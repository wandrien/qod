define @emERROR      "Ошибка"
define @emNOMEMORY   "Недостаточно памяти"
define @emNUMBER     "Тpебуется цифpа"
define @emLONG       "Константа слишком велика"
define @emSIZE       "Слишком длинный идентификатоp"
define @emDOUBLE     "Повтоp имени"
define @emCOMMA      "Пpопущена запятая"
define @emCOLON      "Пpопущено двоеточие"
define @emSEGMENT    "Не указан сегментный pегистp"
define @emBRACKET    "Пpопущена скобка"
define @emINDEX      "Не указан индексный pегистp"
define @emUNDEFINED  "Метка не опpеделена: "

define  bfSIZE     2048 // 1024
define  ttSIZE     1024
define  ltSIZE     2320 // 2336 // 2368 // 2560
define  jtSIZE     2560
define  ctSIZE     3328 // 3392 // 1024
define  mtSIZE      128
define  idSIZE        7

define  cmBYTE        0
define  cmMOVE        1
define  cmMOVS        2
define  cmLOAD        3
define  cmPUSH        4
define  cmINCR        5
define  cmMULT        6
define  cmSIGN        7 // cmJUMP        7
define  cmSHFT        8 // cmCOND        8
define  cmJUMP        9 // cmRETN        9
define  cmCOND       10 // cmSIGN       10
define  cmINTR       11 // cmINTR       11
define  cmRETN       12 // cmSHFT       12
define  cmLD87       13
define  cmOP87       14
define  cmCHAR       15
define  cmWORD       16
define  cmEVEN       17
define  cmNULL       18

define  opVAL         0
define  opREG         1
define  opSEG         2
define  opMEM         3

define  EOF         #26

define  smSCAN        0
define  smSORT        1
define  smHASH        2

struct OpInfo
  word ID;     // byte
  word Reg;    // byte
  word Ptr;    // byte
  word Ofs;
end

struct TMemo
  char @Name;
  word  ID;    // byte
  word  Code1; // byte
  word  Code2; // byte
end

struct TLabel
  char Name [idSIZE];
  word IP;
end
/*
struct TJump
  char Name [idSIZE];
  char Near;   // byte
  word IP;
end
*/
struct TConst
  char Name [idSIZE];
  char Type;
  word Ofs;
  word IP;
end

TLabel LTabl [ltSIZE];
word   nLabel;
/*
TJump  JTabl [jtSIZE];
word   nJump;
*/
TConst CTabl [ctSIZE];
word   nConst;

TMemo  MTabl [mtSIZE];
word   nMemo;

char   Buff  [bfSIZE];
word   pChar;
word   nChar;

word   Line;

byte   Temp  [ttSIZE];
word   pTemp;

word   IP;

char   Name  [    13];
word   F1;
word   F2;

char   Alpha [   256];

word CharToByte(char Ch)
  void  @P=@Ch;
  word  @W=@P;
  return W&255;
end

word CharToWord(char Ch)
  void  @P=@Ch;
  word  @W=@P;
  return W&255;
end

char WordToChar(word W)
  void  @P=@W;
  char  @C=@P;
  return C;
end

void @Ptr(word Seg, Ofs)
  void   @P1=@Ofs;
  void  @@P2=@P1;
  return @P2;
end

word isalnum(char Ch)
  select
    case 'a'<=Ch & Ch<='z':
      return 0;

    case 'A'<=Ch & Ch<='Z':
      return 0;

    case '0'<=Ch & Ch<='9':
      return 0;

    case Ch='@':
      return 0;

    case Ch='_':
      return 0;
  end

  return     1;
end

word strlen(char @Buff)
  word P=0;
  while Buff[P]!=#0 do
    inc P;
  end
  return P;
end

word strcmp(char @St1, @St2)
  word P=0;
  while TRUE do
    if St1[P]!=St2[P] then
      return 1;
    end
    if St1[P]=#0 then
      return 0;
    end
    inc P;
  end
end

char @strcpy(char @Dst, @Src)
  word P=0;
  while Src[P]!=#0 do
    Dst[P]=Src[P];
    inc P;
  end
  Dst[P]=#0;
  return @Dst;
end

char @strcat(char @Dst, @Src)
  word P=strlen(@Dst);
  word Q=0;
  while Src[Q]!=#0 do
    Dst[P]=Src[Q];
    inc P;
    inc Q;
  end
  Dst[P]=#0;
  return @Dst;
end

word GetPSP()
  asm mov     AH,62H
  asm int     21H
  asm mov     AX,BX
end

word create(char @Name)
  asm push    DS
  asm mov     AH,3CH
  asm mov     CX,00H
  asm mov     DX,SS:[BP+6]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+4]
  asm int     21H
  asm pop     DS
end

word open(char @Name)
  asm push    DS
  asm mov     AH,3DH
  asm mov     AL,00H
  asm mov     DX,SS:[BP+6]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+4]
  asm int     21H
  asm db      73H, 03H
  asm mov     AX,0FFFFH
  asm pop     DS
end

word read(word F; void @Buff; word N)
  asm push    DS
  asm mov     AH,3FH
  asm mov     BX,SS:[BP+10]
  asm mov     CX,SS:[BP+4]
  asm mov     DX,SS:[BP+8]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+6]
  asm int     21H
  asm pop     DS
end

word write(word F; void @Buff; word N)
  asm push    DS
  asm mov     AH,40H
  asm mov     BX,SS:[BP+10]
  asm mov     CX,SS:[BP+4]
  asm mov     DX,SS:[BP+8]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+6]
  asm int     21H
  asm pop     DS
end

word seek(word F; word P)
  asm push    DS
  asm mov     AX,4200H
  asm mov     BX,SS:[BP+6]
  asm mov     CX,0
  asm mov     DX,SS:[BP+4]
  asm int     21H
  asm pop     DS
end

void close(word F)
  asm mov     AH,3EH
  asm mov     BX,SS:[BP+4]
  asm int     21H
end

void putc(char Ch)
  asm mov     AH,2
  asm mov     DL,SS:[BP+4]
  asm int     21H
end

void puts(char @St)
  word P=0;
  while St[P]!=#0 do
    putc(St[P]);
    inc P;
  end
end

void outs(char @St)
  puts(@St);
  putc(#13);
  putc(#10);
end

define  HASH 23173

word Hash(char @Name)
  word  H=0;
  word  I=0;
  while Name[I]!=#0 do
    H=HASH*H+CharToWord(Name[I]);
    inc I;
  end

  return H;
end

word Mode;

void Push(char @name; word id; word code1, code2) // byte id; byte code1, code2
  select
    case Mode=smHASH:
      word   P=Hash(@name)%mtSIZE;
    //while @MTabl[P].Name[0]!=NULL do
      while  MTabl[P].Name   !=#0   do
        inc  P;
        if   P>=mtSIZE then
          P=0;
        end
      end

     @MTabl[P]    .Name =@name;
      MTabl[P]    .ID   = id;
      MTabl[P]    .Code1= code1;
      MTabl[P]    .Code2= code2;

    default:
     @MTabl[nMemo].Name =@name;
      MTabl[nMemo].ID   = id;
      MTabl[nMemo].Code1= code1;
      MTabl[nMemo].Code2= code2;
      inc   nMemo;
  end
end

void Info()
  char Buff[256];
  word P=0;
  while Name[P]!=#0 do
    Buff[P]=Name[P];
    inc  P;
  end

  Buff[P]='(';
  inc  P;

  char @D =  "0123456789";
  char  Temp [8];
  word  N=Line;
  word  K=0;

  while K=0 | N>0 do
    Temp[K]=D[N%10];
    inc  K;

    N=N/10;
  end

  while K>0 do
    dec  K;
    Buff[P]=Temp[K];
    inc  P;
  end

  Buff[P]=')';
  inc  P;

  Buff[P]=#0;

  putc(#13);
  puts(@Buff);
end

void Stop(char @EM)
  Info ();

  puts(": ");
  puts(@EM);

  close(F2);
  close(F1);

  asm mov     AX,4C00H
  asm int     21H
end

word Val(char @Buff)
  char @D = "0123456789ABCDEF";
  word  L;
  word  H;
  word  E;
  word  P;

  E=10;
  P= 0;
  while Buff[P]!=#0 do
    if E!=10 then
      Stop(@emNUMBER);
    end
    if Buff[P]='H' then
      E=16;
    end
    inc P;
  end

  L=0;
  H=0;

  P=0;
  while Buff[P]!=#0 & Buff[P]!='H' do
    word  S=0;
    while D[S]!=#0 & D[S]!=Buff[P] do
      inc S;
    end

    if S>=E then
      Stop(@emNUMBER);
    end

    L=E*L+S;
    S=L/256;
    L=L%256;
    H=E*H+S;

    if H>255 then
      Stop(@emLONG);
    end

    inc P;
  end

  return 256*H+L;
end

word DB;

void Code(byte C)
  while DB>0 do
    if pTemp>=ttSIZE then
      write(F2,@Temp,ttSIZE);
      pTemp=0;
    end

    Temp[pTemp]=0;
    inc  pTemp;

    inc  IP;

    dec  DB;
  end

  if pTemp>=ttSIZE then
    write(F2,@Temp,ttSIZE);
    pTemp=0;
  end

  Temp[pTemp]=C;
  inc  pTemp;

  inc  IP;
end

char Read()
  if pChar>=nChar then
    nChar=read(F1,@Buff,bfSIZE);
    if nChar<1 then
      return EOF;
    end
    pChar=0;
  end
  return Buff[pChar];
end

void Next()
  inc pChar;
end

char @Scan(char @Buff)
/*while Read()=#09 | Read()=#13 | Read()=#32 do
    Next();
  end*/

/*char  Ch;
  void @PC = @Ch;
  word @PW = @PC;

  while TRUE do
    Ch=Read();
    if Ch!=#09 then
      if Ch!=#13 then
        if Ch!=#32 then
          exit
        end
      end
    end

    Next();
  end*/

  char  Ch =  Read();
  void @PC = @Ch;
  word @PW = @PC;

  while Alpha[PW & $FF]='S' do
    Next();

    Ch=Read();
  end

//if Read()=';' then
  if Ch=';' then
  /*while Read()!=#10 & Read()!=EOF do
      Next();
    end*/

  /*while TRUE do
      Ch=Read();
      if Ch=#10 then
        exit
      end

      if Ch=EOF then
        exit
      end

      Next();
    end*/

    Next();

    Ch=Read();
    while Alpha[PW & $FF]!='N' do
      Next();

      Ch=Read();
    end
  end

//if Read()=#10 then
  if Ch=#10 then
    inc  Line;
  //if   Line% 100=0 then
    if   Line%1000=0 then
      Info();
    end

    Next();

  //return  @strcpy(@Buff,";");

    Buff[0]=';';
    Buff[1]=#0;

    return  @Buff;
  end

/*word P=0;
//while isalnum(Read())=0 do
//while isalnum(Ch)=0 do
  while Alpha[PW & $FF]='A' do
  //Buff[P]=Read();
    Buff[P]=Ch;
    inc  P;
    if   P>=idSIZE then
      Stop(@emSIZE);
    end

    Next();

    Ch=Read();
  end

  if P=0 then
  //Buff[P]=Read(); Next();
    Buff[P]=Ch;
    inc  P;

    Next();
  end

  Buff[P]=#0;*/

  Buff[0]=Ch;

  select
    case Alpha[PW & $FF]='A':
      word P=1;

      Next();

      Ch=Read();
      while Alpha[PW & $FF]='A' do
        Buff[P]=Ch;
        inc  P;
        if   P>=idSIZE then
          Stop(@emSIZE);
        end

        Next();

        Ch=Read();
      end

      Buff[P]=#0;

    default:
      Buff[1]=#0;

      Next();
  end

  return  @Buff;
end

word FindMemo(char @Name)
  select
    case Mode=smSCAN:
      word  I=0;
      while I<nMemo do
        if strcmp(@MTabl[I].Name,@Name)=0 then
          return I;
        end

        inc I;
      end

    case Mode=smSORT:
      word  L=0;
      word  R=nMemo;
      while L<R do
        word  S=(L+R)/2;
        word  P=0;
        while TRUE do
          char C=MTabl[S].Name[P];
          char D=Name [P];

          if C<D then
            L=S+1;
            exit
          end

          if C>D then
            R=S;
            exit
          end

          if C=#0 then
            return S;
          end

          inc P;
        end
      end

    case Mode=smHASH:
      word   P=Hash(@Name)%mtSIZE;
    //while @MTabl[P].Name[0]!=NULL do
      while  MTabl[P].Name   !=#0   do
        if strcmp(@MTabl[P].Name,@Name)=0 then
          return P;
        end

        inc P;
        if  P>=mtSIZE then
          P=0;
        end
      end
  end

  return mtSIZE;
end


word FindLabel(char @Name; word Flag)
  select
    case Mode=smSCAN:
      word  F=0;
      word  P=0;
      while P<nLabel do
        if strcmp(@LTabl[P].Name,@Name)=0 then
          F=1;
          exit
        end

        inc P;
      end

      if F=1 then
        if Flag!=0 then
          Stop(@emDOUBLE);
        end

        return P;
      end

      if Flag!=0 then
        if nLabel>=ltSIZE then
          Stop(@emNOMEMORY);
        end

        LTabl[P].IP=IP+DB; /* DB! */ strcpy(@LTabl[P].Name,@Name);
        inc   nLabel;
      end

    case Mode=smSORT:
      word  L=0;
      word  R=nLabel;
      while L<R do
        word  S=(L+R)/2;
        word  P=0;
        while TRUE do
          char C=LTabl[S].Name[P];
          char D=Name [P];

          if C<D then
            L=S+1;
            exit
          end

          if C>D then
            R=S;
            exit
          end

          if C=#0 then
            if Flag!=0 then
              Stop(@emDOUBLE);
            end

            return S;
          end

          inc P;
        end
      end

      if Flag!=0 then
        if nLabel>=ltSIZE then
          Stop(@emNOMEMORY);
        end

        word  P=nLabel;
        while L<P do
          LTabl[P].IP=LTabl[P-1].IP; strcpy(@LTabl[P].Name,@LTabl[P-1].Name);
          dec   P;
        end

        LTabl[P].IP=IP+DB; /* DB! */ strcpy(@LTabl[P].Name,@Name);
        inc   nLabel;
      end

    case Mode=smHASH:
      word  P=Hash(@Name)%ltSIZE;
      word  F=0;
      while LTabl[P].Name[0]!=#0 do
        if strcmp(@LTabl[P].Name,@Name)=0 then
          F=1;
          exit
        end

        inc P;
        if  P>=ltSIZE then
          P=0;
        end
      end

      if F=1 then
        if Flag!=0 then
          Stop(@emDOUBLE);
        end

        return P;
      end

      if Flag!=0 then
      /*if nLabel>=ltSIZE then
          Stop(@emNOMEMORY);
        end*/

        LTabl[P].IP=IP+DB; /* DB! */ strcpy(@LTabl[P].Name,@Name);
        inc   nLabel;
        if    nLabel>=ltSIZE then
          Stop(@emNOMEMORY);
        end
      end
  end

//return nLabel;
  return ltSIZE;
end

void Data(char @Buff; OpInfo @Op)
  Op.ID =opREG;
  Op.Ptr=0;
  Op.Ofs=0;

  word  Flag=0;

//Scan(@Buff); // 15.09.2003
/*select
    case strcmp(@Buff,"AL")=0:
      Op.Reg=0;
    case strcmp(@Buff,"CL")=0:
      Op.Reg=1;
    case strcmp(@Buff,"DL")=0:
      Op.Reg=2;
    case strcmp(@Buff,"BL")=0:
      Op.Reg=3;
    case strcmp(@Buff,"AH")=0:
      Op.Reg=4;
    case strcmp(@Buff,"CH")=0:
      Op.Reg=5;
    case strcmp(@Buff,"DH")=0:
      Op.Reg=6;
    case strcmp(@Buff,"BH")=0:
      Op.Reg=7;
    case strcmp(@Buff,"AX")=0:
      Op.Reg=0;
      Op.Ptr=1;
    case strcmp(@Buff,"CX")=0:
      Op.Reg=1;
      Op.Ptr=1;
    case strcmp(@Buff,"DX")=0:
      Op.Reg=2;
      Op.Ptr=1;
    case strcmp(@Buff,"BX")=0:
      Op.Reg=3;
      Op.Ptr=1;
    case strcmp(@Buff,"SP")=0:
      Op.Reg=4;
      Op.Ptr=1;
    case strcmp(@Buff,"BP")=0:
      Op.Reg=5;
      Op.Ptr=1;
    case strcmp(@Buff,"SI")=0:
      Op.Reg=6;
      Op.Ptr=1;
    case strcmp(@Buff,"DI")=0:
      Op.Reg=7;
      Op.Ptr=1;
    case strcmp(@Buff,"ES")=0:
      Op.ID =opSEG;
      Op.Reg=0;
    case strcmp(@Buff,"CS")=0:
      Op.ID =opSEG;
      Op.Reg=1;
    case strcmp(@Buff,"SS")=0:
      Op.ID =opSEG;
      Op.Reg=2;
    case strcmp(@Buff,"DS")=0:
      Op.ID =opSEG;
      Op.Reg=3;
    case strcmp(@Buff,"offset")=0:
      if nConst>=ctSIZE then
        Stop(@emNOMEMORY);
      end

      CTabl[nConst].IP  = IP+1; strcpy(@CTabl[nConst].Name,@Scan(@Buff));
      CTabl[nConst].Type='C';

      word N=256;
      if strcmp(@Scan(@Buff),"+")=0 then
        N=N+Val(@Scan(@Buff));
        Scan(@Buff); // 15.09.2003
    /*else
        Keep();*/
      end

      CTabl[nConst].Ofs=N;
      inc   nConst;

      Op.ID=opVAL;

      return

    default:
      if '0'<=Buff & Buff<='9' then
        Op.ID =opVAL;
        Op.Ofs=Val(@Buff);

        Scan(@Buff); // 15.09.2003

        return
      else
        if nConst>=ctSIZE then
          Stop(@emNOMEMORY);
        end

        CTabl[nConst].IP  =IP+DB+3; /* DB! */ strcpy(@CTabl[nConst].Name,@Buff);
        CTabl[nConst].Type='C';

        Op.ID =opSEG;
        Op.Reg=1;
        Flag  =1;
      end
  end*/

  char Ch =Buff[2];
  word Def=0;
  select
    case Ch=#0:
      Ch=Buff[1];
      select
        case Ch='L':
          Ch=Buff[0];
          select
            case Ch='A':
              Op.Reg=0;
            case Ch='C':
              Op.Reg=1;
            case Ch='D':
              Op.Reg=2;
            case Ch='B':
              Op.Reg=3;
            default:
              Def   =1;
          end

        case Ch='H':
          Ch=Buff[0];
          select
            case Ch='A':
              Op.Reg=4;
            case Ch='C':
              Op.Reg=5;
            case Ch='D':
              Op.Reg=6;
            case Ch='B':
              Op.Reg=7;
            default:
              Def   =1;
          end

        case Ch='X':
          Ch=Buff[0];
          select
            case Ch='A':
              Op.Reg=0;
              Op.Ptr=1;
            case Ch='C':
              Op.Reg=1;
              Op.Ptr=1;
            case Ch='D':
              Op.Reg=2;
              Op.Ptr=1;
            case Ch='B':
              Op.Reg=3;
              Op.Ptr=1;
            default:
              Def   =1;
          end

        case Ch='P':
          Ch=Buff[0];
          select
            case Ch='S':
              Op.Reg=4;
              Op.Ptr=1;
            case Ch='B':
              Op.Reg=5;
              Op.Ptr=1;
            default:
              Def   =1;
          end

        case Ch='I':
          Ch=Buff[0];
          select
            case Ch='S':
              Op.Reg=6;
              Op.Ptr=1;
            case Ch='D':
              Op.Reg=7;
              Op.Ptr=1;
            default:
              Def   =1;
          end

        case Ch='S':
          Ch=Buff[0];
          select
            case Ch='E':
              Op.ID =opSEG;
              Op.Reg=0;
            case Ch='C':
              Op.ID =opSEG;
              Op.Reg=1;
            case Ch='S':
              Op.ID =opSEG;
              Op.Reg=2;
            case Ch='D':
              Op.ID =opSEG;
              Op.Reg=3;
            default:
              Def   =1;
          end

        default:
          Def=1;
      end

    default:
      Def=1;
  end

  if Def!=0 then
    select
      case strcmp(@Buff,"offset")=0:
        if nConst>=ctSIZE then
          Stop(@emNOMEMORY);
        end

        CTabl[nConst].IP  = IP+1; strcpy(@CTabl[nConst].Name,@Scan(@Buff));
        CTabl[nConst].Type='C';

        word N=256;
      //if strcmp(@Scan(@Buff),"+")=0 then
        if Scan(@Buff)='+' then
          N=N+Val(@Scan(@Buff));
          Scan(@Buff); // 15.09.2003
      /*else
          Keep();*/
        end

        CTabl[nConst].Ofs=N;
        inc   nConst;

        Op.ID=opVAL;

        return

      default:
        if '0'<=Buff & Buff<='9' then
          Op.ID =opVAL;
          Op.Ofs=Val(@Buff);

          Scan(@Buff); // 15.09.2003

          return
        else
          if nConst>=ctSIZE then
            Stop(@emNOMEMORY);
          end

          CTabl[nConst].IP  =IP+DB+3; /* DB! */ strcpy(@CTabl[nConst].Name,@Buff);
          CTabl[nConst].Type='C';

          Op.ID =opSEG;
          Op.Reg=1;
          Flag  =1;
        end
    end
  end

  if Flag=0 then
  //if strcmp(@Scan(@Buff),":")!=0 then
    if Scan(@Buff)!=':' then
    //Keep();
      return
    end
  end

//if strcmp(@Scan(@Buff),"[")!=0 then
  if Scan(@Buff)!='[' then
    if Flag!=0 then
      CTabl[nConst].Ofs=256;
      inc   nConst;

      Op.ID =opMEM;
      Op.Ptr=    8;
      Op.Ofs=$FFFF;

    //Keep();

      return
    end

    Stop(@emBRACKET);
  end

  if Op.ID!=opSEG then
    Stop(@emSEGMENT);
  end

  Op.ID=opMEM;

  Scan(@Buff);
/*select
    case strcmp(@Buff,"SI")=0:
      Op.Ptr=4;
    case strcmp(@Buff,"DI")=0:
      Op.Ptr=5;
    case strcmp(@Buff,"BP")=0:
      Op.Ptr=6;
    case strcmp(@Buff,"BX")=0:
      Op.Ptr=7;
    default:
      Op.Ptr=8;
      Op.Ofs=Val(@Buff);
      if strcmp(@Scan(@Buff),"]")!=0 then
        Stop(@emBRACKET);
      end

      if Flag!=0 then
        CTabl[nConst].Ofs=Op.Ofs+256;
        inc   nConst;

        Op.Ofs=$FFFF;
      end

      Scan(@Buff); // 15.09.2003

      return
  end*/

  Ch =Buff[2];
  Def=0;
  select
    case Ch=#0:
      Ch=Buff[1];
      select
        case Ch='I':
          Ch=Buff[0];
          select
            case Ch='S':
              Op.Ptr=4;
            case Ch='D':
              Op.Ptr=5;
            default:
              Def   =1;
          end

        case Ch='P':
          Ch=Buff[0];
          select
            case Ch='B':
              Op.Ptr=6;
            default:
              Def   =1;
          end

        case Ch='X':
          Ch=Buff[0];
          select
            case Ch='B':
              Op.Ptr=7;
            default:
              Def   =1;
          end

        default:
          Def=1;
      end

    default:
      Def=1;
  end

  if Def!=0 then
    Op.Ptr=8;
    Op.Ofs=Val(@Buff);
  //if strcmp(@Scan(@Buff),"]")!=0 then
    if Scan(@Buff)!=']' then
      Stop(@emBRACKET);
    end

    if Flag!=0 then
      CTabl[nConst].Ofs=Op.Ofs+256;
      inc   nConst;

      Op.Ofs=$FFFF;
    end

    Scan(@Buff); // 15.09.2003

    return
  end

//if strcmp(@Scan(@Buff),"]")=0 then
  if Scan(@Buff)=']' then
  //if strcmp(@Scan(@Buff),"[")!=0 then
    if Scan(@Buff)!='[' then
      if Flag!=0 then
        CTabl[nConst].Ofs=Op.Ofs+256;
        inc   nConst;

        Op.Ofs=$FFFF;
      end

    //Keep();

      return
    end

    Scan(@Buff);
  /*select
      case strcmp(@Buff,"SI")=0:
        select
          case Op.Ptr=6:
            Op.Ptr=2;
          case Op.Ptr=7:
            Op.Ptr=0;
          default:
            Stop(@emINDEX);
        end
      case strcmp(@Buff,"DI")=0:
        select
          case Op.Ptr=6:
            Op.Ptr=3;
          case Op.Ptr=7:
            Op.Ptr=1;
          default:
            Stop(@emINDEX);
        end
      default:
        Stop(@emINDEX);
    end*/

    Ch=Buff[2];
    select
      case Ch=#0:
        Ch=Buff[1];
        select
          case Ch='I':
            Ch=Buff[0];
            select
              case Ch='S':
                select
                  case Op.Ptr=6:
                    Op.Ptr=2;
                  case Op.Ptr=7:
                    Op.Ptr=0;
                  default:
                    Stop(@emINDEX);
                end

              case Ch='D':
                select
                  case Op.Ptr=6:
                    Op.Ptr=3;
                  case Op.Ptr=7:
                    Op.Ptr=1;
                  default:
                    Stop(@emINDEX);
                end

              default:
                Stop(@emINDEX);
            end

          default:
            Stop(@emINDEX);
        end

      default:
        Stop(@emINDEX);
    end

    Scan(@Buff);
  end

  select
  //case strcmp(@Buff,"+")=0:
    case Buff='+':
      Op.Ofs=Val(@Scan(@Buff));
      Scan(@Buff);
  //case strcmp(@Buff,"-")=0:
    case Buff='-':
      Op.Ofs=($FFFF-Val(@Scan(@Buff)))+1;
      Scan(@Buff);
  end

//if strcmp(@Buff,"]")!=0 then
  if Buff!=']' then
    Stop(@emBRACKET);
  end

  if Flag!=0 then
    CTabl[nConst].Ofs=Op.Ofs+256;
    inc   nConst;

    Op.Ofs=$FFFF;
  end

  Scan(@Buff); // 15.09.2003
end

begin
  word @Size=@Ptr(GetPSP(),128); // byte
  char @Parm=@Ptr(GetPSP(),129);
  char  Buff [256];

  word  I=0;
  while I<Size%256 & Parm[I] =' ' do
    inc I;
  end

  word  P=0;
  word  N=0;
  word  K=0;
  while I<Size%256 & Parm[I]!=' ' do
    Buff[K]=Parm[I];
    select
      case (Buff[K]='.'):
        P=K;

      case (Buff[K]='\'):
        N=K+1;
        P=0;
    end

    inc  K;
    inc  I;
  end
  Buff[K]=#0;

  if K=0 then
    outs("Ассемблеp для 8086/8088.  Веpсия 1.1");
    outs("(C) Хохлов А.В.  г. Москва 1997-2003");
    outs("Использование:  asm8086  <имя файла>");
    return
  end

  if P=0 then
    P=K;
    strcpy(@Buff[P],".ASM");
  end

  if strlen(@Buff[N])>12 then
    puts(@Buff[N]);
    puts("(0): Слишком длинное имя файла");
    return
  end

  strcpy(@Name,@Buff[N]);

  F1=open(@Buff);
  if F1=$FFFF then
    puts(@Name);
    puts("(0): Невозможно откpыть файл");
    return
  end

  strcpy(@Buff[P],".COM");

  F2=create(@Buff);

  I=0;
  while I<=255 do
    select
      case isalnum(WordToChar(I))=0:
        Alpha[I]='A';

      case I= 9 | I=13 | I=32:
        Alpha[I]='S';

      case I=10 | I=CharToWord(EOF):
        Alpha[I]='N';

      default:
        Alpha[I]='C';
    end

    inc I;
  end

  Line  =1;

  nChar =0;
  pChar =0;
  pTemp =0;

  nLabel=0;
//nJump =0;
  nConst=0;
  nMemo =0;

  Mode  =smSORT;

  select
    case Mode=smHASH:
      I=0;
      while   I<mtSIZE do
     //@MTabl[I].Name=NULL;
       @MTabl[I].Name="";
        inc   I;
      end

      I=0;
      while   I<ltSIZE do
        LTabl[I].Name[0]=#0;
        inc   I;
      end
  end

  IP    =0;
  DB    =0;

/*Push("mov",   cmMOVE,$88,$C6);
  Push("xchg",  cmMOVE,$86,$00);
  Push("add",   cmMOVE,$00,$80);
  Push("adc",   cmMOVE,$10,$80);
  Push("sub",   cmMOVE,$28,$80);
  Push("sbb",   cmMOVE,$18,$80);
  Push("cmp",   cmMOVE,$38,$80);
  Push("or",    cmMOVE,$08,$80);
  Push("and",   cmMOVE,$20,$80);
  Push("test",  cmMOVE,$84,$F6);
  Push("xor",   cmMOVE,$30,$80);
  Push("rep",   cmMOVS,$F3,$00);
  Push("repe",  cmMOVS,$F3,$00);
  Push("repne", cmMOVS,$F2,$00);
  Push("lds",   cmLOAD,$C5,$00);
  Push("les",   cmLOAD,$C4,$00);
  Push("push",  cmPUSH,$50,$06);
  Push("pop",   cmPUSH,$58,$07);
  Push("inc",   cmINCR,$40,$00);
  Push("dec",   cmINCR,$48,$08);
  Push("mul",   cmMULT,$F6,$E0);
  Push("div",   cmMULT,$F6,$F0);
  Push("imul",  cmMULT,$F6,$E8);
  Push("idiv",  cmMULT,$F6,$F8);
  Push("not",   cmSIGN,$F6,$D0);
  Push("neg",   cmSIGN,$F6,$D8);
  Push("shl",   cmSHFT,$00,$E0);
  Push("shr",   cmSHFT,$00,$E8);
  Push("jmp",   cmJUMP,$E9,$00);
  Push("call",  cmJUMP,$E8,$00);
  Push("jo",    cmCOND,$70,$00);
  Push("jno",   cmCOND,$71,$00);
  Push("jb",    cmCOND,$72,$00);
  Push("jae",   cmCOND,$73,$00);
  Push("jz",    cmCOND,$74,$00);
  Push("je",    cmCOND,$74,$00);
  Push("jnz",   cmCOND,$75,$00);
  Push("jne",   cmCOND,$75,$00);
  Push("jbe",   cmCOND,$76,$00);
  Push("ja",    cmCOND,$77,$00);
  Push("js",    cmCOND,$78,$00);
  Push("jns",   cmCOND,$79,$00);
  Push("jp",    cmCOND,$7A,$00);
  Push("jnp",   cmCOND,$7B,$00);
  Push("jl",    cmCOND,$7C,$00);
  Push("jnl",   cmCOND,$7D,$00);
  Push("jge",   cmCOND,$7D,$00);
  Push("jng",   cmCOND,$7E,$00);
  Push("jle",   cmCOND,$7E,$00);
  Push("jg",    cmCOND,$7F,$00);
  Push("retn",  cmRETN,$00,$00);
  Push("int",   cmINTR,$00,$00);
  Push("iret",  cmBYTE,$CF,$00);
  Push("cbw",   cmBYTE,$98,$00);
  Push("cwd",   cmBYTE,$99,$00);
  Push("cli",   cmBYTE,$FA,$00);
  Push("sti",   cmBYTE,$FB,$00);
  Push("cld",   cmBYTE,$FC,$00);
  Push("std",   cmBYTE,$FD,$00);
  Push("lahf",  cmBYTE,$9F,$00);
  Push("sahf",  cmBYTE,$9E,$00);
  Push("fld",   cmLD87,$D9,$00);
  Push("fild",  cmLD87,$DB,$00);
  Push("fstp",  cmLD87,$D9,$18);
  Push("fistp", cmLD87,$DB,$18);
  Push("fstsw", cmLD87,$DD,$38);
  Push("finit", cmOP87,$DB,$E3);
  Push("fldz",  cmOP87,$D9,$EE);
  Push("faddp", cmOP87,$DE,$C1);
  Push("fsubp", cmOP87,$DE,$E9);
  Push("fmulp", cmOP87,$DE,$C9);
  Push("fdivp", cmOP87,$DE,$F9);
  Push("fsubrp",cmOP87,$DE,$E1);
  Push("fdivrp",cmOP87,$DE,$F1);
  Push("fcompp",cmOP87,$DE,$D9);
  Push("fwait", cmBYTE,$9B,$00);
  Push("db",    cmCHAR,$00,$00);
  Push("dw",    cmWORD,$00,$00);
  Push("even",  cmEVEN,$90,$00);
  Push("nop",   cmNULL,$90,$00);*/

  Push("adc",   cmMOVE,$10,$80);
  Push("add",   cmMOVE,$00,$80);
  Push("and",   cmMOVE,$20,$80);
  Push("call",  cmJUMP,$E8,$00);
  Push("cbw",   cmBYTE,$98,$00);
  Push("cld",   cmBYTE,$FC,$00);
  Push("cli",   cmBYTE,$FA,$00);
  Push("cmp",   cmMOVE,$38,$80);
  Push("cwd",   cmBYTE,$99,$00);
  Push("db",    cmCHAR,$00,$00);
  Push("dec",   cmINCR,$48,$08);
  Push("div",   cmMULT,$F6,$F0);
  Push("dw",    cmWORD,$00,$00);
  Push("even",  cmEVEN,$90,$00);
  Push("faddp", cmOP87,$DE,$C1);
  Push("fcompp",cmOP87,$DE,$D9);
  Push("fdivp", cmOP87,$DE,$F9);
  Push("fdivrp",cmOP87,$DE,$F1);
  Push("fild",  cmLD87,$DB,$00);
  Push("finit", cmOP87,$DB,$E3);
  Push("fistp", cmLD87,$DB,$18);
  Push("fld",   cmLD87,$D9,$00);
  Push("fldz",  cmOP87,$D9,$EE);
  Push("fmulp", cmOP87,$DE,$C9);
  Push("fstp",  cmLD87,$D9,$18);
  Push("fstsw", cmLD87,$DD,$38);
  Push("fsubp", cmOP87,$DE,$E9);
  Push("fsubrp",cmOP87,$DE,$E1);
  Push("fwait", cmBYTE,$9B,$00);
  Push("idiv",  cmMULT,$F6,$F8);
  Push("imul",  cmMULT,$F6,$E8);
  Push("inc",   cmINCR,$40,$00);
  Push("int",   cmINTR,$00,$00);
  Push("iret",  cmBYTE,$CF,$00);
  Push("ja",    cmCOND,$77,$00);
  Push("jae",   cmCOND,$73,$00);
  Push("jb",    cmCOND,$72,$00);
  Push("jbe",   cmCOND,$76,$00);
  Push("je",    cmCOND,$74,$00);
  Push("jg",    cmCOND,$7F,$00);
  Push("jge",   cmCOND,$7D,$00);
  Push("jl",    cmCOND,$7C,$00);
  Push("jle",   cmCOND,$7E,$00);
  Push("jmp",   cmJUMP,$E9,$00);
  Push("jne",   cmCOND,$75,$00);
  Push("jng",   cmCOND,$7E,$00);
  Push("jnl",   cmCOND,$7D,$00);
  Push("jno",   cmCOND,$71,$00);
  Push("jnp",   cmCOND,$7B,$00);
  Push("jns",   cmCOND,$79,$00);
  Push("jnz",   cmCOND,$75,$00);
  Push("jo",    cmCOND,$70,$00);
  Push("jp",    cmCOND,$7A,$00);
  Push("js",    cmCOND,$78,$00);
  Push("jz",    cmCOND,$74,$00);
  Push("lahf",  cmBYTE,$9F,$00);
  Push("lds",   cmLOAD,$C5,$00);
  Push("les",   cmLOAD,$C4,$00);
  Push("mov",   cmMOVE,$88,$C6);
  Push("mul",   cmMULT,$F6,$E0);
  Push("neg",   cmSIGN,$F6,$D8);
  Push("nop",   cmNULL,$90,$00);
  Push("not",   cmSIGN,$F6,$D0);
  Push("or",    cmMOVE,$08,$80);
  Push("pop",   cmPUSH,$58,$07);
  Push("push",  cmPUSH,$50,$06);
  Push("rep",   cmMOVS,$F3,$00);
  Push("repe",  cmMOVS,$F3,$00);
  Push("repne", cmMOVS,$F2,$00);
  Push("retn",  cmRETN,$00,$00);
  Push("sahf",  cmBYTE,$9E,$00);
  Push("sbb",   cmMOVE,$18,$80);
  Push("shl",   cmSHFT,$00,$E0);
  Push("shr",   cmSHFT,$00,$E8);
  Push("std",   cmBYTE,$FD,$00);
  Push("sti",   cmBYTE,$FB,$00);
  Push("sub",   cmMOVE,$28,$80);
  Push("test",  cmMOVE,$84,$F6);
  Push("xchg",  cmMOVE,$86,$00);
  Push("xor",   cmMOVE,$30,$80);

  Scan(@Buff);
  while Buff[0]!=EOF do
  //if strcmp(@Buff,";")=0 then
    if Buff[0]=';' then
      Scan(@Buff); // 15.09.2003
      loop
    end

    word H;
    select
      case Mode=smHASH:
        H=Hash(@Buff);
        I=H%mtSIZE;
        while TRUE do
        //if @MTabl[I].Name[0]=NULL then
          if  MTabl[I].Name   =#0   then
            I=mtSIZE;
            exit
          end

          if strcmp(@MTabl[I].Name,@Buff)=0 then
            exit
          end

          inc I;
          if  I>=mtSIZE then
            I=0;
          end
        end

      default:
        I=FindMemo(@Buff);
    end

  //if I< nMemo then
    if I<mtSIZE then       // 20.05.2007
      word ID=MTabl[I].ID; // byte
      select
        case ID=cmBYTE:
          Code(MTabl[I].Code1);
          Scan(@Buff); // 15.09.2003

        case ID=cmMOVE:
          OpInfo Op1,Op2;

          Data(@Scan(@Buff),@Op1);

        //if strcmp(@Scan(@Buff),",")!=0 then
        //if strcmp(@Buff,",")!=0 then // 15.09.2003
          if Buff[0]!=',' then
            Stop(@emCOMMA);
          end

          Data(@Scan(@Buff),@Op2); // 15.09.2003

          select
            case Op1.ID=opVAL:
              Stop(@emERROR);

            case Op2.ID=opVAL:
              if Op1.ID!=opREG then
                Stop(@emERROR);
              end

              if Op1.ID=opREG & strcmp(@MTabl[I].Name,"mov")=0 then
                word C=$B0; // byte

                if Op1.Ptr=1 then
                  C=C|$08;
                end

                Code(C|Op1.Reg);
              else
                word C=MTabl[I].Code2; // byte
                if strcmp(@MTabl[I].Name,"test")=0 then
                  C=$F6;
                end

                if strcmp(@MTabl[I].Name,"xchg")=0 then
                  Stop(@emERROR);
                end

                if Op1.Ptr=1 then
                  C=C|$01;
                end

                Code(C);
                if strcmp(@MTabl[I].Name,"test")=0 then
                  Code($C0|Op1.Reg);
                else
                  Code($C0|MTabl[I].Code1|Op1.Reg);
                end
              end

              Code(Op2.Ofs%256);
              if Op1.Ptr!=0 then
                Code(Op2.Ofs/256);
              else
                if Op2.Ofs>255 then
                  Stop(@emLONG);
                end
              end

            case Op1.ID=opSEG:
              if strcmp(@MTabl[I].Name,"mov")!=0 then
                Stop(@emERROR);
              end

              select
                case Op2.ID=opREG:
                  if Op2.Ptr!=1 then
                    Stop(@emERROR);
                  end

                  Code($8E);
                  Code($C0|8*Op1.Reg|Op2.Reg);

                default:
                  Stop(@emERROR);
              end

            case Op2.ID=opSEG:
              if strcmp(@MTabl[I].Name,"mov")!=0 then
                Stop(@emERROR);
              end

              if Op1.Ptr!=1 then
                Stop(@emERROR);
              end

              Code($8C);
              Code($C0|8*Op2.Reg|Op1.Reg);

            default:
              word    C= MTabl[I].Code1; // byte
              OpInfo @R=@Op2;
              OpInfo @M=@Op1;

              if Op1.ID=opREG then
                if strcmp(@MTabl[I].Name,"test")!=0 then
                  C=C|$02;
                end
                @R=@Op1;
                @M=@Op2;
              end

              if R.Ptr=1 then
                C=C|$01;
              end

              if R.ID!=opREG then
                Stop(@emERROR);
              end

              select
                case M.ID=opREG:
                  if Op1.Ptr!=Op2.Ptr then
                    Stop(@emERROR);
                  end

                  Code(C);
                  Code($C0|8*R.Reg|M.Reg);

                case M.ID=opMEM:
                  select
                    case M.Ptr=$02 | M.Ptr=$03 | M.Ptr=$06:
                      if M.Reg!=$02 then
                        Code($26|8*M.Reg);
                      end
                    default:
                      if M.Reg!=$03 then
                        Code($26|8*M.Reg);
                      end
                  end

                  Code(C);

                  if M.Ofs>0 then
                    if M.Ptr=8 then
                      Code(8*R.Reg|$06);
                    else
                      Code($80|8*R.Reg|M.Ptr);
                    end
                    Code(M.Ofs%256);
                    Code(M.Ofs/256);
                  else
                    select
                      case M.Ptr=6:
                        Stop(@emERROR);

                      case M.Ptr=8:
                        Code(8*R.Reg|$06);
                        Code($00);
                        Code($00);

                      default:
                        Code(8*R.Reg|M.Ptr);
                    end
                  end

                default:
                  Stop(@emERROR);
              end
          end

        case ID=cmMOVS:
          Scan(@Buff);
          Code(MTabl[I].Code1);
          select
            case strcmp(@Buff,"movsb")=0:
              Code($A4);

            case strcmp(@Buff,"movsw")=0:
              Code($A5);

            case strcmp(@Buff,"cmpsb")=0:
              Code($A6);

            case strcmp(@Buff,"cmpsw")=0:
              Code($A7);

            case strcmp(@Buff,"scasb")=0:
              Code($AE);

            case strcmp(@Buff,"scasw")=0:
              Code($AF);

            default:
              Stop(@emERROR);
          end

          Scan(@Buff); // 15.09.2003

        case ID=cmLOAD:
          OpInfo Op1,Op2;

          Data(@Scan(@Buff),@Op1); // 15.09.2003

        //if strcmp(@Scan(@Buff),",")!=0 then
        //if strcmp(@Buff,",")!=0 then // 15.09.2003
          if Buff[0]!=',' then
            Stop(@emCOMMA);
          end

          if Op1.Ptr!=1 then
            Stop(@emERROR);
          end

          Data(@Scan(@Buff),@Op2); // 15.09.2003

          if Op2.ID!=opMEM then
            Stop(@emERROR);
          end

          select
            case Op2.Ptr=$02 | Op2.Ptr=$03 | Op2.Ptr=$06:
              if Op2.Reg!=$02 then
                Code($26|8*Op2.Reg);
              end
            default:
              if Op2.Reg!=$03 then
                Code($26|8*Op2.Reg);
              end
          end

          Code(MTabl[I].Code1);
          if Op2.Ptr=8 then
            Code(8*Op1.Reg|6);
          else
            Code($80|8*Op1.Reg|Op2.Ptr);
          end
          Code(Op2.Ofs%256);
          Code(Op2.Ofs/256);

        case ID=cmPUSH:
          OpInfo Op;

          Data(@Scan(@Buff),@Op); // 15.09.2003

          select
            case Op.ID=opREG:
              if Op.Ptr=0 then
                Stop(@emERROR);
              end
              Code(MTabl[I].Code1|Op.Reg);
            case Op.ID=opSEG:
              Code(MTabl[I].Code2|8*Op.Reg);
            default:
              Stop(@emERROR);
          end

        case ID=cmINCR:
          Scan(@Buff);

          word W=2;
          select
            case strcmp(@Buff,"byte")=0:
              W=0;
            case strcmp(@Buff,"word")=0:
              W=1;
          /*default:
              W=2;
              Keep();*/
          end

          if W<2 then
            if strcmp(@Scan(@Buff),"ptr")!=0 then
              Stop(@emERROR);
            end

            Scan(@Buff); // 15.09.2003
          end

          OpInfo Op;

          Data(@Buff,@Op);

          if W<2 then
            if Op.ID!=opMEM then
              Stop(@emERROR);
            end

            select
              case Op.Ptr=$02 | Op.Ptr=$03 | Op.Ptr=$06:
                if Op.Reg!=$02 then
                  Code($26|8*Op.Reg);
                end
              default:
                if Op.Reg!=$03 then
                  Code($26|8*Op.Reg);
                end
            end

            Code($FE|W);
            if Op.Ptr!=8 then
              if Op.Ofs>0 then
                Code($80|MTabl[I].Code2|Op.Ptr);
                Code(Op.Ofs%256);
                Code(Op.Ofs/256);
              else
                Code(MTabl[I].Code2|Op.Ptr);
              end
            else
              Code(MTabl[I].Code2|$06);
              Code(Op.Ofs%256);
              Code(Op.Ofs/256);
            end
          else
            if Op.ID!=opREG then
              Stop(@emERROR);
            end

            if Op.Ptr=0 then
              Code($FE);
              Code($C0|MTabl[I].Code2|Op.Reg);
            else
              Code(MTabl[I].Code1|Op.Reg);
            end
          end

        case ID=cmMULT:
          OpInfo Op;

          Data(@Scan(@Buff),@Op); // 15.09.2003

          if Op.ID!=opREG then
            Stop(@emERROR);
          end

          Code(MTabl[I].Code1|Op.Ptr);
          Code(MTabl[I].Code2|Op.Reg);

        case ID=cmSIGN:
          OpInfo Op;

          Data(@Scan(@Buff),@Op); // 15.09.2003

          if Op.ID!=opREG then
            Stop(@emERROR);
          end

          Code(MTabl[I].Code1|Op.Ptr);
          Code(MTabl[I].Code2|Op.Reg);

        case ID=cmSHFT:
          OpInfo Op1,Op2;

          Data(@Scan(@Buff),@Op1); // 15.09.2003

        //if strcmp(@Scan(@Buff),",")!=0 then
        //if strcmp(@Buff,",")!=0 then // 15.09.2003
          if Buff[0]!=',' then
            Stop(@emCOMMA);
          end

          if Op1.ID!=opREG then
            Stop(@emERROR);
          end

          Data(@Scan(@Buff),@Op2); // 15.09.2003

          word V;
          select
            case Op2.ID=opVAL & Op2.Ofs=1:
              V=0;
            case Op2.ID=opREG & Op2.Reg=1 & Op2.Ptr=0:
              V=2;
            default:
              Stop(@emERROR);
          end

          Code($D0|V|Op1.Ptr);
          Code(MTabl[I].Code2|Op1.Reg);

        case ID=cmJUMP:
          word D;

          P=FindLabel(@Scan(@Buff),0);
          D=0;
        //if P<nLabel then
          if P<ltSIZE then         // 13.05.2007
            D=LTabl[P].IP-(IP+3);
          else
          //if nJump>=jtSIZE then
            if nConst>=ctSIZE then
              Stop(@emNOMEMORY);
            end

          /*JTabl[nJump].IP  = IP+1; strcpy(@JTabl[nJump].Name,@Buff);
            JTabl[nJump].Near='N'; // 1
            inc   nJump;*/

            CTabl[nConst].IP  = IP+1; strcpy(@CTabl[nConst].Name,@Buff);
            CTabl[nConst].Type='N'; // 1
            inc   nConst;
          end

          Code(MTabl[I].Code1);
          Code(D%256);
          Code(D/256);

          Scan(@Buff); // 15.09.2003

        case ID=cmCOND:
        //if nJump>=jtSIZE then
          if nConst>=ctSIZE then
            Stop(@emNOMEMORY);
          end

        /*JTabl[nJump].IP  = IP+1; strcpy(@JTabl[nJump].Name,@Scan(@Buff));
          JTabl[nJump].Near='S'; // 0
          inc   nJump;*/

          CTabl[nConst].IP  = IP+1; strcpy(@CTabl[nConst].Name,@Scan(@Buff));
          CTabl[nConst].Type='S'; // 1
          inc   nConst;

          Code(MTabl[I].Code1);
          Code($00);

          Scan(@Buff); // 15.09.2003

        case ID=cmINTR:
          Code($CD);
          Code(Val(@Scan(@Buff)));

          Scan(@Buff); // 15.09.2003

        case ID=cmRETN:
        //if strcmp(@Scan(@Buff),";")!=0 then
          if Scan(@Buff)!=';' then
            N=Val(@Buff);
            Code($C2);
            Code(N%256);
            Code(N/256);
            Scan(@Buff); // 15.09.2003
          else
            Code($C3);
          //Keep();
          end

        case ID=cmLD87:
          Scan(@Buff);

          word W=0;
          select
            case strcmp(@Buff,"word")=0:
              W=1;
            case strcmp(@Buff,"dword")=0:
              W=2;
            case strcmp(@Buff,"qword")=0:
              W=3;
          end

          if W=0 then
            select
              case strcmp(@MTabl[I].Name,"fild") =0:
                W=1;
              case strcmp(@MTabl[I].Name,"fistp")=0:
                W=1;
              case strcmp(@MTabl[I].Name,"fld")  =0:
                W=3;
              case strcmp(@MTabl[I].Name,"fstp") =0:
                W=3;
              case strcmp(@MTabl[I].Name,"fstsw")=0:
                W=2;
            end

          //Keep();
          else
            select
              case strcmp(@MTabl[I].Name,"fstsw")=0:
                Stop(@emERROR);
            end

            if strcmp(@Scan(@Buff),"ptr")!=0 then
              Stop(@emERROR);
            end

            Scan(@Buff); // 15.09.2003
          end

          if W<2 then
            select
              case strcmp(@MTabl[I].Name,"fld")  =0:
                Stop(@emERROR);
              case strcmp(@MTabl[I].Name,"fstp") =0:
                Stop(@emERROR);
            end
          end

          OpInfo Op2;

          Data(@Buff,@Op2);

          if Op2.ID!=opMEM then
            Stop(@emERROR);
          end

          Code($9B);

          select
            case Op2.Ptr=$02 | Op2.Ptr=$03 | Op2.Ptr=$06:
              if Op2.Reg!=$02 then
                Code($26|8*Op2.Reg);
              end
            default:
              if Op2.Reg!=$03 then
                Code($26|8*Op2.Reg);
              end
          end

          if W=1 | W=3 then
            Code(MTabl[I].Code1|$04);
          else
            Code(MTabl[I].Code1);
          end

          select
            case W=3 & strcmp(@MTabl[I].Name,"fild") =0:
              W=$28;
            case W=3 & strcmp(@MTabl[I].Name,"fistp")=0:
              W=$20;
            default:
              W=$00;
          end

          if Op2.Ptr=8 then
            Code(MTabl[I].Code2|6|W);
          else
            Code($80|MTabl[I].Code2|Op2.Ptr|W);
          end
          Code(Op2.Ofs%256);
          Code(Op2.Ofs/256);

        case ID=cmOP87:
          Code($9B);
          Code(MTabl[I].Code1);
          Code(MTabl[I].Code2);

          Scan(@Buff); // 15.09.2003

        case ID=cmCHAR:
          Scan(@Buff); // 15.09.2003
          while TRUE do
          //Scan(@Buff);
            select
              case Buff[0]='"' & Buff[1]=#0:
                while Read()!='"' do
                  Code(CharToByte(Read()));
                  Next();
                end

                Next();

                Scan(@Buff); // 15.09.2003

              case Buff[0]=#39 & Buff[1]=#0:
                Code(CharToByte(Read()));
                Next();
                Next();

                Scan(@Buff); // 15.09.2003

              default:
                word V=Val(@Buff);
                if strcmp(@Scan(@Buff),"dup")=0 then
                  Scan(@Buff); // (
                  Scan(@Buff); // ?
                  Scan(@Buff); // )

                  DB=V;

                  Scan(@Buff); // 15.09.2003
                else
                  if V>255 then
                    Stop(@emNUMBER);
                  end

                  Code(V);

                //Keep();
                end
            end

          //if strcmp(@Scan(@Buff),";")=0 then
          //if strcmp(@Buff,";")=0 then
            if Buff[0]=';' then
              exit
            end

          //if strcmp(@Buff,",")!=0 then
            if Buff[0]!=',' then
              Stop(@emCOMMA);
            end

            Scan(@Buff); // 15.09.2003
          end

        //Keep();

        case ID=cmWORD:
          Scan(@Buff);
          if '0'<=Buff[0] & Buff[0]<='9' then
            while TRUE do
              word V=Val(@Buff);
              if strcmp(@Scan(@Buff),"dup")=0 then
                Scan(@Buff); // (
                Scan(@Buff); // ?
                Scan(@Buff); // )

                DB=2*V;

                Scan(@Buff); // 15.09.2003
              else
                Code(V%256);
                Code(V/256);

              //Keep();
              end

            //if strcmp(@Scan(@Buff),",")!=0 then
            //if strcmp(@Buff,",")!=0 then // 15.09.2003
              if Buff[0]!=',' then
                exit
              end

              Scan(@Buff);
            end

          //Keep();
          else
            word L=FindLabel(@Buff,0);
          //if L>=nLabel then
            if P>=ltSIZE then      // 13.05.2007
              char Temp [128];
              Stop(@strcat(@strcpy(@Temp,@emUNDEFINED),@Buff));
            end

            Code((LTabl[L].IP+256)%256);
            Code((LTabl[L].IP+256)/256);

            Scan(@Buff); // 24.09.2003
          end

        case ID=cmEVEN:
          if IP%2!=0 then
            Code(MTabl[I].Code1);
          end

          Scan(@Buff);

        case ID=cmNULL:
        //Code(MTabl[I].Code1);
          Scan(@Buff); // 15.09.2003

        default:
          Stop(@emERROR);
      end

    //if strcmp(@Scan(@Buff),";")!=0 then
    //if strcmp(@Buff,";")!=0 then // 15.09.2003
      if Buff[0]!=';' then
        Stop(@emERROR);
      end
    else
      select
        case Mode=smHASH:
          I=H%ltSIZE;
          while LTabl[I].Name[0]!=#0 do
            if strcmp(@LTabl[I].Name,@Buff)=0 then
              Stop(@emDOUBLE);
            end

            inc I;
            if  I>=ltSIZE then
              I=0;
            end
          end

          LTabl[I].IP=IP+DB; /* DB! */ strcpy(@LTabl[I].Name,@Buff);
          inc   nLabel;
          if    nLabel>=ltSIZE then
            Stop(@emNOMEMORY);
          end

        default:
          FindLabel(@Buff,1);
      end

      Scan(@Buff);
      select
        case strcmp(@Buff,"db")=0:
        //Keep();

        case strcmp(@Buff,"dw")=0:
        //Keep();

      //case strcmp(@Buff,":")!=0:
      //  Stop(@emCOLON);

      //case strcmp(@Buff,":") =0:
        case Buff[0]=':':
          Scan(@Buff); // 15.09.2003

        default:
          Stop(@emCOLON);
      end
    end
  end

  if pTemp>0 then
    write(F2,@Temp,pTemp);
  end

/*K=0;
  while K<nConst do
    P=FindLabel(@CTabl[K].Name,0);
  //if P>=nLabel then
    if P>=ltSIZE then              // 13.05.2007
      Stop(@strcat(@strcpy(@Buff,@emUNDEFINED),@JTabl[K].Name));
    end

    word D=LTabl[P].IP+CTabl[K].Ofs;

    seek (F2,CTabl[K].IP);
    write(F2,@D,2);

    inc K;
  end

  K=0;
  while K<nJump do
    P=FindLabel(@JTabl[K].Name,0);
  //if P>=nLabel then
    if P>=ltSIZE then              // 13.05.2007
      Stop(@strcat(@strcpy(@Buff,@emUNDEFINED),@JTabl[K].Name));
    end

    seek(F2,JTabl[K].IP);
    if JTabl[K].Near='N' then // 1
      word  D=LTabl[P].IP-(JTabl[K].IP+2);
      write(F2,@D,2);
    else
      word  D=LTabl[P].IP-(JTabl[K].IP+1);
      write(F2,@D,1);
    end

    inc K;
  end*/

  I=0;
  while I<nConst do
    byte Temp[4096];

    IP=CTabl[I].IP;
    K =I;
    while I<nConst do
      P=CTabl[I].IP;
      if CTabl[I].Type!='S' then
        inc P;
      end

      if P-CTabl[K].IP>=4096 then
        exit
      end

      inc I;
    end

    seek   (F2,IP);
    N=read (F2,@Temp,4096);

    while K<I do
      P=FindLabel(@CTabl[K].Name,0);
    //if P>=nLabel then
      if P>=ltSIZE then            // 13.05.2007
        Stop(@strcat(@strcpy(@Buff,@emUNDEFINED),@CTabl[K].Name));
      end

      select
        case CTabl[K].Type='S':
          word  D=LTabl[P].IP-(CTabl[K].IP+1);
          Temp[CTabl[K].IP-IP  ]=D;

        case CTabl[K].Type='N':
          word  D=LTabl[P].IP-(CTabl[K].IP+2);
          Temp[CTabl[K].IP-IP  ]=D%256;
          Temp[CTabl[K].IP-IP+1]=D/256;

        default:
          word D=LTabl[P].IP+CTabl[K].Ofs;
          Temp[CTabl[K].IP-IP  ]=D%256;
          Temp[CTabl[K].IP-IP+1]=D/256;
      end

      inc K;
    end

    seek   (F2,IP);
    write  (F2,@Temp,N);
  end

  close(F2);
  close(F1);

  Info ();
end
