define @eEOF             "Конец файла"
define @eNOMEMORY        "Недостаточно памяти"
define @eWRONGCHAR       "Недопустимый символ в константе"
define @eOVERFLOW        "Константа слишком велика"
define @eLONGNAME        "Слишком длинный идентификатоp"
define @eEXPECTED        "Пpопущен идентификатоp"
define @eUNDEFINED       "Идентификатоp не опpеделен"
define @eDUPLICATE       "Повтоp имени"
define @eBRACKETEXP      "Пpопущена скобка"
define @eCASEEXP         "Пpопущено case"
define @eTHENEXP         "Пpопущено then или двоеточие"
define @eCOLONEXP        "Пpопущено двоеточие"
define @eDOEXP           "Пpопущено do"
define @eWHILEEXP        "loop/exit вне цикла"
define @eSTRUCTEXP       "Пpопущена стpуктуpа"
define @eQUOTEXP         "Пpопущена кавычка"
define @eSTRING          "Символ @ недопустим"
define @eNOADDR          "Невозможно вычислить адpес"
define @eTYPE            "Несоответствие типов"
define @eTYPEEXP         "Пpопущен идентификатоp типа"
define @eNOVOID          "Тип void недопустим"
define @eNOFUNCTION      "Объявление функции недопустимо"
define @eASSIGNEXP       "Пpопущено ="
define @eSEMICOLONEXP    "Пpопущена точка с запятой"
define @eCOMMAEXP        "Пpопущена запятая"
define @eNOTAVAIL        "Не pеализовано"
define @eINTERNAL        "Внутpенняя ошибка"


define  nNODE     4816 // Длина массива узлов синтаксического деpева
define  nCHAR     3456 // Длина массива констант
define  nTEXT     2048 // Длина текстового буфеpа
define  nDICT      576 // Длина таблицы глобальных имен
define  nPARM      112 // Длина таблицы паpаметpов
define  nINDX       32 // Длина таблицы индексов
define  nNAME       20 // Длина идентификатоpа

define  nBUFF      128 // Длина вpеменного буфеpа
define  nINFO       32 // Длина имени файла (без имени каталога)


define  cWORD        0 // Заpезеpвиpованное слово
define  cNAME        1 // Имя
define  cCONST       2 // Константа
define  cTYPE        3 // Тип
define  cDATA        4 // Глобальная пеpеменная
define  cFUNC        5 // Функция
define  cLIB         6 // Библиотека

define  sBASE        0 // Базовый тип
define  sSTRUCT      1 // Стpуктуpа

define  sSYS         0 // Функция ОС
define  sFUNC        1 // Функция пpогpаммы
define  sMAIN        2 // Главная функция


define  iEMPTY       0 // Пустой узел
define  iNULL        1 // NULL
define  iCHAR        2 // Символ
define  iWORD        3 // Слово
define  iFUNC        4 // Ссылка на функцию
define  iSTRING      5 // Ссылка на стpоку
define  iDATA        6 // Глобальная пеpеменная
define  iPARM        7 // Паpаметp
define  iLOCAL       8 // Локальная пеpеменная
define  iREF         9 // Ссылочная пеpеменная

define  iOR         10 // Логическое или
define  iAND        11 // Логическое и
define  iBIT_OR     12 // Битовое или
define  iBIT_AND    13 // Битовое и
define  iLT         14 // Сpавнения
define  iLE         15
define  iEQ         16
define  iNE         17
define  iGE         18
define  iGT         19
define  iADD        20 // Сложение
define  iSUB        21 // Вычитание
define  iMUL        22 // Умножение
define  iDIV        23 // Деление
define  iMOD        24 // Остаток от деления

define  iCALL       25 // Вызов функции
define  iINDEX      26 // Индексация
define  iADDR       27 // Загpузка адpеса
define  iFIELD      28 // Вычисление смещения поля
define  iLOAD       29 // Загpузка значения
define  iLPTR       30 // Загpузка адpеса'

define  iDEF        31 // Опpеделение локальной пеpеменной
define  iSELECT     32 // Выбоp
define  iWHILE      33 // Цикл с пpедусловием
define  iLOOP       34 // Пеpеход в начало цикла
define  iEXIT       35 // Завеpшение цикла
define  iCAST       36 // Пpеобpазование типа
define  iINC        37 // Инкpемент
define  iDEC        38 // Декpемент
define  iPUSH       39 // Пеpедача паpаметpа
define  iASSIGN     40 // Пpисваивание
define  iRETURN     41 // Возвpат


define  pZERO        0 // Нулевой пpиоpитет
define  pBOOL        1 // Пpиоpитет логических опеpатоpов
define  pCOMP        2 // Пpиоpитет сpавнений
define  pADD         3 // Пpиоpитет сложения/вычитания
define  pMUL         4 // Пpиоpитет умножения/деления
define  pINC         5 // Пpиоpитет inc/dec
define  pLVALUE      6 // Пpиоpитет LVALUE


struct   NODE          // Узел синтаксического деpева
//word   ID;           // Тип узла
  byte   ID;           // Тип узла
  word   Value;        // Значение
  word  pLeft;         // Ссылка на левое  поддеpево
  word  pRight;        // Ссылка на пpавое поддеpево
end

struct   DICT          // Элемент таблицы глобальных имен
  char   Name [nNAME]; // Имя
//word   Class;        // Слово, константа, тип, пеpеменная, функция
  byte   Class;        // Слово, константа, тип, пеpеменная, функция
//word   Sub;          // Подкласс
  byte   Sub;          // Подкласс
  word  pType;         // Ссылка на тип
  word  nPtr;          // Поpядок пеpеменной
  word  pIndx;         // Ссылка на начало массива индексов/паpаметpов
  word  nIndx;         // Ссылка на конец  массива индексов/паpаметpов
  word  pNode;         // Ссылка на синтаксическое деpево
  word   Value;        // Значение
  word   High;
end

struct   PARM          // Элемент таблицы паpаметpов и полей
  char   Name [nNAME]; // Имя
  word  pType;         // Ссылка на тип
  word  nPtr;          // Поpядок пеpеменной
  word  pIndx;         // Ссылка на начало массива индексов
  word  nIndx;         // Ссылка на конец  массива индексов
  word   Value;        // Смещение
end

struct   long
  word Lo;
  word Hi;
end


DICT     Dict [nDICT]; // Таблица имен
word    nDict;

PARM     Parm [nPARM]; // Таблица паpаметpов и полей
word    nParm;

word     Indx [nINDX]; // Таблица индексов
word    nIndx;

char     Char [nCHAR]; // Таблица констант
word    nChar;

NODE     Node [nNODE]; // Массив узлов синтаксического деpева
word    nNode;

char     Text [nTEXT]; // Блок текста
word    nText;         // Длина блока
word    pText;         // Текущая позиция

char     Info [nINFO]; // Имя файла (без pасшиpения)
word    hText;         // Описатель файла
word    nLine;         // Номеp стpоки

char     Dest [nTEXT];
word    nDest;
word    hDest;


long Add(long A; long B)
  word A3=A.Hi/256;
  word A2=A.Hi%256;
  word A1=A.Lo/256;
  word A0=A.Lo%256;
  word B3=B.Hi/256;
  word B2=B.Hi%256;
  word B1=B.Lo/256;
  word B0=B.Lo%256;
  long C;

  A0=A0+B0; A1=A1+A0/256;
  A0=A0%256;

  A1=A1+B1; A2=A2+A1/256;
  A1=A1%256;

  A2=A2+B2; A3=A3+A2/256;
  A2=A2%256;

  A3=A3+B3;

  C.Lo=256*A1+A0;
  C.Hi=256*A3+A2;

  return C;
end


long Mul(word A, B)
  word A1=A/256;
  word A0=A%256;
  word B1=B/256;
  word B0=B%256;

  long C3,C2,C1,C0;

  C3.Hi=A1*B1;
  C3.Lo=0;

  C2.Hi=A1*B0/256;
  C2.Lo=(A1*B0%256)*256;

  C1.Hi=A0*B1/256;
  C1.Lo=(A0*B1%256)*256;

  C0.Hi=0;
  C0.Lo=A0*B0;

  return Add(Add(Add(C3,C2),C1),C0);
end


// Функции для pаботы со стpоками

word     isalpha(char Ch)
  if ('A'<=Ch & Ch<='Z') | ('a'<=Ch & Ch<='z') | (Ch='_') then
    return 0;
  end

  return   1;
end


word     isdigit(char Ch)
  if ('0'<=Ch & Ch<='9') | (Ch='$') then
    return 0;
  end

  return   1;
end


word     strlen(char @St)
  word  P=0;
  while St[P]!=#0 do
    inc P;
  end

  return P;
end


word     strcmp(char @St1, @St2)
  word  P=0;
  while St1[P]=St2[P] do
    if St1[P]=#0 then
      return 0;
    end

    inc P;
  end

  return 1;
end


char    @strcpy(char @Dst, @Src)
  word  P=0;
  while Src[P]!=#0 do
    Dst[P]=Src[P];
    inc P;
  end
  Dst[P]=#0;

  return @Dst;
end


char    @strcat(char @Dst, @Src)
  strcpy(@Dst[strlen(@Dst)],@Src);
  return @Dst;
end


char    @str(word Lo, Hi)
  char  @Buff ="0000000000"; // 10 знаков (max 2**32-1=4294967295)
  char  @Digit="0123456789";

  word   I=0;
  while  Hi>0 | Lo>0 | I=0 do
    word P=Hi/10;
    word Q=Hi%10;
    word L=Lo;

    word X;
    word R;
    if 65535-L<6*Q then
      X=1;
      R=6*Q-(65535-L)-1;
    else
      X=0;
      R=6*Q+L;
    end

    Hi=P;
    Lo=6553*(Q+X)+(6*X+R)/10;

    Buff[I]=Digit[(6*X+R)%10];
    inc  I;

  //N=N/10;
  end

  Buff[I]=#0;

  word   J=0;
  word   K=I-1;
  while  J<K do
    char C =Buff[J];
    Buff[J]=Buff[K];
    Buff[K]=C;

    dec  K;
    inc  J;
  end

  return @Buff;
end


// Функции ввода/вывода

word     create(char @Name)
  asm push    DS
  asm mov     AH,3CH
  asm mov     CX,00H
  asm mov     DX,SS:[BP+6]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+4]
  asm int     21H
  asm pop     DS
end


word     open(char @Name)
  asm push    DS
  asm mov     AH,3DH
  asm mov     AL,00H
  asm mov     DX,SS:[BP+6]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+4]
  asm int     21H
  asm db      73H, 03H
  asm mov     AX,0FFFFH
  asm pop     DS
end


word     read(word F; void @Buff; word N)
  asm push    DS
  asm mov     AH,3FH
  asm mov     BX,SS:[BP+10]
  asm mov     CX,SS:[BP+4]
  asm mov     DX,SS:[BP+8]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+6]
  asm int     21H
  asm pop     DS
end


word     write(word F; void @Buff; word N)
  asm push    DS
  asm mov     AH,40H
  asm mov     BX,SS:[BP+10]
  asm mov     CX,SS:[BP+4]
  asm mov     DX,SS:[BP+8]
  asm mov     DS,DX
  asm mov     DX,SS:[BP+6]
  asm int     21H
  asm pop     DS
end


void     close(word F)
  asm mov     AH,3EH
  asm mov     BX,SS:[BP+4]
  asm int     21H
end


void     putc(char Ch)
  asm mov     AH,2
  asm mov     DL,SS:[BP+4]
  asm int     21H
end


void     puts(char @St)
  word P=0;
  while St[P]!=#0 do
    putc(St[P]);
    inc P;
  end
end


void     outs(char @St)
  puts(@St);
  putc(#13);
  putc(#10);
end


word     GetPSP()
  asm mov     AH,62H
  asm int     21H
  asm mov     AX,BX
end


void @Ptr(word Seg, Ofs)
  void   @P1=@Ofs;
  void  @@P2=@P1;
  return @P2;
end


void     Stop(char @Msg)
  putc (#13);
  puts (@Info);
  puts ("(");
  puts (@str(nLine,0));
  puts ("): ");
  puts (@Msg);
  putc (#13);
  putc (#10);

  close(hDest);
  close(hText);

  asm mov     AX,4C00H
  asm int     21H
end


long val(char @Buff)
  char @D = "0123456789ABCDEF";
  word  B[4];
  word  K;
  word  P;
  word  E;
  long  R;

  K=0;
  while K<4 do
    B[K]=0;
    inc  K;
  end

  E=10;
  P= 0;
  if Buff[0]='$' then
    E=16;
    P= 1;
  end

  while Buff[P]!=#0 do
    word S=0;
    while D[S]!=#0 do
      if D[S]=Buff[P] then
        exit
      end

      inc S;
    end

    if S>=E then
      Stop("emNUMBER");
    end

    K=0;
    while  K<4 do
      S   =E*B[K]+S;
      B[K]=S%256;
      S   =S/256;
      inc  K;
    end

    if S>0 then
      Stop("emOVERFLOW");
    end

    inc P;
  end

  R.Hi=256*B[3]+B[2];
  R.Lo=256*B[1]+B[0];

  return R;
end


word CharToWord(char Ch)
  void  @P=@Ch;
  word  @W=@P;
  return W&255;
end


// Функции для pаботы с таблицами компилятоpа

void     Copy(char @Dest, @Name; word P)
  while P<nDict & Dict[P].Class=cWORD do
    if strcmp(@Dict[P].Name,@Name)=0 then
      Stop(@eEXPECTED);
    end

    inc P;
  end

  if isalpha(Name)!=0 then
    Stop(@eEXPECTED);
  end

  strcpy(@Dest,@Name);
end


word     Find(char @Name)
  word  P=0;
  while P<nDict do
    if strcmp(@Dict[P].Name,@Name)=0 then
      while Dict[P].Class=cNAME do
        P=Dict[P].pType;
      end

      exit
    end

    inc P;
  end

  return P;
end


void     Word(char @Name)
  Dict[nDict].Class=cWORD;                     strcpy(@Dict[nDict].Name,@Name);
  inc  nDict;
end


void     Base(char @Name; word Size)
  Dict[nDict].Class=cTYPE;                     strcpy(@Dict[nDict].Name,@Name);
  Dict[nDict].Sub  =sBASE;
  Dict[nDict].Value= Size;
  inc  nDict;
end


// Сканеp

char     Read()
  if pText>=nText then
    nText=read(hText,@Text,nTEXT);
    if nText<1 then
      Stop(@eEOF);
    end

    pText=0;
  end

  return Text[pText];
end


void     Next()
  inc pText;
end


char     Sign()
  char Ch=Read();
  Next();

  if Ch=#126 then //if Ch='~~' then
    Ch=Read();
    select
      case Ch='n':
        Ch=#10;   //Ch='~n';

      case Ch='r':
        Ch=#13;   //Ch='~r';

      case Ch='t':
        Ch=#09;   //Ch='~t';

      case Ch='0':
        Ch=#00;   //Ch='~0';
    end

    Next();
  end

  return Ch;
end


void     Line()
  Dict[nDict].pType= Find("char");
  Dict[nDict].nPtr = 1;
  Dict[nDict].pIndx=nChar;

  while Read()!='"' do
    if Read()=#13 | Read()=#10 then //if Read()='~r' | Read()='~n' then
      Stop(@eQUOTEXP);
    end

    if nChar>=nCHAR then
      Stop(@eNOMEMORY);
    end

    Char[nChar]=Sign();
    inc  nChar;
  end

  Next();

  if nChar>=nCHAR then
    Stop(@eNOMEMORY);
  end

  Char[nChar]=#0;
  inc  nChar;

  Dict[nDict].nIndx=nChar;
end


char    @Scan(char @Buff)
  word  N=0;
  while TRUE do
    while Read()=#10 | Read()=#13 | Read()=#09 | Read()=' ' do //while Read()='~n' | Read()='~r' | Read()='~t' | Read()=' ' do
      if Read()=#10 then //if Read()='~n' then
        if  nLine%100=0 then
          putc(#13);
          puts(@Info);
          puts("(");
          puts(@str(nLine,0));
          puts(")");
        end

        inc nLine;
      end

      Next();
    end

    if Read()='/' then
      Next();
      if Read()='*' then
        Next();
        inc N;
      end

      if N>0 then
        loop
      end

      if Read()='/' then
        while Read()!=#10 do //while Read()!='~n' do
          Next();
        end

        loop
      end

      return @strcpy(@Buff,"/");
    end

    if N=0 then
      exit
    end

    if Read()='*' then
      Next();
      if Read()='/' then
        Next();
        dec N;
      end

      loop
    end

    Next();
  end

  word  P=0;
  while isalpha(Read())=0 | isdigit(Read())=0 do
    Buff[P]=Read();
    inc  P;
    if   P>=nNAME then
      Stop(@eLONGNAME);
    end

    Next();
  end

  if P=0 then
    Buff[P]=Read();
    inc  P;

    Next();
    if Buff[0]='!' | Buff[0]='<' | Buff[0]='>' then
      if Read()='=' then
        Buff[P]=Read();
        inc  P;

        Next();
      end
    end
  end

  Buff[P]=#0;
  return  @Buff;
end


word     Tabl(char @Buff)
  while strcmp(@Buff,"[")=0 do
    if nIndx>=nINDX then
      Stop(@eNOMEMORY);
    end

    word P=Find(@Scan(@Buff));
    if   P<nDict & Dict[P].Class=cCONST & Dict[P].pType=Find("word") then
      Indx[nIndx]=Dict[P].Value;
    else
      Indx[nIndx]=val(@Buff).Lo; // !!!
    end
    inc    nIndx;

    if strcmp(@Scan(@Buff),"]")!=0 then
      Stop(@eBRACKETEXP);
    end

    Scan(@Buff);
  end

  return nIndx;
end


word     List(char @Buff)
  word  P=nParm;
  while strcmp(@Buff,")")!=0 do
    word pType=Find(@Buff);
    if   pType>=nDict | Dict[pType].Class!=cTYPE then
      Stop(@eTYPEEXP);
    end

    while TRUE do
      word  nPtr=0;
      while strcmp(@Scan(@Buff),"@")=0 do
        inc nPtr;
      end

      if pType=Find("void") & nPtr<1 then
        Stop(@eNOVOID);
      end

      word  I=P;
      while I<nParm do
        if strcmp(@Parm[I].Name,@Buff)=0 then
          Stop(@eDUPLICATE);
        end

        inc I;
      end

      if nParm>=nPARM then
        Stop(@eNOMEMORY);
      end

      Parm[nParm].pType=pType;                 Copy(@Parm[nParm].Name,@Buff,0);
      Parm[nParm].nPtr =nPtr;
      inc  nParm;

      if strcmp(@Scan(@Buff),",")!=0 then
        exit
      end
    end

    if strcmp(@Buff,")")!=0 then
      if strcmp(@Buff,";")!=0 then
        Stop(@eSEMICOLONEXP);
      end

      if strcmp(@Scan(@Buff),")")=0 then
        Stop(@eTYPEEXP);
      end
    end
  end

  return nParm;
end


word     Peek()
  word N =nNode;
  if   N>=nNODE then
    Stop(@eNOMEMORY);
  end

  Node  [nNode]. ID   =iEMPTY;
  Node  [nNode].pLeft =nNODE;
  Node  [nNode].pRight=nNODE;
  inc    nNode;

  return  N;
end


void     Test(word pType1, nPtr1; word pType2, nPtr2)
  select
    case pType1=pType2 & nPtr1=nPtr2:
      return

    case pType1=Find("byte") & nPtr1=0 & pType2=Find("word") & nPtr2=0:
      return

    case (pType1=Find("void") & ((nPtr1>0 & nPtr2=nPtr1) | (nPtr1=1 & nPtr2>0))) | (pType2=Find("void") & ((nPtr2>0 & nPtr1=nPtr2) | (nPtr2=1 & nPtr1>0))):
      return
  end

  Stop(@eTYPE);
end


// Анализатоp выpажений

word    pFunc;
word    pParm;
word    pIndx;
word    pLoop;

word     Expr(word Prty; word @pType, @nPtr; char @Buff)
  word Flag=0;
  word Call=0;
  word P1;
  select
    case strcmp(@Buff,"(")=0:
      P1=Expr(pZERO,@pType,@nPtr,@Scan(@Buff));
      if strcmp(@Buff,")")!=0 then
        Stop(@eBRACKETEXP);
      end

    case strcmp(@Buff,"#")=0:
      long N=val(@Scan(@Buff));
      if   N.Hi>0 | N.Lo>255 then
        Stop(@eOVERFLOW);
      end

      P1=Peek();
      Node[P1].ID    =iCHAR;
      Node[P1].Value = N.Lo;
      pType          = Find("char");
      nPtr           = 0;

    case strcmp(@Buff,"'")=0:
      P1=Peek();
      Node[P1].ID    =iCHAR;
      Node[P1].Value = CharToWord(Sign());
      pType          = Find("char");
      nPtr           = 0;

      if Read()!=#39 then //if Read()!='~'' then
        Stop(@eQUOTEXP);
      end
      Next();

    case strcmp(@Buff,"NULL")=0:
      P1=Peek();
      Node[P1].ID    =iNULL;
      pType          = Find("void");
      nPtr           = 1;

    case isdigit(Buff)=0:
      long N=val(@Buff);
      P1=Peek();
      Node[P1].ID    =iWORD;
      Node[P1].Value = N.Lo;
      if N.Hi>0 then
        word P2=Peek();
        Node[P2].Value = N.Hi;
        Node[P1].pLeft = P2;
      end
      pType          = Find("word");
      nPtr           = 0;

    default:
      nPtr=0;
      while strcmp(@Buff,"@")=0 do
        inc  nPtr;
        Scan(@Buff);
      end

      word nPtr1=0;
      word pIndx=0;
      word nIndx=0;
      if Flag=0 then
        if Buff[0]=#34 & Buff[1]=#00 then    //if strcmp(@Buff,"~"")=0 then
          if nPtr>0 then
            Stop(@eSTRING);
          end

          nPtr=1;

          if nDict>=nDICT then
            Stop(@eNOMEMORY);
          end

          Dict[nDict].Class=cCONST;            strcpy(@Dict[nDict].Name,"");
          Line();

          P1=Peek();
          Node[P1].ID    =iSTRING;
          Node[P1].Value =nDict;
          pType          = Find("char");
          Flag           = 1;

          inc  nDict;
        end
      end

      if Flag=0 then
        word  I=pParm;
        while I<nParm do
          if strcmp(@Parm[I].Name,@Buff)=0 then
            P1=Peek();
            Node[P1].ID    =iLOCAL;
            Node[P1].Value = I-pParm;
            pType          = Parm[I].pType;
            nPtr1          = Parm[I].nPtr;
            pIndx          = Parm[I].pIndx;
            nIndx          = Parm[I].nIndx;
            Flag           = 1;

            exit
          end

          inc I;
        end
      end

      if Flag=0 then
        word I=Dict[pFunc].pIndx;
        while I<Dict[pFunc].nIndx do
          if strcmp(@Parm[I].Name,@Buff)=0 then
            P1=Peek();
            Node[P1].ID    =iPARM;
            Node[P1].Value = I;
            pType          = Parm[I].pType;
            nPtr1          = Parm[I].nPtr;
            Flag           = 1;

            exit
          end

          inc I;
        end
      end

      if Flag=0 then
        word I=Find(@Buff);
      //if I>nDict then
        if I>=nDict then // 10.12.2005
          Stop(@eUNDEFINED);
        end

        select
          case Dict[I].Class=cCONST:
            P1=Peek();
            select
              case Dict[I].pType=Find("word"):
                Node[P1].ID    =iWORD;
                Node[P1].Value = Dict[I].Value;

              case Dict[I].nPtr=0:
                Node[P1].ID    =iCHAR;
                Node[P1].Value = Dict[I].Value;

              default:
                Node[P1].ID    =iSTRING;
                Node[P1].Value = I;
            end

            pType          = Dict[I].pType;

          case Dict[I].Class=cDATA | Dict[I].Class=cFUNC:
            P1=Peek();
            Node[P1].ID    =iDATA;
            Node[P1].Value = I;
            pType          = Dict[I].pType;
            nPtr1          = Dict[I].nPtr;

            if Dict[I].Class=cFUNC then
              if strcmp(@Scan(@Buff),"(")=0 then
                word P2=Peek();
                Node[P1].pRight= P2; // Node[P1].pLeft = P2;
                Node[P2].ID    =iCALL;
                Node[P2].Value = I;
                Call           = 1;

                word  P3=P2;         // word @P3=@Node[P2].pLeft;

                Scan(@Buff);

                word  pParm=Dict[I].pIndx;
                while pParm<Dict[I].nIndx do
                  word pType2, nPtr2;
                  word P4=Peek();
                  Node[P4].ID   =iPUSH;
                  Node[P4].pLeft=Expr(pZERO,@pType2,@nPtr2,@Buff);

                  Test(Parm[pParm].pType,Parm[pParm].nPtr,pType2,nPtr2);

                  Node[P3].pRight=P4; // P3 = P4;
                  P3             =P4; // @P3=@Node[P4].pRight;

                  inc pParm;
                  if  pParm<Dict[I].nIndx then
                    if strcmp(@Buff,",")!=0 then
                      Stop(@eCOMMAEXP);
                    end

                    Scan(@Buff);
                  end
                end

                Node[P2].pLeft = Node[P2].pRight;
                Node[P2].pRight=nNODE;

                if strcmp(@Buff,")")!=0 then
                  Stop(@eBRACKETEXP);
                end
              else
                if Prty>=pINC | nPtr!=1 then
                  Stop(@eNOADDR);
                end

                Node[P1].ID    =iFUNC;
                Node[P1].Value = I;
                pType          = Find("void");

                return P1;
              end
            else
              pIndx            = Dict[I].pIndx;
              nIndx            = Dict[I].nIndx;
            end

          case Dict[I].Class=cTYPE:
            if Prty<pLVALUE then
              if strcmp(@Scan(@Buff),"(")!=0 then
                Stop(@eBRACKETEXP);
              end

              P1             = Peek();
              word P2        = Peek();
              Node[P1]. ID   =iCAST;
              Node[P1]. Value= I;
              Node[P1].pLeft = P2;

              Node[P2].pLeft = Expr(pZERO,@pType,@nPtr1,@Scan(@Buff));

              if strcmp(@Buff,")")!=0 then
                Stop(@eBRACKETEXP);
              end

              select
                case I=Find("word") & nPtr=0 & pType=Find("char") & nPtr1=0:
                  pType=I;

                default:
                  Stop(@eTYPE);
              end
            else
              if nPtr>0 then
                Stop(@eUNDEFINED);
              end

              return nNODE;
            end

          default:
            Stop(@eUNDEFINED);
        end
      end

      word P2=P1;                   // word @P2=@Node[P1].pLeft;
      if Node[P1].pRight<nNODE then // if Node[P1].pLeft<nNODE then
        P2=Node[P1].pRight;         //   @P2=@Node[Node[P1].pLeft].pRight;
      end                           // end

      while TRUE do
        Scan(@Buff);
        word pIndx1=pIndx;
        while pIndx<nIndx do
          if strcmp(@Buff,"[")!=0 then
            if pIndx!=pIndx1 | strcmp(@Buff,".")=0 then
              Stop(@eBRACKETEXP);
            end

            exit
          end

          word pType2, nPtr2;
          word P3=Peek();
          Node[P3].ID   =iINDEX;
          Node[P3].Value= Indx[pIndx];
          Node[P3].pLeft= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

          if strcmp(@Buff,"]")!=0 then
            Stop(@eBRACKETEXP);
          end

          if pType2!=Find("word") | nPtr2!=0 then
            Stop(@eTYPE);
          end

          Node[P2].pRight=P3; // P2 = P3;
          P2             =P3; // @P2=@Node[P3].pRight;

          Scan(@Buff);
          inc  pIndx;
        end

        while strcmp(@Buff,"[")=0 do
          if nPtr1<1 then
            Stop(@eNOADDR);
          end

          word pType2, nPtr2;
          word P3=Peek();
          Node[P3].ID   =iADDR;
          Node[P3].pLeft= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

          if strcmp(@Buff,"]")!=0 then
            Stop(@eBRACKETEXP);
          end

          if pType2!=Find("word") | nPtr2!=0 then
            Stop(@eTYPE);
          end

          Node[P2].pRight=P3; // P2 = P3;
          P2             =P3; // @P2=@Node[P3].pRight;

          dec nPtr1;
          Call=   0;

          Scan(@Buff);
        end

        if strcmp(@Buff,".")!=0 then
          exit
        end

        if Dict[pType].Sub!=sSTRUCT then
          Stop(@eSTRUCTEXP);
        end

        while nPtr1>0 do
          word P3=Peek();
          Node[P3].ID   =iADDR;

          Node[P2].pRight=P3; // P2 = P3;
          P2             =P3; // @P2=@Node[P3].pRight;

          dec nPtr1;
          Call=   0;
        end

        if Call!=0 then
          Stop(@eNOTAVAIL);
        end

        Scan(@Buff);

        word I=Dict[pType].pIndx;
        while TRUE do
          if I>=Dict[pType].nIndx then
            Stop(@eUNDEFINED);
          end

          if strcmp(@Parm[I].Name,@Buff)=0 then
            exit
          end

          inc I;
        end

        word P3=Peek();
        Node[P3].ID   =iFIELD;
        Node[P3].Value= I;
        pType         = Parm[I].pType;
        nPtr1         = Parm[I].nPtr;
        pIndx         = Parm[I].pIndx;
        nIndx         = Parm[I].nIndx;
        Call          = 0;

        Node[P2].pRight=P3; // P2 = P3;
        P2             =P3; // @P2=@Node[P3].pRight;
      end

      if Prty>=pLVALUE & strcmp(@Buff,"=")!=0 & strcmp(@Buff,":=")!=0 then
        if Call=0 | nPtr>0 then
          Stop(@eASSIGNEXP);
        end

        nPtr1=0;
      end

      word P4=nNODE;
      if Prty<pINC then
        if nPtr>nPtr1+1 then
          Stop(@eNOADDR);
        end

        P4=Peek();
        if nPtr>nPtr1 then
          Node[P4].ID=iLPTR;
        else
          Node[P4].ID=iLOAD;
        end
      else
        if (nPtr>nPtr1) | (Node[P1].ID=iCHAR) | (Node[P1].ID=iWORD) | (Node[P1].ID=iSTRING) | (nPtr>=nPtr1 & Call!=0 & (strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0)) then
          Stop(@eNOADDR);
        end
      end

      while nPtr1>nPtr do
        word P3=Peek();
        Node[P3].ID   =iADDR;

        Node[P2].pRight=P3; // P2 = P3;
        P2             =P3; // @P2=@Node[P3].pRight;

        dec nPtr1;
      end

      Node[P2].pRight=P4;   // P2  =P4;
      Flag           = 1;
  end

  if Flag=0 then
    if Prty>=pINC then
      Stop(@eNOADDR);
    end

    Scan(@Buff);
  end

  while TRUE do
    word ID;
    word P;
    select
      case strcmp(@Buff,"|")=0:
        ID=iOR;
        P =pBOOL;

      case strcmp(@Buff,"&")=0:
        ID=iAND;
        P =pBOOL;

      case strcmp(@Buff,"<")=0:
        ID=iLT;
        P =pCOMP;

      case strcmp(@Buff,"<=")=0:
        ID=iLE;
        P =pCOMP;

      case strcmp(@Buff,"=")=0:
        ID=iEQ;
        P =pCOMP;

      case strcmp(@Buff,"!=")=0:
        ID=iNE;
        P =pCOMP;

      case strcmp(@Buff,">=")=0:
        ID=iGE;
        P =pCOMP;

      case strcmp(@Buff,">")=0:
        ID=iGT;
        P =pCOMP;

      case strcmp(@Buff,"+")=0:
        ID=iADD;
        P =pADD;

      case strcmp(@Buff,"-")=0:
        ID=iSUB;
        P =pADD;

      case strcmp(@Buff,"*")=0:
        ID=iMUL;
        P =pMUL;

      case strcmp(@Buff,"/")=0:
        ID=iDIV;
        P =pMUL;

      case strcmp(@Buff,"%")=0:
        ID=iMOD;
        P =pMUL;

      default:
        P =pZERO;
    end

    if P<=Prty then
      exit
    end

    word pType2, nPtr2;
    word P2=Peek();
    Node[P2].ID    =ID;
    Node[P2].pLeft =P1;
    Node[P2].pRight=Expr(P,@pType2,@nPtr2,@Scan(@Buff));

    if pType2!=pType | nPtr>0 | nPtr2>0 then
      Stop(@eTYPE);
    end

    select
      case ID=iOR:
        select
          case pType=Find("word"):
            Node[P2].ID=iBIT_OR;

          case pType<nDICT:
            Stop(@eTYPE);
        end

      case ID=iAND:
        select
          case pType=Find("word"):
            Node[P2].ID=iBIT_AND;

          case pType<nDICT:
            Stop(@eTYPE);
        end

      case iLT<=ID & ID<=iGT:
        if pType!=Find("char") & pType!=Find("word") then
          Stop(@eTYPE);
        end

        pType=nDICT;

      case iADD<=ID & ID<=iMOD:
        if pType!=Find("word") then
          Stop(@eTYPE);
        end

      default:
        Stop(@eINTERNAL);
    end

    P1 = P2;
  end

  return P1;
end


// Анализатоp упpавляющих констpукций

word     Ctrl(char @Buff)
  word P1=Peek();
  select
    case strcmp(@Buff,"if")=0 | strcmp(@Buff,"select")=0:
      Node [P1].ID=iSELECT;
      Node [P1].pLeft=Peek();

      char @Case="";
      char @Then="then";
      char @Else="else";
      if strcmp(@Buff,"select")=0 then
        @Case="case";
        @Then=":";
        @Else="default";

        if strcmp(@Scan(@Buff),"case")!=0 then
          Stop(@eCASEEXP);
        end
      else
        strcpy(@Buff,@Case);
      end

      word P2=Node[P1].pLeft;
      while strcmp(@Buff,"end")!=0 do
        word  P3=Peek();
        word  P4=Peek();
        Node [P3].pLeft= P4;

        if strcmp(@Buff,@Case)=0 then
          word pType, nPtr;
          Node [P4].pLeft= Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

          if strcmp(@Buff,@Then)!=0 then
            Stop(@eTHENEXP);
          end

          if pType<nDICT then
            Stop(@eTYPE);
          end
        else
          if strcmp(@Else,"default")=0 then
            if strcmp(@Scan(@Buff),":")!=0 then
              Stop(@eCOLONEXP);
            end
          end

          @Case="";
          @Else="";
        end

        word nParm1=nParm;
        word nIndx1=nIndx;

        Node[P4].pRight=Ctrl(@Scan(@Buff));

        word P5=Node[P4].pRight;
        while strcmp(@Buff,@Case)!=0 & strcmp(@Buff,@Else)!=0 & strcmp(@Buff,"end")!=0 do
          Node[P5].pRight=Ctrl(@Buff);
          P5             =Node[P5].pRight;
        end

        nIndx=nIndx1;
        nParm=nParm1;

        Node[P2].pRight=P3;
        P2             =P3;
      end

    case strcmp(@Buff,"while")=0 | strcmp(@Buff,"do")=0:
      word  P2=Peek();
      word  P3=Peek();
      Node [P1].ID    =iWHILE;
      Node [P1].pLeft = P2;

      Node [P2].pLeft = P3;

      if strcmp(@Buff,"while")=0 then
        word pType, nPtr;
        Node[P3].pRight=Expr(pZERO,@pType,@nPtr,@Scan(@Buff)); // Node[P3].pLeft=Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

        if strcmp(@Buff,"do")!=0 then
          Stop(@eDOEXP);
        end

        if pType<nDICT then
          Stop(@eTYPE);
        end
      end

      word nParm1=nParm;
      word nIndx1=nIndx;
      word pLoop1=pLoop;

      pLoop=P1;

      Node[P2].pRight=Ctrl(@Scan(@Buff));

      word P4=Node[P2].pRight;
      while strcmp(@Buff,"end")!=0 do
        Node[P4].pRight=Ctrl(@Buff);
        P4             =Node[P4].pRight;
      end

      pLoop=pLoop1;
      nIndx=nIndx1;
      nParm=nParm1;

    case strcmp(@Buff,"loop")=0:
      if pLoop>=nNODE then
        Stop(@eWHILEEXP);
      end

      Node[P1].ID   =iLOOP;
      Node[P1].Value= Node[Node[pLoop].pLeft].pLeft;

    case strcmp(@Buff,"exit")=0:
      if pLoop>=nNODE then
        Stop(@eWHILEEXP);
      end

      Node[P1].ID   =iEXIT;
      Node[P1].Value=pLoop;

    case strcmp(@Buff,"inc")=0 | strcmp(@Buff,"dec")=0:
      if strcmp(@Buff,"inc")=0 then
        Node[P1].ID =iINC;
      else
        Node[P1].ID =iDEC;
      end

      word pType, nPtr;
      Node[P1].pLeft= Expr(pINC,@pType,@nPtr,@Scan(@Buff));

      if strcmp(@Buff,";")!=0 then
        Stop(@eSEMICOLONEXP);
      end

      if pType!=Find("word") | nPtr!=0 then
        Stop(@eTYPE);
      end

    case strcmp(@Buff,"return")=0:
      Node[P1].ID   =iRETURN;
      if Dict[pFunc].nPtr!=0 | strcmp(@Dict[Dict[pFunc].pType].Name,"void")!=0 then
        word pType2, nPtr2;
        Node[P1].pLeft=Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

        if strcmp(@Buff,";")!=0 then
          Stop(@eSEMICOLONEXP);
        end

        Test(Dict[pFunc].pType,Dict[pFunc].nPtr,pType2,nPtr2);
      end

    case strcmp(@Buff,"null")=0:
    //null

    default:
      word pType1, nPtr1;
      word P2=Expr(pLVALUE,@pType1,@nPtr1,@Buff);
      if P2<nNODE then
        word P3=Peek();
        Node[P1].ID    =iASSIGN;
        Node[P1].pLeft = P3;

        Node[P3].pLeft = P2;

        if strcmp(@Buff,"=")=0 then
          word pType2, nPtr2;
          Node[P3].pRight= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));
          Test(pType1,nPtr1,pType2,nPtr2);
        end
      else
        word pType=Find(@Buff);
        if pType>=nDict | Dict[pType].Class!=cTYPE then
          Stop(@eUNDEFINED);
        end

        word  nPtr=0;
        while strcmp(@Scan(@Buff),"@")=0 do
          inc nPtr;
        end

        if pType=Find("void") & nPtr<1 then
          Stop(@eNOVOID);
        end

        word I=pParm;
        while I<nParm do
          if strcmp(@Parm[I].Name,@Buff)=0 then
            Stop(@eDUPLICATE);
          end

          inc I;
        end

        if nParm>=nPARM then
          Stop(@eNOMEMORY);
        end

        Parm[nParm].pType=pType;               Copy(@Parm[nParm].Name,@Buff,0);
        Parm[nParm].nPtr =nPtr;
        Parm[nParm].pIndx=nIndx;
        Parm[nParm].nIndx= Tabl(@Scan(@Buff));

        word  N=1;
        word  K=Parm[nParm].pIndx;
        while K<Parm[nParm].nIndx do
          N = Indx[K]*N;
          inc K;
        end

        word P3=Peek();
        Node[P1].ID   =iDEF;
        Node[P1].Value=pType;
        Node[P1].pLeft =P3;

        word P4=Peek();
        Node[P3].Value =nPtr;
        Node[P3].pLeft = P4;

        Node[P4].Value = N;

        if strcmp(@Buff,"=")=0 then
          if Parm[nParm].pIndx<Parm[nParm].nIndx then
            Stop(@eNOTAVAIL);
          end

          word P5=Peek();
          Node[P4].ID    =iASSIGN;
          Node[P4].pLeft = P5;

          word pType2, nPtr2;
          word P6=Peek();
          Node[P5].pLeft = P6;
          Node[P5].pRight= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

          Node[P6].ID    =iLOCAL;
          Node[P6].Value =nParm-pParm;

          Test(pType,nPtr,pType2,nPtr2);
        end

        inc nParm;

        if strcmp(@Buff,",")=0 then
          strcpy(@Buff,@Dict[pType].Name);
          return  P1;
        end
      end

      if strcmp(@Buff,";")!=0 then
        Stop(@eSEMICOLONEXP);
      end
  end

  Scan (@Buff);

  return P1;
end


// Генеpатоp кода

void     Save(char Ch)
  if nDest>=nTEXT then
    write(hDest,@Dest,nDest);
    nDest=0;
  end

  Dest[nDest]=Ch;
  inc  nDest;
end


void     Decl(char @Inst)
  word   I=0;
  while  Inst[I]!=#0 do
    Save(Inst[I]);
    inc  I;
  end

  Save(#13); //Save('~r');
  Save(#10); //Save('~n');
end


void     Emit(word L; char @Inst)
  if L!=0 then
    Save('@');

    char  @P=@str(L,0);
    word   I=0;
    while  P[I]!=#0 do
      Save(P[I]);
      inc    I;
    end

    Save(':');
    Save(' ');
  else
    word  I=0;
    while I<8 do
      Save(' ');
      inc I;
    end
  end

  Decl(@Inst);
end


word     Even(word Ofs)
  while  Ofs%4!=0 do
    inc  Ofs;
  end

  return Ofs;
end


word     Enum(word P; word Flag; word @L)
  if P>=nNODE then
    return 0;
  end

  select
    case Flag!=0:
      word  S=0;
      word  M=0;
      while P<nNODE do
        select
          case Node[P].ID=iSELECT:
            word  P1=Node[Node[P].pLeft].pRight; // word  P1=Node[P].pLeft;
            while P1<nNODE do
              word P2=Node[P1].pLeft;

              Enum(Node[P2].pLeft,0,@L);

              Node[P2].Value=L;
              inc  L;

              word V=Enum(Node[P2].pRight,1,@L);
              if M<S+V then
                M=S+V;
              end

              Node[P1].Value=L;
              inc  L;

              P1=Node[P1].pRight;
            end

            Node[P].Value=L;
            inc  L;

          case Node[P].ID=iWHILE:
            word P1=Node[P] .pLeft;
            word P2=Node[P1].pLeft;

            Node[P2].Value=L;
            inc  L;

          //Enum(Node[P2].pLeft, 0,@L);
            Enum(Node[P2].pRight,0,@L);

            Node[P1].Value=L;
            inc  L;

            word V=Enum(Node[P1].pRight,1,@L);
            if M<S+V then
              M=S+V;
            end

            Node[P].Value=L;
            inc  L;

          case Node[P].ID=iDEF:
            word Size=4;
            if Node[Node[P].pLeft].Value=0 then
              Size=Dict[Node[P].Value].Value;
            end

            S=S+Even(Node[Node[Node[P].pLeft].pLeft].Value*Size);
            if M<S then
              M=S;
            end
        end

        P=Node[P].pRight;
      end

      return M;

    case Node[P].ID!=iASSIGN & Node[P].ID!=iINC & Node[P].ID!=iDEC:
      Enum(Node[P].pLeft, 0,@L);

      if iOR<=Node[P].ID & Node[P].ID<=iAND then
        Node[P].Value=L;
        inc  L;
      end

      Enum(Node[P].pRight,0,@L);
  end

  return 0;
end


word    pSize;
word    pVar;

word     Code(word P; word F; word T; word M)
  char Buff [nBUFF];
  select
    case Node[P].ID=iNULL:
      Emit(0,"xor     EAX,  EAX");
      return nDICT;

    case Node[P].ID=iCHAR:
      Emit(0,@strcat(@strcpy(@Buff,"mov     AL,   "),@str(Node[P].Value,0)));
      return  Find("char");

    case Node[P].ID=iWORD:
      if Node[Node[P].pLeft].ID!=iEMPTY then
        Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  "),@str(Node[P].Value,0)));
      else
        Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  "),@str(Node[P].Value,Node[Node[P].pLeft].Value)));
      end
      return  Find("word");

    case Node[P].ID=iFUNC:
    //Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  offset @"),@str(Dict[Node[P].Value].Value,0))); // TASM
      Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  @"),@str(Dict[Node[P].Value].Value,0)));        // FASM
      return nDICT;

    case Node[P].ID=iDATA | Node[P].ID=iPARM | Node[P].ID=iLOCAL | Node[P].ID=iSTRING | Node[P].ID=iINC | Node[P].ID=iDEC:
      word ID1=Node[P].ID;
      if ID1=iINC | ID1=iDEC then
        P=Node[P].pLeft;
      end

      word pType;
      word nPtr;
      word  Ofs;
      word  High=0;
      select
        case Node[P].ID=iDATA:
          pType=Dict[Node[P].Value].pType;
          nPtr =Dict[Node[P].Value].nPtr;
          Ofs  =Dict[Node[P].Value]. Value;
          High =Dict[Node[P].Value]. High;

        case Node[P].ID=iPARM:
          pType=Parm[Node[P].Value].pType;
          nPtr =Parm[Node[P].Value].nPtr;
          Ofs  =Parm[Node[P].Value]. Value;

        case Node[P].ID=iLOCAL:
          pType=Parm[Node[P].Value+pParm].pType;
          nPtr =Parm[Node[P].Value+pParm].nPtr;
          Ofs  =Parm[Node[P].Value+pParm]. Value;

        case Node[P].ID=iSTRING:
          pType=Dict[Node[P].Value].pType;
          nPtr =1;
          Ofs  =Dict[Node[P].Value].pIndx;

        default:
          Stop(@eINTERNAL);
      end

      word ID=Node[P]. ID;
      word P1=Node[P].pRight; // word P1=Node[P].pLeft;
      while TRUE do
        select
          case P1>=nNODE:
            select
              case ID1=iINC | ID1=iDEC:
                if ID1=iINC then
                //strcpy(@Buff,"inc     dword ptr "); // TASM
                  strcpy(@Buff,"inc     dword ");     // FASM
                else
                //strcpy(@Buff,"dec     dword ptr "); // TASM
                  strcpy(@Buff,"dec     dword ");     // FASM
                end

                select
                  case ID=iDATA:
                  //Emit(0,@strcat(@strcat(@strcat(@Buff,"@@DATA["),@str(Ofs,High)),"]"));  // TASM
                    Emit(0,@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs,High)),"]")); // FASM

                  case ID=iPARM:
                  //Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Parm[Node[P].Value].Value,0)),"]"));
                    Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs,0)),"]"));

                  case ID=iLOCAL:
                  //Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Parm[Node[P].Value+pParm].Value,0)),"]"));
                    Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs,0)),"]"));

                  case ID=iREF:
                    Emit(0,@strcat(@strcat(@strcat(@Buff,"[EAX+"),@str(Ofs,0)),"]"));

                  default:
                    Stop(@eINTERNAL);
                end

              case ID!=iCALL:
                if Node[P].pRight<nNODE then // Node[P].pLeft<nNODE
                  if ID=iREF then
                    Emit(0,"xchg    EAX,  EBX");
                  end

                  Emit(0,"pop     EAX");
                end

                word Size=4;
                if nPtr=0 then
                  Size=Dict[pType].Value;
                end

                select
                  case Size=1:
                  //strcpy(@Buff,"mov     byte  ptr "); // TASM
                    strcpy(@Buff,"mov     byte  ");     // FASM

                  case Size=4:
                  //strcpy(@Buff,"mov     dword ptr "); // TASM
                    strcpy(@Buff,"mov     dword ");     // FASM

                  default:
                    Stop(@eINTERNAL);
                end

                select
                  case ID=iDATA:
                  //strcat(@Buff,"@@DATA[");  // TASM
                    strcat(@Buff,"[@@DATA+"); // FASM

                  case ID=iPARM:
                    strcat(@Buff,"[EBP+");

                  case ID=iLOCAL:
                    strcat(@Buff,"[EBP-");

                  case ID=iREF:
                    strcat(@Buff,"[EBX+");

                  default:
                    Stop(@eINTERNAL);
                end

                select
                  case Size=1:
                    Emit(0,@strcat(@strcat(@Buff,@str(Ofs,High)),"], AL"));

                  case Size=4:
                    Emit(0,@strcat(@strcat(@Buff,@str(Ofs,High)),"], EAX"));

                  default:
                    Stop(@eINTERNAL);
                end
            end

            exit

          case Node[P1].ID=iLOAD:
            word Size=4;
            if nPtr=0 then
              Size = Dict[pType].Value;
            else
              pType=nDICT;
            end

            select
              case Size=1:
              //strcpy(@Buff,"mov     AL,   byte  ptr "); // TASM
                strcpy(@Buff,"mov     AL,   byte  ");     // FASM

              case Size=4:
              //strcpy(@Buff,"mov     EAX,  dword ptr "); // TASM
                strcpy(@Buff,"mov     EAX,  dword ");     // FASM

              default:
                Stop(@eINTERNAL);
            end

            select
              case ID=iDATA:
              //Emit(0,@strcat(@strcat(@strcat(@Buff,"@@DATA["),@str(Ofs,High)),"]"));  // TASM
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs,High)),"]")); // FASM

              case ID=iPARM:
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs,0)),"]"));

              case ID=iLOCAL:
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs,0)),"]"));

              case ID=iREF:
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[EAX+"),@str(Ofs,0)),"]"));
            end

            return pType;

          case Node[P1].ID=iLPTR:
            select
              case ID=iDATA:
              //Emit(0,@strcat(@strcat(@strcpy(@Buff,"mov     EAX,  offset @@DATA["),@str(Ofs,High)),"]")); // TASM
                Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  @@DATA+"),@str(Ofs,High)));                     // FASM

              case ID=iPARM:
                Emit(0,"mov     EAX,  EBP");
                Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs,0)));

              case ID=iLOCAL:
                Emit(0,"mov     EAX,  EBP");
                Emit(0,@strcat(@strcpy(@Buff,"sub     EAX,  "),@str(Ofs,0)));

              case ID=iSTRING:
              //Emit(0,@strcat(@strcat(@strcpy(@Buff,"mov     EAX,  offset @@TEXT["),@str(Ofs,0)),"]")); // TASM
                Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  @@TEXT+"),@str(Ofs,0)));                     // FASM

              case ID=iREF & Ofs!=0:
                Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs,0)));
            end

            return nDICT;

          case Node[P1].ID=iCALL:
            if Node[P1].pLeft<nNODE then
              Code(Node[P1].pLeft,0,0,0);
            end

            if Dict[Node[P1].Value].Sub=sSYS then
            //Emit(0,@strcat(@strcpy(@Buff,"call    "),@Dict[Node[P1].Value].Name));                       // TASM
              Emit(0,@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Node[P1].Value].Value,0)),"]")); // FASM
            else
              Emit(0,@strcat(@strcpy(@Buff,"call    @"),@str(Dict[Node[P1].Value].Value,0)));
            end

            ID  =iCALL;
            Ofs =    0;
            High=    0;

          case Node[P1].ID=iINDEX:
            if ID=iREF then
              Emit(0,"push    EAX");
            end

            Code(Node[P1].pLeft,0,0,0);

            if Node[P1].pRight<nNODE then
              if Node[Node[P1].pRight].ID=iINDEX then
                Stop(@eNOTAVAIL);
              end
            end

            word Size=4;
            if nPtr=0 then
              Size=Dict[pType].Value;
            end

            select
              case Size=4:
                Emit(0,"shl     EAX,  2");

              case Size>1:
                Emit(0,@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(Size,0)));
            end

            select
              case ID=iDATA:
              //Emit(0,@strcat(@strcat(@strcpy(@Buff,"add     EAX,  offset @@DATA["),@str(Ofs,High)),"]")); // TASM
                Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  @@DATA+"),@str(Ofs,High)));                     // FASM

              case ID=iPARM:
                Emit(0,"add     EAX,  EBP");
                Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs,0)));

              case ID=iLOCAL:
                Emit(0,"add     EAX,  EBP");
                Emit(0,@strcat(@strcpy(@Buff,"sub     EAX,  "),@str(Ofs,0)));

              case ID=iREF:
                Emit(0,"pop     EBX");
                Emit(0,"add     EAX,  EBX");
            end

            ID  =iREF;
            Ofs =   0;
            High=   0;

          case Node[P1].ID=iADDR:
            dec nPtr;
            if Node[P1].pLeft<nNODE then
              if ID=iREF then
                Emit(0,"push    EAX");
              end

              Code(Node[P1].pLeft,0,0,0);

              word Size=4;
              if nPtr=0 then
                Size=Dict[pType].Value;
              end

              select
                case Size=4:
                  Emit(0,"shl     EAX,  2");

                case Size>1:
                  Emit(0,@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(Size,0)));
              end

            //strcpy(@Buff,"add     EAX,  dword ptr "); // TASM
              strcpy(@Buff,"add     EAX,  dword ");     // FASM
            else
            //strcpy(@Buff,"mov     EAX,  dword ptr "); // TASM
              strcpy(@Buff,"mov     EAX,  dword ");     // FASM
            end

            select
              case ID=iDATA:
              //Emit(0,@strcat(@strcat(@strcat(@Buff,"@@DATA["),@str(Ofs,High)),"]"));  // TASM
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs,High)),"]")); // FASM

              case ID=iPARM:
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs,0)),"]"));

              case ID=iLOCAL:
                Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs,0)),"]"));

              case ID=iREF:
                if Node[P1].pLeft<nNODE then
                  Emit(0,"pop     EBX");
                  Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBX+"),@str(Ofs,0)),"]"));
                else
                  Emit(0,@strcat(@strcat(@strcat(@Buff,"[EAX+"),@str(Ofs,0)),"]"));
                end
            end

            ID  =iREF;
            Ofs =   0;
            High=   0;

          case Node[P1].ID=iFIELD: // !!!
            pType=Parm[Node[P1].Value].pType;
            nPtr =Parm[Node[P1].Value].nPtr;
            if ID!=iLOCAL then
              Ofs=Ofs+Parm[Node[P1].Value].Value;
            else
              Ofs=Ofs-Parm[Node[P1].Value].Value;
            end

          default:
            Stop(@eINTERNAL);
        end

        P1=Node[P1].pRight;
      end

    case Node[P].ID=iCAST:
      word pType=Code(Node[Node[P].pLeft].pLeft,0,0,0);
      select
        case Node[P].Value=Find("word") & pType=Find("char"):
          Emit(0,"and     EAX,  0FFH");
          return  Node[P].Value;

        default:
          Stop(@eINTERNAL);
      end

    case Node[P].ID=iOR:
      if T=0 then
        Code(Node[P].pLeft, 0,M,Node[P].Value);
        Emit(Node[P].Value,"");
        Code(Node[P].pRight,F,0,M);
      else
        Code(Node[P].pLeft, 0,T,Node[P].Value);
        Emit(Node[P].Value,"");
        Code(Node[P].pRight,0,T,M);
      end

    case Node[P].ID=iAND:
      if T=0 then
        Code(Node[P].pLeft, F,0,Node[P].Value);
        Emit(Node[P].Value,"");
        Code(Node[P].pRight,F,0,M);
      else
        Code(Node[P].pLeft, M,0,Node[P].Value);
        Emit(Node[P].Value,"");
        Code(Node[P].pRight,0,T,M);
      end

    case iBIT_OR<=Node[P].ID & Node[P].ID<=iMOD:
      word pType;
      select
        case Node[Node[P].pRight].ID=iCHAR:
          pType=Code(Node[P].pLeft,0,0,0);
          Emit(0,@strcat(@strcpy(@Buff,"mov     BL,   "),@str(Node[Node[P].pRight].Value,0)));

        case Node[Node[P].pRight].ID=iWORD:
          pType=Code(Node[P].pLeft,0,0,0);
          if Node[Node[Node[P].pRight].pLeft].ID!=iEMPTY then
            Emit(0,@strcat(@strcpy(@Buff,"mov     EBX,  "),@str(Node[Node[P].pRight].Value,0)));
          else
            Emit(0,@strcat(@strcpy(@Buff,"mov     EBX,  "),@str(Node[Node[P].pRight].Value,Node[Node[Node[P].pRight].pLeft].Value)));
          end

        case Node[Node[Node[P].pLeft] .pRight].ID=iLOAD: // Node[Node[Node[P].pLeft] .pLeft].ID=iLOAD
          Code(Node[P].pRight,0,0,0);
          Emit(0,"xchg    EAX,  EBX");
          pType=Code(Node[P].pLeft,0,0,0);

        case Node[Node[Node[P].pRight].pRight].ID=iLOAD: // Node[Node[Node[P].pRight].pLeft].ID=iLOAD
          pType=Code(Node[P].pLeft,0,0,0);
          Emit(0,"xchg    EAX,  EBX");
          Code(Node[P].pRight,0,0,0);
          Emit(0,"xchg    EAX,  EBX");

        default:
          Code(Node[P].pRight,0,0,0);
          Emit(0,"push    EAX");
          pType=Code(Node[P].pLeft,0,0,0);
          Emit(0,"pop     EBX");
      end

      word Size=4;
      if pType<nDICT then
        Size=Dict[pType].Value;
      end

      select
        case iLT<=Node[P].ID & Node[P].ID<=iGT:
          select
            case Size=1:
              Emit(0,"cmp     AL,   BL");

            case Size=4:
              Emit(0,"cmp     EAX,  EBX");

            default:
              Stop(@eINTERNAL);
          end

          word ID=Node[P].ID;
          if T=0 then
            select
              case ID=iLT:
                ID=iGE;

              case ID=iLE:
                ID=iGT;

              case ID=iEQ:
                ID=iNE;

              case ID=iNE:
                ID=iEQ;

              case ID=iGE:
                ID=iLT;

              case ID=iGT:
                ID=iLE;

              default:
                Stop(@eINTERNAL);
            end

            T=F;
            F=0;
          end

          if T=0 | F!=0 then
            Stop(@eINTERNAL);
          end

          select
            case ID=iLT:
              Emit(0,@strcat(@strcpy(@Buff,"jb      @"),@str(T,0)));

            case ID=iLE:
              Emit(0,@strcat(@strcpy(@Buff,"jbe     @"),@str(T,0)));

            case ID=iEQ:
              Emit(0,@strcat(@strcpy(@Buff,"je      @"),@str(T,0)));

            case ID=iNE:
              Emit(0,@strcat(@strcpy(@Buff,"jne     @"),@str(T,0)));

            case ID=iGE:
              Emit(0,@strcat(@strcpy(@Buff,"jae     @"),@str(T,0)));

            case ID=iGT:
              Emit(0,@strcat(@strcpy(@Buff,"ja      @"),@str(T,0)));

            default:
              Stop(@eINTERNAL);
          end

          return nDICT;

        case Node[P].ID=iBIT_OR:
          strcpy(@Buff,"or      ");

        case Node[P].ID=iBIT_AND:
          strcpy(@Buff,"and     ");

        case Node[P].ID=iADD:
          strcpy(@Buff,"add     ");

        case Node[P].ID=iSUB:
          strcpy(@Buff,"sub     ");

        case Node[P].ID=iMUL:
          Emit(0,"mul     EBX");
          return pType;

        case Node[P].ID=iDIV | Node[P].ID=iMOD:
          Emit(0,"xor     EDX,  EDX");
          Emit(0,"div     EBX");
          if Node[P].ID=iMOD then
            Emit(0,"xchg    EAX,  EDX");
          end

          return pType;

        default:
          Stop(@eINTERNAL);
      end

      select
        case Size=4:
          Emit(0,@strcat(@Buff,"EAX,  EBX"));

        default:
          Stop(@eINTERNAL);
      end

      return pType;

    case Node[P].ID=iDEF:
      if nParm>=nPARM then
        Stop(@eNOMEMORY);
      end

      word pType=Node[P].Value;
      word nPtr =Node[Node[P].pLeft].Value;
      word  Size=4;
      if nPtr=0 then
        Size=Dict[Node[P].Value].Value;
      end

      pVar=pVar+Even(Node[Node[Node[P].pLeft].pLeft].Value*Size);

      Parm[nParm].pType=pType;
      Parm[nParm].nPtr =nPtr;
      Parm[nParm].Value=pVar;
      inc  nParm;

      Code(Node[Node[P].pLeft].pLeft,0,0,0);

    case Node[P].ID=iPUSH:
      if Node[P].pRight<nNODE then
        Code(Node[P].pRight,0,0,0);
      end

      Code(Node[P].pLeft,0,0,0);
      Emit(0,"push    EAX");

    case Node[P].ID=iASSIGN:
      P =Node[P].pLeft;
      if Node[P].pRight<nNODE then
        Code(Node[P].pRight,0,0,0);
        if Node[Node[P].pLeft].pRight<nNODE then // Node[Node[P].pLeft].pLeft<nNODE
          Emit(0,"push    EAX");
        end
      end

      Code(Node[P].pLeft,0,0,0);

    case Node[P].ID=iRETURN:
      if Node[P].pLeft<nNODE then
        Code(Node[P].pLeft,0,0,0);
      end

      Emit(0,"mov     ESP,  EBP");
      Emit(0,"pop     EBP");

      if Dict[pFunc].Sub=sMAIN then
        Emit(0,"xor     EAX,  EAX");
        Emit(0,"push    EAX");
      //Emit(0,"call    ExitProcess");                                                                    // TASM
        Emit(0,@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Find("ExitProcess")].Value,0)),"]")); // FASM
      else
        Emit(0,@strcat(@strcpy(@Buff,"ret     "),@str(pSize,0)));
      end

    case Node[P].ID=iSELECT:
      word E=Node[P].Value;

      P=Node[Node[P].pLeft].pRight; // word  P=Node[P].pLeft;
      while P<nNODE do
        if Node[Node[P].pLeft].pLeft<nNODE then
          F=Node[P].Value;
          T=Node[Node[P].pLeft].Value;
          Code(Node[Node[P].pLeft].pLeft,F,0,T);
          Emit(T,"");
        end

        word nParm1=nParm;
        word pVar1 =pVar;

        word  P1=Node[Node[P].pLeft].pRight;
        while P1<nNODE do
          Code(P1,0,0,0);
          P1=Node[P1].pRight;
        end

        pVar =pVar1;
        nParm=nParm1;

        if Node[P].pRight<nNODE then
          Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(E,0)));
        end

        if Node[Node[P].pLeft].pLeft<nNODE then
          Emit(F,"");
        end

        P=Node[P].pRight;
      end

      Emit(E,"");

    case Node[P].ID=iWHILE:
      F=Node[P].Value;
      P=Node[P].pLeft;
      T=Node[P].Value;

      word L=Node[Node[P].pLeft].Value;
      Emit(L,"");
    //if Node[Node[P].pLeft].pLeft <nNODE then
      if Node[Node[P].pLeft].pRight<nNODE then
      //Code(Node[Node[P].pLeft].pLeft, F,0,T);
        Code(Node[Node[P].pLeft].pRight,F,0,T);
        Emit(T,"");
      end

      word nParm1=nParm;
      word pVar1 =pVar;

      word  P1=Node[P].pRight;
      while P1<nNODE do
        Code(P1,0,0,0);
        P1=Node[P1].pRight;
      end

      pVar =pVar1;
      nParm=nParm1;

      Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(L,0)));
      Emit(F,"");

    case Node[P].ID=iLOOP | Node[P].ID=iEXIT:
      Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(Node[Node[P].Value].Value,0)));

    case Node[P].ID=iEMPTY:
    //null

    default:
      Stop(@eINTERNAL);
  end

  return nDICT;
end


begin
  word @Size   =@Ptr(GetPSP(),128);
  char @Command=@Ptr(GetPSP(),129);

  word  I=0;
  while I<Size%256 & Command[I] =' ' do
    inc I;
  end

  char  Name [nBUFF];
  word  K=0;
  while I<Size%256 & Command[I]!=' ' do
    Name[K]=Command[I];
    inc  K;

    if   K>=nBUFF then
      outs("Слишком длинное имя файла");
      return
    end

    inc  I;
  end
  Name[K]=#0;

  while I<Size%256 & Command[I] =' ' do
    inc I;
  end

  char  Dest2 [nBUFF];
  word  M=0;
  while I<Size%256 & Command[I]!=' ' do
    Dest2[M]=Command[I];
    inc   M;

    if   M>=nBUFF then
      outs("Неизвестный паpаметp");
      return
    end

    inc  I;
  end
  Dest2[M]=#0;

  if K=0 then
    outs("Тpанслятоp языка Context. Веpсия 2.0");
    outs("(C) Хохлов А.В.  г.Москва  1995-2004");
    outs("Использование: context <файл> [/c|w]");

    return
  end

  word pExt=0;

  I=0;
  K=0;
  while Name[I]!=#0 do
    select
      case Name[I]='.':
        pExt=I;
      case Name[I]='\':
        pExt=0;
        K   =I+1;
    end

    inc I;
  end

  if pExt=0 then
    if I+4>=nBUFF then
      outs("Слишком длинное имя файла");
      return
    end

    strcpy(@Name[I],".ctx");

    pExt=I;
    I   =I+4;
  end

  if I-K>=nINFO then
    outs("Слишком длинное имя файла");
    return
  end

  strcpy(@Info,@Name[K]);

  select
    case strcmp(@Dest2,"/c")=0:
      strcpy(@Dest2,"CONSOLE");

    case strcmp(@Dest2,"/w")=0:
      strcpy(@Dest2,"GUI");

    default:
      if strlen(@Dest2)>0 then
        outs("Неизвестный паpаметp");
        return
      end

      strcpy(@Dest2,"CONSOLE");
  end

  hText=open(@Name);
//if hText=$FFFFFFFF then
  if hText=$FFFF then
    outs(@strcat(@strcpy(@Name,@Info),"(0): Невозможно откpыть файл"));
    return
  end

  nDict=0;                                  // Инициализация счетчиков
  nParm=0;
  nIndx=0;
  nChar=0;
//nNode=0;

  strcpy(@Text,"define @COMPILER _Context 2.0 for Win32___"); //strcpy(@Text,"define @COMPILER ~"Context 2.0 for Win32~"~r~n");
  Text[17]=#34;
  Text[39]=#34;
  Text[40]=#13;
  Text[41]=#10;
  strcat(@Text,"void    ExitProcess(word uExitCode) external KERNEL32;");

  nText=strlen(@Text);
  pText=0;
  nLine=0;

  strcpy(@Name[pExt],".asm");

  hDest=create(@Name);
  nDest=0;

  pLoop=nNODE;

  Word("define");                           // Заполнение таблицы имен
  Word("struct");
  Word("synonym");
  Word("function");
  Word("external");
  Word("begin");
  Word("select");
  Word("case");
  Word("default");
  Word("if");
  Word("then");
  Word("else");
  Word("while");
  Word("do");
  Word("loop");
  Word("exit");
  Word("inc");
  Word("dec");
  Word("return");
  Word("null");
  Word("NULL");
  Word("end");

  Base("void",0);
  Base("char",1);
  Base("byte",1);
  Base("word",4);

  char  Buff [nBUFF];

//Decl(".386");                                            // TASM
//Decl(".model  flat,   stdcall");
  Decl(@strcat(@strcpy(@Buff,"format  PE      "),@Dest2)); // FASM
  Decl("");

  strcpy(@Buff,"section _.code_ code readable executable");// Decl("section ~".code~" code readable executable"); // FASM
  Buff[ 8]=#34;
  Buff[14]=#34;
  Decl(@Buff);

  word  L  =10000;
  word  F  =60000; // FASM
  long  D;

  D.Lo =0;
  D.Hi =0;

  word  S;

//word  Ext=1;

  while TRUE do                             // Синтаксический анализ
    Scan(@Buff);
    select
      case strcmp(@Buff,"begin")=0:         // Главная функция
        if nDict>=nDICT then
          Stop(@eNOMEMORY);
        end

        pFunc=nDict;
        pParm=nParm;
        pIndx=nIndx;
        nNode=    0;

        Dict[nDict]. Class=cFUNC;            strcpy(@Dict[nDict].Name,"");
        Dict[nDict]. Sub  =sMAIN;
        Dict[nDict].pType = Find("void");
        Dict[nDict].nPtr  = 0;
        Dict[nDict].pIndx =nParm;
        Dict[nDict].nIndx =nParm;
        inc  nDict;

      /*word pNode;
        word @P   =@pNode; // @Dict[pFunc].pNode;
        word  Flag= 0;

        Scan(@Buff);
        while Flag=0 | strcmp(@Buff,"end")!=0 do
          P   = Ctrl(@Buff);
          @P  =@Node[P].pRight;
          Flag= 1;
        end*/

        word pNode=Ctrl(@Scan(@Buff));

        word  P=pNode;
        while strcmp(@Buff,"end")!=0 do
          Node[P].pRight=Ctrl(@Buff);
          P             =Node[P].pRight;
        end

        nIndx=pIndx;
        nParm=pParm;

        Decl("");
        Emit(L,"       ;begin");
        S=   L;
        inc  L;

        Emit(0,"push    EBP");
        Emit(0,"mov     EBP,  ESP");

        word V=Enum(pNode,1,@L);
        if V>0 then
          Emit(0,@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(V,0)));
        end

        pParm=nParm;
        pSize= 0;
        pVar = 0;

        word  P1=pNode;
        word  ID;
        while P1<nNODE do
          Code   (P1,0,0,0);
          ID=Node[P1].ID;
          P1=Node[P1].pRight;
        end

        if ID!=iRETURN then
          Emit(0,"mov     ESP,  EBP");
          Emit(0,"pop     EBP");
          Emit(0,"xor     EAX,  EAX");
          Emit(0,"push    EAX");
        //Emit(0,"call    ExitProcess");                                                                    // TASM
          Emit(0,@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Find("ExitProcess")].Value,0)),"]")); // FASM
        end

        exit

      case strcmp(@Buff,"define")=0:        // Константа
        word nPtr=0;
        if strcmp(@Scan(@Buff),"@")=0 then
          Scan(@Buff);
          nPtr=1;
        end

        if Find(@Buff)<nDict then
          Stop(@eDUPLICATE);
        end

        if nDict>=nDICT then
          Stop(@eNOMEMORY);
        end

        Dict[nDict]. Class=cCONST;             Copy(@Dict[nDict].Name,@Buff,nDict);
        Dict[nDict].nPtr  =     0;

        if nPtr=0 then
          Dict[nDict].pType=Find("word");
          Dict[nDict].Value=val (@Scan(@Buff)).Lo;
        else
        //if strcmp(@Scan(@Buff),"~"")!=0 then
          Scan(@Buff);                      // 10.12.2005
          if Buff[0]!='"' then
            Stop(@eQUOTEXP);
          end

          Line();
        end

        inc nDict;

      case strcmp(@Buff,"struct")=0:        // Стpуктуpа
        word pType=Find(@Scan(@Buff));
        if pType<nDict then
          Stop(@eDUPLICATE);
        end

        if nDict>=nDICT then
          Stop(@eNOMEMORY);
        end

        Dict[nDict]. Class=cTYPE;              Copy(@Dict[nDict].Name,@Buff,nDict);
        Dict[nDict]. Sub  =sSTRUCT;
        Dict[nDict].pIndx =nParm;

        if strcmp(@Scan(@Buff),";")=0 then
          Stop(@eNOTAVAIL);
        end

        word  D1=0;

        word pParm=nParm;
        while TRUE do
          pType=Find(@Buff);
          if   pType>=nDict | Dict[pType].Class!=cTYPE then
            Stop(@eTYPEEXP);
          end

          while TRUE do
            word  nPtr=0;
            while strcmp(@Scan(@Buff),"@")=0 do
              inc nPtr;
            end

            if pType=Find("void") & nPtr<1 then
              Stop(@eNOVOID);
            end

            I=pParm;
            while I<nParm do
              if strcmp(@Parm[I].Name,@Buff)=0 then
                Stop(@eDUPLICATE);
              end

              inc I;
            end

            if nParm>=nPARM then
              Stop(@eNOMEMORY);
            end

            Parm[nParm].pType =pType;          Copy(@Parm[nParm].Name,@Buff,0);
            Parm[nParm].nPtr  =nPtr;
            Parm[nParm].pIndx =nIndx;
            Parm[nParm].nIndx = Tabl(@Scan(@Buff));
            Parm[nParm]. Value= D1;

            word D2=4;
            if nPtr=0 then
              D2=Dict[pType].Value;
            end

            word N=Parm[nParm].pIndx;
            while N<Parm[nParm].nIndx do
              D2= Indx[N]*D2;
              inc N;
            end

            D1=D1+D2;

            inc  nParm;

            if strcmp(@Buff,";") =0 then
              exit
            end

            if strcmp(@Buff,",")!=0 then
              Stop(@eSEMICOLONEXP);
            end
          end

          if strcmp(@Scan(@Buff),"end")=0 then
            exit
          end
        end

        Dict[nDict].nIndx =nParm;
        Dict[nDict]. Value= D1;
        inc  nDict;

      case strcmp(@Buff,"synonym")=0:       // Синоним
        if Find(@Scan(@Buff))<nDict then
          Stop(@eDUPLICATE);
        end

        if nDict>=nDICT then
          Stop(@eNOMEMORY);
        end

        Dict[nDict].Class=cNAME;               Copy(@Dict[nDict].Name,@Buff,nDict);

        word pType=Find(@Scan(@Buff));
        if pType>=nDict then
          Stop(@eUNDEFINED);
        end

        Dict[nDict].pType=pType;
        inc  nDict;

      default:                              // Пеpеменная, функция, ...
        word pType=Find(@Buff);
        if   pType>=nDict | Dict[pType].Class!=cTYPE then
          Stop(@eTYPEEXP);
        end

        if strcmp(@Scan(@Buff),"function")=0 then
          Stop(@eNOTAVAIL);
        end

        word Flag=0;
        while TRUE do
          word  nPtr=0;
          while strcmp(@Buff,"@")=0 do
            inc nPtr;
            Scan(@Buff);
          end

          if Find(@Buff)<nDict then
            Stop(@eDUPLICATE);
          end

          if nDict>=nDICT then
            Stop(@eNOMEMORY);
          end

          Dict[nDict].pType=pType;             Copy(@Dict[nDict].Name,@Buff,nDict);
          Dict[nDict].nPtr =nPtr;

          Scan(@Buff);
          select
            case strcmp(@Buff,"(")=0:       // Функция
              if Flag!=0 then
                Stop(@eNOFUNCTION);
              end

              pFunc=nDict;

              Dict[nDict]. Class=cFUNC;
              Dict[nDict]. Sub  =sFUNC;
              Dict[nDict].pIndx =nParm;
              Dict[nDict].nIndx = List(@Scan(@Buff));
              inc  nDict;

              Scan(@Buff);
              select
                case strcmp(@Buff,";")=0:
                  Stop(@eNOTAVAIL);

                case strcmp(@Buff,"external")=0:
                /*if Ext=0 then
                    Stop(@eNOTAVAIL);
                  end*/

                  word pLib=Find(@Scan(@Buff));
                  if   pLib>=nDict then
                    if nDict>=nDICT then
                      Stop(@eNOMEMORY);
                    end

                    Dict[nDict]. Class=cFUNC;strcpy(@Dict[nDict].Name,@Dict[pFunc].Name);
                    Dict[nDict].pType =pType;
                    Dict[nDict].nPtr  =nPtr;
                    Dict[nDict].pIndx = Dict[pFunc].pIndx;
                    Dict[nDict].nIndx = Dict[pFunc].nIndx;

                    Dict[pFunc]. Class=cLIB; Copy  (@Dict[pFunc].Name,@Buff,nDict);
                    Dict[pFunc]. Value= F;

                    pLib =pFunc;
                    pFunc=nDict;
                    inc   nDict;
                  end

                  if strcmp(@Scan(@Buff),".")=0 then
                    if Find(@Scan(@Buff))<nDict then
                      Stop(@eDUPLICATE);
                    end

                    if nDict>=nDICT then
                      Stop(@eNOMEMORY);
                    end

                    Dict[nDict]. Class=cNAME;strcpy(@Dict[nDict].Name,@Dict[pFunc].Name);
                    Dict[nDict].pType=pFunc;
                    inc  nDict;

                    Copy(@Dict[pFunc].Name,@Buff,nDict);
                    Scan(@Buff);
                  end

                  Dict[pFunc].Sub   =sSYS;
                  Dict[pFunc].pNode =pLib;
                  Dict[pFunc]. Value= F;
                  inc   F;

                  if strcmp(@Buff,";")!=0 then
                    Stop(@eSEMICOLONEXP);
                  end

                /*word  N=strlen(@strcat(@strcpy(@Buff,"extrn   "),@Dict[pFunc].Name));
                  while N<nNAME+8 do
                    Buff[N]=' ';
                    inc  N;
                  end
                  Buff[N]=#0;

                  Emit(0,@strcat(@Buff,":proc"));*/

                default:
                /*if Ext!=0 then
                    Decl("");
                    Decl(".code");
                  end*/

                  pParm=nParm;
                  pIndx=nIndx;
                  nNode=    0;
                /*Flag =    0;

                  word pNode;
                  word @P=@pNode; //   @Dict[pFunc].pNode;
                  while Flag=0 | strcmp(@Buff,"end")!=0 do
                    P   = Ctrl(@Buff);
                    @P  =@Node[P].pRight;
                    Flag= 1;
                  end*/

                  word pNode=Ctrl(@Buff);

                  word  P=pNode;
                  while strcmp(@Buff,"end")!=0 do
                    Node[P].pRight=Ctrl(@Buff);
                    P             =Node[P].pRight;
                  end

                  nIndx=pIndx;
                  nParm=pParm;

                  Decl("");
                  Emit(L,@strcat(@strcpy(@Buff,"       ;"),@Dict[pFunc].Name));

                  Dict[pFunc].Value=L;
                  inc  L;

                  word S1=0;

                  K=Dict[pFunc].pIndx;
                  while K<Dict[pFunc].nIndx do
                    Parm[K].Value=S1+8;
                    if Parm[K].nPtr=0 then
                      S1=S1+Even(Dict[Parm[K].pType].Value);
                    else
                      S1=S1+4;
                    end

                    inc  K;
                  end

                  Emit(0,"push    EBP");
                  Emit(0,"mov     EBP,  ESP");

                  word V=Enum(pNode,1,@L);
                  if V>0 then
                    Emit(0,@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(V,0)));
                  end

                  pParm=nParm;
                  pSize= S1;
                  pVar = 0;

                  word  P1=pNode;
                  word  ID;
                  while P1<nNODE do
                    Code   (P1,0,0,0);
                    ID=Node[P1].ID;
                    P1=Node[P1].pRight;
                  end

                  if ID!=iRETURN then
                    Emit(0,"mov     ESP,  EBP");
                    Emit(0,"pop     EBP");
                    Emit(0,@strcat(@strcpy(@Buff,"ret     "),@str(pSize,0)));
                  end

                  nParm=pParm;

                //Ext  =    0;
              end

              exit

            default:                        // Пеpеменная
              if pType=Find("void") & nPtr<1 then
                Stop(@eNOVOID);
              end

              Dict[nDict]. Class=cDATA;
              Dict[nDict].pIndx =nIndx;
              Dict[nDict].nIndx = Tabl(@Buff);
              Dict[nDict].Value = D.Lo;
              Dict[nDict].High  = D.Hi;

              word D1=4;
              if Dict[nDict].nPtr=0 then
                D1=Dict[Dict[nDict].pType].Value;
              end

              word D2=1;

              word N=Dict[nDict].pIndx;
              while N<Dict[nDict].nIndx do
                D2=Indx[N]*D2;
                inc N;
              end

              D=Add(D,Mul(D1,D2));
              while D.Lo%4!=0 do
                if D.Lo<65535 then
                  inc D.Lo;
                else
                  inc D.Hi;
                  D.Lo = 0;
                end
              end

              inc  nDict;

              if strcmp(@Buff,";") =0 then
                exit
              end

              if strcmp(@Buff,",")!=0 then
                Stop(@eSEMICOLONEXP);
              end

              Scan(@Buff);
          end

          Flag=1;
        end
    end
  end

  Decl("");
//Decl(".data");                                           // TASM

  strcpy(@Buff,"section _.data_ data readable writeable"); // Decl("section ~".data~" data readable writeable"); // FASM
  Buff[ 8]=#34;
  Buff[14]=#34;
  Decl(@Buff);

  Buff[0]=#13;                                             // strcpy(@Buff,"~r~n@@TEXT  db     ");
  Buff[1]=#10;
  strcpy(@Buff[2],"@@TEXT  db    ");

  I=0;
  while I<nDict do
    if Dict[I].Class=cCONST & Dict[I].nPtr>0 then
      word N   =strlen(@Buff);
      word Flag=0;

      K=Dict[I].pIndx;
      while K<Dict[I].nIndx do
        if N+6>=nBUFF then
          Stop(@eINTERNAL);
        end

      //if Char[K]=#10 | Char[K]=#13 | Char[K]=#09 | Char[K]=#34 | Char[K]=#00 then //if Char[K]='~n' | Char[K]='~r' | Char[K]='~t' | Char[K]='~"' | Char[K]='~0' then
        if Char[K]<' ' | Char[K]='"' then
          if Flag!=0 then
            Buff[N]='"';
            inc  N;

            Flag=0;
          end

          if K>Dict[I].pIndx then
            Buff[N]=',';
            inc  N;
          else
            Buff[N]=' ';
            inc  N;
          end

          Buff[N]=' ';
          inc  N;

          char @P=@str(CharToWord(Char[K]),0);
          word  J=0;
          while P[J]!=#0 do
            Buff[N]=P[J];
            inc  N;
            inc  J;
          end
        else
          if Flag=0 then
            if K>Dict[I].pIndx then
              Buff[N]=',';
              inc  N;
            end

            Buff[N]=' ';
            inc  N;

            Buff[N]='"';
            inc  N;

            Flag=1;
          end

          Buff[N]=Char[K];
          inc  N;
        end

        inc  K;
      end
      Buff[N]=#0;

      Decl  (@Buff);
      strcpy(@Buff,"        db    ");
    end

    inc I;
  end

  if D.Lo>0 | D.Hi>0 then
    Decl("");
  //Decl(@strcat(@strcat(@strcpy(@Buff,"@@DATA  db      "),@str(D.Lo,D.Hi))," dup (?)")); // TASM
    Decl(@strcat(@strcpy(@Buff,"@@DATA  rb      "),@str(D.Lo,D.Hi)));                     // FASM
  end

  Decl("");
//Emit(0,@strcat(@strcpy(@Buff,"end     @"),@str(S,0)));           // TASM

  strcpy(@Buff,"section _.idata_ import data readable writeable"); // Decl("section ~".idata~" import data readable writeable"); // FASM
  Buff[ 8]=#34;
  Buff[15]=#34;
  Decl(@Buff);
  Decl("");

  word nLib=0;
  word  L1;

  L1=F;
  I =0;
  while I<nDict do
    if Dict[I].Class=cLIB then
      char Tmp1 [nBUFF];
      char Tmp2 [nBUFF];
      Emit(0,@strcat(@strcat(@strcat(@strcpy(@Buff,"dd      0, 0, 0, RVA @"),@strcpy(@Tmp1,@str(L1,0))),", RVA @"),@strcpy(@Tmp2,@str(Dict[I].Value,0))));
      inc  L1;
      inc nLib;
    end

    inc I;
  end

  Emit(0,"dd      0, 0, 0, 0, 0");

  I =0;
  while I<nDict do
    if Dict[I].Class=cLIB then
      Decl("");

      word  J=0;
      while J<nDict do
        if Dict[J].Class=cFUNC & Dict[J].Sub=sSYS & Dict[J].pNode=I then
          char Tmp1 [nBUFF];
          char Tmp2 [nBUFF];
          Decl(@strcat(@strcat(@strcat(@strcpy(@Buff,"@"),@strcpy(@Tmp1,@str(Dict[J].Value,0))),"  dd      RVA @"),@strcpy(@Tmp2,@str(L1,0))));
          inc  L1;
        end

        inc J;
      end

      Emit(0,"dd      0");
    end

    inc I;
  end

  Decl("");

  L1=F;
  I =0;
  while I<nDict do
    if Dict[I].Class=cLIB then
      strcat(@strcat(@strcpy(@Buff,"db     _"),@Dict[I].Name),".DLL_"); //Emit(L1,@strcat(@strcat(@strcpy(@Buff,"db     ~""),@Dict[I].Name),".DLL~", 0"));
      Buff[7]              =#34;
      Buff[strlen(@Buff)-1]=#34;
      Emit(L1,@strcat(@Buff,", 0"));
      inc  L1;
    end

    inc I;
  end

  I =0;
  while I<nDict do
    if Dict[I].Class=cLIB then
      Decl("");

      word  J=0;
      while J<nDict do
        if Dict[J].Class=cFUNC & Dict[J].Sub=sSYS & Dict[J].pNode=I then
          Emit(L1,"dw      0");
          strcat(@strcat(@strcpy(@Buff,"db     _"),@Dict[J].Name),"_"); //Emit(0,  @strcat(@strcat(@strcpy(@Buff,"db     ~""),@Dict[J].Name),"~", 0"));
          Buff[7]              =#34;
          Buff[strlen(@Buff)-1]=#34;
          Emit(0,  @strcat(@Buff,", 0"));
          inc  L1;
        end

        inc J;
      end
    end

    inc I;
  end

  Decl("");
  strcpy(@Buff,"section _.reloc_ fixups data readable discardable"); // Decl("section ~".reloc~" fixups data readable discardable");
  Buff[ 8]=#34;
  Buff[15]=#34;
  Decl(@Buff);

  Decl("");
  Emit(0,@strcat(@strcpy(@Buff,"entry   @"),@str(S,0)));             // FASM

  if nDest>0 then
    write(hDest,@Dest,nDest);
  end

  close(hDest);
  close(hText);

  putc (#13);
  puts (@Info);
  puts ("(");
  puts (@str(nLine,0));
  puts (")");
  putc (#13);
  putc (#10);

/*strcpy(@Name[pExt],".def");

  hDest=create(@Name);
  nDest=0;

  I=0;
  while I<nDict do
    if Dict[I].Class=cFUNC & Dict[I].Sub=sSYS then
      word  N=strlen(@strcat(@strcpy(@Buff,"imports "),@Dict[I].Name));
      while N<nNAME+8 do
        Buff[N]=' ';
        inc  N;
      end
      Buff[N]=#0;

      Decl(@strcat(@strcat(@strcat(@strcat(@Buff," = "),@Dict[Dict[I].pNode].Name),"."),@Dict[I].Name));
    end

    inc I;
  end

  if nDest>0 then
    write(hDest,@Dest,nDest);
  end

  close(hDest);

  puts (@strcat(@strcat(@strcat(@strcat(@strcpy(@Buff,"~r"),@Info),"("),@str(nLine,0)),")~r~n"));*/
end
