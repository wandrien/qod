# Правила приведение целочисленных типов в арифметических выражениях

Рассмотрим выражение `a + b`, где `a` и `b` — значения целочисленных типов, а `+` — некоторая ариметическая операции с двумя аргументами. Список арифметических операций указан в конце раздела.

Типы целых чисел могут быть знаковыми или беззнаковым, а также они могут иметь различное количество значащих бит.

Перед выполнением арифметической операции операнды должны быть неявно приведены к одному типу. При этом значение операнда может выйти за пределы области значений нового типа.

С учётом наличия/отсутствия знака и разного количества значащих бит, всего возможны 7 вариантов. В двух из них приведение типов не требуется. В трёх — приведение типа заведомо сохраняет значение в области допустимых значений. Еще в двух — значение операнда может выйти за пределы области значений нового типа.

Далее перечислены все варианты и действия, которые должна выполнить реализация.

```
1.
signed(N) + signed(N)
Приведение типов не требуется.
Тип результата: signed(N)

2.
unsigned(N) + unsigned(N)
Приведение типов не требуется.
Тип результата: unsigned(N)

3.
signed(n) + signed(N), где n < N
signed(n) расширяется до signed(N)
Тип результата: signed(N)

4.
unsigned(n) + unsigned(N), где n < N
unsigned(n) расширяется до unsigned(N)
Тип результата: unsigned(N)

5.
unsigned(n) + signed(N), где n < N
unsigned(n) расширяется до signed(N)
Тип результата: signed(N)

6.
signed(n) + unsigned(N), где n < N
Оба операнда приводятся к signed(N).
Тип результата: signed(N)
На этапе компиляции реализация обязана вывести диагностику в лог
или иным образом информировать пользователя. Допустимо ли продолжать
компиляцию, определяется реализацией. Если продолжение компиляции
допустимо, приведение типов и тип результата должны быть такими,
как указано выше.

7.
signed(N) + unsigned(N)
unsigned(N) приводится к signed(N).
Тип результата: signed(N)
На этапе компиляции реализация обязана вывести диагностику в лог
или иным образом информировать пользователя. Допустимо ли продолжать
компиляцию, определяется реализацией. Если продолжение компиляции
допустимо, приведение типов и тип результата должны быть такими,
как указано выше.
```

Набор ассертов для иллюстрации данных правил:

```
int8 i8; uint8 u8;
int32 i32; uint32 u32;

/* Следующие условия должны выполняться: */
static_assert(typeof(i8 + i8) == int8);    /* #1 */
static_assert(typeof(u8 + u8) == uint8);   /* #2 */
static_assert(typeof(i8 + i32) == int32);  /* #3 */
static_assert(typeof(u8 + u32) == uint32); /* #4 */
static_assert(typeof(u8 + i32) == int32);  /* #5 */
/* Если реализация допускает успешную компиляцию выражений,
   соответствующих пунктам 6 и 7, то следующие условия
   должны выполняться. */
static_assert(typeof(i8 + u32) == int32);  /* #6 */
static_assert(typeof(u32 + i32) == int32);  /* #7 */
```

Операции, к которым применяются указанные выше правила:

* сложение (+)
* вычитание (-)
* умножение (*)
* деление (/)
* взятие остатка (%)
* побитовое И (&)
* побитовое ИЛИ (|)
