# Правила приведение целочисленных типов в арифметических выражениях

Рассмотрим выражение `a + b`, где `a` и `b` — значения целочисленных типов, а `+` — некоторая ариметическая операции с двумя аргументами. Список арифметических операций указан в конце раздела.

Типы целых чисел могут быть знаковыми или беззнаковыми, а также они могут иметь различное количество значащих бит.

Перед выполнением арифметической операции операнды должны быть неявно приведены к общему типу.

С учётом наличия/отсутствия знака и разного количества значащих бит, всего возможны 7 вариантов. В двух из них приведение типов не требуется. В трёх — приведение типа заведомо сохраняет значение в области допустимых значений. Еще в двух — значение операнда может выйти за пределы области значений нового типа.

Далее перечислены все варианты и действия, которые должна выполнить реализация. В описании вариантов подразумевается, что всегда `n < N`: в ином случае просто считаем, что операнды стоят в обратном порядке, так как для описанных правил порядок операндов не важен.

```
1.
signed(N) + signed(N)
Приведение типов не требуется.
Тип результата: signed(N)

2.
unsigned(N) + unsigned(N)
Приведение типов не требуется.
Тип результата: unsigned(N)

3.
signed(n) + signed(N), где n < N
signed(n) расширяется до signed(N)
Тип результата: signed(N)

4.
unsigned(n) + unsigned(N), где n < N
unsigned(n) расширяется до unsigned(N)
Тип результата: unsigned(N)

5.
unsigned(n) + signed(N), где n < N
unsigned(n) расширяется до signed(N)
Тип результата: signed(N)

6.
signed(n) + unsigned(N), где n < N
Оба операнда приводятся к signed(N).
Тип результата: signed(N)
На этапе компиляции реализация обязана вывести диагностику в лог
или иным образом информировать пользователя. Допустимо ли продолжать
компиляцию, определяется реализацией. Если продолжение компиляции
допустимо, приведение типов и тип результата должны быть такими,
как указано выше.

7.
signed(N) + unsigned(N)
unsigned(N) приводится к signed(N).
Тип результата: signed(N)
На этапе компиляции реализация обязана вывести диагностику в лог
или иным образом информировать пользователя. Допустимо ли продолжать
компиляцию, определяется реализацией. Если продолжение компиляции
допустимо, приведение типов и тип результата должны быть такими,
как указано выше.
```

Набор ассертов для иллюстрации данных правил:

```
int8 i8; uint8 u8;
int32 i32; uint32 u32;

/* Следующие условия должны выполняться: */
static_assert(typeof(i8 + i8) == int8);    /* #1 */
static_assert(typeof(u8 + u8) == uint8);   /* #2 */
static_assert(typeof(i8 + i32) == int32);  /* #3 */
static_assert(typeof(u8 + u32) == uint32); /* #4 */
static_assert(typeof(u8 + i32) == int32);  /* #5 */
/* Если реализация допускает успешную компиляцию выражений,
   соответствующих пунктам 6 и 7, то следующие условия
   должны выполняться. */
static_assert(typeof(i8 + u32) == int32);  /* #6 */
static_assert(typeof(u32 + i32) == int32); /* #7 */
```

В практическом смысле требования пунктов 6 и 7 означают, что совместимая программа не должна иметь указанных сочетаний типов операндов арифметических операций. Вместе с тем, такие сочетания могут возникать достаточно часто, особенно при переносе алгоритмов с других ЯП. Чтобы пользователь не находился под давлением стимула «как можно скорее поставить все явные преобразования типов, чтобы добиться выполнения программы», а имел возможность подумать, какое именно решение будет верным, для реализации оставлена возможность выбора между выдачей предупреждения и ошибки.

Операции, к которым применяются указанные выше правила:

* сложение (+)
* вычитание (-)
* умножение (*)
* деление (/)
* взятие остатка (%)
* операции сравнения (==, !=, <, <=, >, >=)

### Информативная часть (примечания и пояснения)

* Вариантов семь, поскольку для правил, описанных здесь, порядок операндов не важен. `u8 - i32` и `i32 - u8` приводятся одинаковым образом: `u8` будет приведён в `typeof(i32)`.
* В случае, если один из типов знаковый, а второй беззнаковый, общее правило очень простое: наличие знака всегда побеждает. Это делает систему правил интуитивно понятной и устраняет целый класс ошибок, свойственных, например, C/C++.
* В качестве **варианта по умолчанию** в отношении правил 6 и 7 для реализации рекомендуется **прерывать компиляцию с выдачей ошибки**.
* Для операций `+`, `-`, `*`, `/`, `%` данные правила описывают как приведение операндов, так и тип результата. Однако продемонстрировать на наборе ассертов неявное приведение типов мы не можем, поэтому показаны равенства типов для результата. Следует иметь в виду, что для операций сравнения тип результата — `bool`. Однако приведение операндов перед сравнением выполняется по этим же правилам.
* Неявное приведение типа алгоритмически повторяет логику явного приведения целочисленных типов. Для исчерпывающего описания смотрите соответствующий раздел. Здесь будут указаны только краткие пояснения:
  * Приведение типа оставляет без изменений **арифметическое значение**, когда это возможно.
  * Если **арифметическое значение** не представимо в целевом типе, поведение зависит от контекста: `checked` или `unchecked`.
  * В `checked`-контексте попытка выполнения такого приведения вызывает **аварийное завершение программы**.
  * В `unchecked`-контексте результирующее значение будет таким, как описано в разделе о явном приведении типа.

