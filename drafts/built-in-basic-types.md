# Встроенные элементарные типы данных

# Тип `type`

Тип `type` — это тип всех типов.

Инстансами типа `type` являются все типы данных, включая сам `type`. Тип `type` является абстрактным, то есть не может быть инстанцирован отдельно как `type x;` и не может быть материализован в компилируемую форму.

Тип `type` не имеет размера, операция `sizeof(type)` приводит к ошибке при компиляции.

# Тип `void`

Тип `void` не может быть инстанцирован.

Тип `void` не имеет размера, операция `sizeof(void)` приводит к ошибке при компиляции.

Возможно объявлять указатели на тип `void`, но разыменование такого указателя является ошибкой времени компиляции.

Для функций тип возвращаемого значения `void` означает, что функция возвращает управление, но не возвращает никакого значения.

Для результата с типом `void` определена (неявная) операция «выполнить следующую команду в цепочке», и этим он отличается от результата с типом `noreturn`. (См. ниже.)

# Тип `noreturn`

Тип `noreturn` не может быть инстанцирован.

Тип `noreturn` не имеет размера, операция `sizeof(noreturn)` приводит к ошибке при компиляции.

Тип `noreturn` используется как тип возвращаемого значения для функций и означает, что функция не возвращает управление. (В неявном виде тип `noreturn` также используется компилятором для таких операторов как `return` или `exit`.)

Для результата с типом `noreturn` **не определена** (неявная) операция «выполнить следующую команду в цепочке», и этим он отличается от результата с типом `void`. Это означает, что результат с типом `noreturn` всегда завершает собой цепочку исполнения. Любые действия, которые расположены в цепочке далее, считаются мёртвым кодом и гарантированно устраняются компилятором.

В некотором смысле `noreturn` является «более пустым», чем `void`. Тип `void` сериализирует операторы языка в императивную цепочку действий, в то время как `noreturn` символизирует, что никаких действий далее не осталось.

# Тип `nulltype`

Тип `nulltype` это тип литерала `null`.

Тип `nulltype` может быть инстанцирован, но единственное допустимое значение типа — это `null`.

Таким образом запись `nulltype x;` означает, что `x` равен `null` и только лишь `null`, то есть значение `x` известно во время компиляции.

```
nulltype x, y;
static_assert(is_const_expr(x));
static_assert(x == null);
static_assert(x == y);
```

Размер типа `nulltype` совпадает с размером указателя.

# Булевы типы

Булевы типы порождаются конструктором типа `boolean(n_bits)`, где `n_bits` — количество значащих бит типа.

Определены следующие имена типов:

```
type bool8  = boolean(8);
type bool16 = boolean(16);
type bool32 = boolean(32);

type bool   = boolean(...); /* размер определяется реализацией */
```

Репрезентация булевых типов:

* Все значащие биты имеют нулевое значение — `false`.
* Любое иное значение бит  — `true`.

# Символьный тип `char`

Символьный тип `char` имеет размер 1 байт. Для типа `char` определены операции сравнения и порядка, но не определены арифметические и побитовые операции.

Тип `char` может быть эксплицитно приведён в целочисленный тип того же размера.

Тип `char` может быть эксплицитно приведён в целочисленный тип большего размера. При этом `char` считается беззнаковым.

Целочисленные типы могут быть эксплицитно приведены в `char`.

# Целочисленные типы

Целочисленные типы порождаются конструкторами типа `signed(n_bits)` и `unsigned(n_bits)`, где `n_bits` — количество значащих бит типа.

Определены следующие имена типов:

```
type int8    = signed(8);
type int16   = signed(16);
type int32   = signed(32); /* если поддерживается реализацией */
type int64   = signed(64); /* если поддерживается реализацией */
type int128  = signed(128); /* если поддерживается реализацией */

type byte    = unsigned(8);
type uint8   = unsigned(8);
type uint16  = unsigned(16);
type uint32  = unsigned(32); /* если поддерживается реализацией */
type uint64  = unsigned(64); /* если поддерживается реализацией */
type uint128 = unsigned(128); /* если поддерживается реализацией */


/* Для следующих типов размер определяется реализацией */
type int     = signed(...);
type long    = signed(...);
type intsz   = signed(...);
type intptr  = signed(...);
type uint    = unsigned(...);
type ulong   = unsigned(...);
type uintsz  = unsigned(...);
type uintptr = unsigned(...);
type word    = unsigned(...);
```

# Целочисленные типы с NaN

Целочисленные типы с NaN порождаются конструкторами типа `signed_with_nan(n_bits)` и `unsigned_with_nan(n_bits)`, где `n_bits` — количество значащих бит типа.

Определены следующие имена типов:

```
type wn_int8    = signed_with_nan(8);
type wn_int16   = signed_with_nan(16);
type wn_int32   = signed_with_nan(32); /* если поддерживается реализацией */
type wn_int64   = signed_with_nan(64); /* если поддерживается реализацией */
type wn_int128  = signed_with_nan(128); /* если поддерживается реализацией */

type wn_uint8   = unsigned_with_nan(8);
type wn_uint16  = unsigned_with_nan(16);
type wn_uint32  = unsigned_with_nan(32); /* если поддерживается реализацией */
type wn_uint64  = unsigned_with_nan(64); /* если поддерживается реализацией */
type wn_uint128 = unsigned_with_nan(128); /* если поддерживается реализацией */
```

# Типы с плавающей точкой

TODO
