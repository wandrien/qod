# Значения времени компиляции и времени выполнения

Значение выражения может иметь время жизни, ограниченное фазой компиляции программы, или время жизни, ограниченное временем фазой выполнения программы, или же иметь смысл как при компиляции, так и при выполнении программы.

Значения, время жизни которых ограничено фазой компиляции программы, называются <типы>. Типы существуют для того, чтобы компилятор мог проверить статическую корректность программы на этапе компиляции.

Значения, время жизни которых ограничено фазой выполнения программы - это значения переменных и выражений в традиционном понимании.

Значения, которые имеют смысл как при компиляции, так и привыполнении программы — это константные литералы, такие как `0`, `10` или `"Hello, World!"`, а также константные выражения, вычислимые компилятором, такие как `10 * 25`, `sizeof(int)`, `10 + 5 < 20`.

При помощи следующих операций можно в явном виде энфорсить время жизни выражения. Если условие не соблюдено, компиляция прерывается:

```
type_expr(expr) - выражение expr должно быть выражением типа.
const_expr(expr) - выражение expr должно быть константным выражением.
static_expr(expr) - выражение expr должно быть константным выражением или выражением типа.
tangible_expr(expr) - выражение expr не должно быть выражением типа.
```

В большинстве случаев в этих операциях нет необходимости, однако они могут использоваться для улучшения читабельности, чтобы пояснить мысль программиста, а также убедиться, что фактическое содержание кода соответствует этой мысли.

Также есть и соответствующие операции, которые во время компиляции вычисляются в `false` или `true` в зависимости от того, какое выражение им передано:

```
is_type_expr(expr)
is_const_expr(expr)
is_static_expr(expr)
is_tangible_expr(expr)
```

# Выражения и типы, а также типы как выражения

У каждого выражения есть тип:

```
int x;
static_assert(typeof(x + 1) == int);
```

Поскольку выражение типа также является выражением, то и у него есть тип. Его тип — `type`:

```
static_assert(typeof(int) == type);
static_assert(typeof(void) == type);
static_assert(typeof(^struct{int x}) == type);
static_assert(typeof(qod) == type);
```

Поскольку ключевое слово `type` также само по себе является выражением типа, то и у него есть тип:

```
static_assert(typeof(type) == type);
```

Таким образом типы представляют собой значения времени компиляции. Типы можно сравнивать на равенство: `void == void`, `void != int`.

Значения типов можно присваивать именам:

```
type X1 = int;
type X2 = ^int;
type X3 = void;
```

Однако значение типа не может быть присвоено переменой времени выполнения:

```
auto x = int; /* Ошибка */
```

Значение типа не материализуемо в компилируемую форму. Не существует каких-либо бит, которые можно было бы поместить в исполняемый файл в качестве «типа». Тип это абстракция, которой компилятор оперирует исключительно при сборке программы. Или выражаясь операциями языка, тип не проходит проверку `is_tangible_expr()`.

