
/*
	Compile-Time Evaluations
*/

/* TODO: Вычислять в отдельном проходе по дереву. */

/*****************************************************************************/

void CTE(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	if ID == iDIV | ID == iMOD then
		if NodeHasImmediateValue(pRight) != 0 then
			if NodeGetImmediateValue(pRight) == 0 then
				Stop(@eDIVZERO);
			end
		end
	end

	when Node[pLeft].ID != Node[pRight].ID:
		return;

	select
	case ID == iADD:
		if Node[pLeft].ID == iWORD then
			Node[P].ID    = iWORD;
			Node[P].Value = Node[pLeft].Value + Node[pRight].Value;
		end
		if Node[pLeft].ID == iINT then
			Node[P].ID    = iINT;
			int v1 = Node[pLeft].Value;
			int v2 = Node[pRight].Value;
			Node[P].Value = v1 + v2;
		end
	case ID == iSUB:
		if Node[pLeft].ID == iWORD then
			Node[P].ID    = iWORD;
			Node[P].Value = Node[pLeft].Value - Node[pRight].Value;
		end
		if Node[pLeft].ID == iINT then
			Node[P].ID    = iINT;
			int v1 = Node[pLeft].Value;
			int v2 = Node[pRight].Value;
			Node[P].Value = v1 - v2;
		end
	case ID == iMUL:
		if Node[pLeft].ID == iWORD then
			Node[P].ID    = iWORD;
			Node[P].Value = Node[pLeft].Value * Node[pRight].Value;
		end
		if Node[pLeft].ID == iINT then
			Node[P].ID    = iINT;
			int v1 = Node[pLeft].Value;
			int v2 = Node[pRight].Value;
			Node[P].Value = v1 * v2;
		end
	case ID == iDIV:
		if Node[pLeft].ID == iWORD then
			Node[P].ID    = iWORD;
			Node[P].Value = Node[pLeft].Value / Node[pRight].Value;
		end
		if Node[pLeft].ID == iINT then
			Node[P].ID    = iINT;
			int v1 = Node[pLeft].Value;
			int v2 = Node[pRight].Value;
			Node[P].Value = v1 / v2;
		end
	case ID == iMOD:
		if Node[pLeft].ID == iWORD then
			Node[P].ID    = iWORD;
			Node[P].Value = Node[pLeft].Value % Node[pRight].Value;
		end
	end:select

end

/*****************************************************************************/
