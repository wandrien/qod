
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */

bool CodeRequiresSingleRegister(word P);

word Reg_TARGET;
word Reg_ALT_TARGET;
word RegAllocation[5];

void RegAllocate(word Reg)
	when RegAllocation[Reg] != 0:
		StopInternalCodegen(__FILE__, __LINE__);
	inc RegAllocation[Reg];
end

void RegFree(word Reg)
	when RegAllocation[Reg] != 1:
		StopInternalCodegen(__FILE__, __LINE__);
	dec RegAllocation[Reg];
end

/*****************************************************************************/

word ChooseEmptyReg_IgnoreConsts()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0:
		return RegA;
	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0:
		return RegD;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0:
		return RegC;
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0:
		return RegB;
	return RegNone;
end

word ChooseEmptyReg()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;
	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;
	return ChooseEmptyReg_IgnoreConsts();
end

word ChooseEmptyReg2_IgnoreConsts()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0:
		return RegA;
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0:
		return RegB;
	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0:
		return RegD;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0:
		return RegC;
	return RegNone;
end

word ChooseEmptyReg2()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;
	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;
	return ChooseEmptyReg2_IgnoreConsts();
end

word ChooseEmptyReg3()
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;
	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0:
		return RegB;
	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0:
		return RegC;
	return RegNone;
end

word ChooseOptimalRegForNode(word P; word RegDefault)
	select
	case NodeCanBeEncodedAsImm(P):
		word Value = Node[P].Value;
		if Value == 0 then
			return ChooseEmptyReg2();
		else
			return RegDefault;
		end:if
	case CodeRequiresSingleRegister(P):
		word Reg = ChooseEmptyReg2();
		if Reg != RegNone then
			return Reg;
		else
			return RegDefault;
		end:if
	default:
		return RegDefault;
	end:select
end

/*****************************************************************************/

word LookupRegForNode(word P)
	word Reg = PHO_LookupRegForNode(P);
	if Reg != RegNone then
		return Reg;
	end:if

	when !NodeCanBeEncodedAsImm(P):
		return RegNone;

	word Size = T_SizeOf(Node[P].pType);
	when (Size != 4) & (Size != 2) & (Size != 1):
		return RegNone;
	/* FIXME: проверять только часть регистра при необходимости */
	return PHO_FindRegWithConst(Node[P].Value);
end

/*****************************************************************************/

word Code(word P);
word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M);

/*****************************************************************************/

struct CODEBLOCK of
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		word pType = Code(P);
		when pType == st_noreturn:
			return st_noreturn;
		P = Node[P].pRight;
	end
	return st_void;
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	word pType = Code_List(P);
	Code_EndBlock(@CB);
	return pType;
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.qdi";

/*****************************************************************************/

void Emit_SaveReg(word Reg; char @Comment)
	char Buff[nBUFF];
	Buff[0] = #0;
	EmitWithExprComment(@CodePushReg(@Buff, Reg, 4), @Comment);
end

void Emit_RestoreReg(word Reg; char @Comment)
	char Buff[nBUFF];
	Buff[0] = #0;
	EmitWithExprComment(@CodePopReg(@Buff, Reg, 4), @Comment);
end

/*****************************************************************************/

void Code_ADDR(word P1; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if !T_IsPtr(Ref.pType) then
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:if

	word pTypeDeref = T_DerefPtr(Ref.pType);
	word Size = T_SizeOf(pTypeDeref);

	word pIndex = P1;

	if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
		pIndex = nNODE;
	end:if

	if pIndex < nNODE then
		select
		case Ref.IX == RegNone:
			pass;
		case Ref.IX == Reg_ALT_TARGET:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		case Reg_ALT_TARGET != RegNone:
			if Reg_TARGET != Reg_ALT_TARGET then
				Emit_SaveReg(Reg_ALT_TARGET, "saved in Code_ADDR");
			end:if
			Buff[0] = #0;
			Emit(@CodeXchgRegReg(@Buff, Ref.IX, Reg_ALT_TARGET, 4));
			Reg_TARGET = Ref.IX;
			Ref.IX = Reg_ALT_TARGET;
		default:
			Reg_ALT_TARGET = Ref.IX;
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		Code(pIndex);
		Emit_IMUL_Reg_Const(Reg_TARGET, 4, Size);

		if Reg_TARGET == Reg_ALT_TARGET then
			if Ref.IX != RegNone then
				Ref.IX = RegB;
				Emit_RestoreReg(Ref.IX, "restored in Code_ADDR");
			end:if
		end:if
	end:if

	char @TX = @CodeReg(NULL, Reg_TARGET, 4);

	switch Ref.ID of
	case iDATA, iPARM, iLOCAL, iREF:
		if pIndex < nNODE then
			strcpy3(@Buff,"add     ",@TX,",  ");
		else
			strcpy3(@Buff,"mov     ",@TX,",  ");
		end:if
		Emit(@ValueRef_Code(@Buff, @Ref));
	case iREG:
		if Ref.IX != RegNone then
			if Reg_TARGET != Ref.IX then
				char @RX = @CodeReg(NULL, Ref.IX, 4);
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  dword ");
					strcat7(@Buff,"[",@TX,"+",@RX,"+",@istr(Ref.Offset),"]");
					EmitPhoInvalidate(@Buff);
				else
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@RX));
				end:if
			end:if
		else
			//Reg_TARGET = Ref.IX;
			pass;
		end:if
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:switch

	if Reg_TARGET == Reg_ALT_TARGET | Reg_ALT_TARGET == RegNone then
		Ref.IX = Reg_TARGET;
	else
		word Reg_TARGET_tmp = Reg_TARGET;
		if Ref.IX != RegNone then
			when (Reg_ALT_TARGET == RegNone):
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = Reg_ALT_TARGET;
		end:if

		Ref.IX = Reg_TARGET_tmp;
	end:if

	Ref.pType = pTypeDeref;
	Ref.ID = iREF;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_INDEX(word P1; ValueRef @Ref)
	Ref.pType = T_ArrayDeref(Ref.pType);
	word Size = T_SizeOf(Ref.pType);
	select
	case NodeIsLiteralWord(P1):
		word IndexingOffset = Size * Node[P1].Value;
		Ref.Offset = Ref.Offset + int(IndexingOffset);
	case Ref.IX == RegNone:
		Code(P1);
		Ref.IX = Reg_TARGET;
		Emit_IMUL_Reg_Const(Ref.IX, 4, Size);
		when Reg_ALT_TARGET == RegNone:
			Reg_ALT_TARGET = Ref.IX;
	default:
		when Reg_ALT_TARGET != RegNone & Reg_ALT_TARGET != Ref.IX:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		Reg_TARGET = ChooseEmptyReg();
		when Reg_TARGET == Reg_ALT_TARGET | Reg_TARGET == RegNone:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		Code(P1);
		Emit_IMUL_Reg_Const(Reg_TARGET, 4, Size);
		if Reg_TARGET == Reg_ALT_TARGET then
			when Reg_TARGET != Ref.IX:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = ChooseEmptyReg();
			Emit_RestoreReg(Reg_TARGET, "restored in Code_INDEX");
		end:if
		Emit_CmdRegReg("add", Ref.IX, 4, Reg_TARGET, 4);
		Reg_TARGET = Ref.IX;
	end:select
end

/*****************************************************************************/

void Code_LPTR(word P1; ValueRef @Ref)
	char Buff [nBUFF];
	Buff[0] = #0;

	char @TX = @CodeReg(NULL, Reg_TARGET, 4);

	if Ref.IX != RegNone then
		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"add     ",@TX,",  ");
			Emit(@ValueRef_Code_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			EmitPhoInvalidate(@ValueRef_Code_ForLEA(@Buff, @Ref));
		case iREF:
			if Reg_TARGET != Ref.IX then
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  ");
					EmitPhoInvalidate(@ValueRef_Code_ForLEA(@Buff, @Ref));
				else
					Emit(@CodeCmdRegReg(@Buff, "mov", Reg_TARGET, 4, Ref.IX, 4));
				end
			else
				when Ref.Offset != 0:
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@istr(Ref.Offset)));
			end
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	else
		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"mov     ",@TX,",  ");
			Emit(@ValueRef_Code_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			EmitPhoInvalidate(@ValueRef_Code_ForLEA(@Buff, @Ref));
		case iREF:
			pass;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	end:if

	Ref.pType = T_PtrTo(Ref.pType);
	Ref.ID = iREG;
	Ref.IX = Reg_TARGET;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_CALL(word pPrimary; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if Reg_ALT_TARGET == RegA & Reg_TARGET != RegA then
		Emit_SaveReg(RegA, "saved in Code_CALL");
	end:if
	Reg_TARGET = RegA;

	switch Node[pPrimary].ID of
	case iCALL:
		when Node[pPrimary].pLeft != nNODE:
			Code(Node[pPrimary].pLeft);
		word pFunc = NodeGetDict(pPrimary);
		if Dict[pFunc].Sub==sSYS then
			EmitWithPhoMode(
				@strcpy3(@Buff,"call   [@",@str(Dict[pFunc].Label),"]"),
				PHO_Mode_Invalidate
			);
		else
			EmitWithPhoModeAndComment(
				@strcpy2(@Buff,"call    @",@str(Dict[pFunc].Label)),
				PHO_Mode_Invalidate,
				@DictGetName(pFunc)
			);
		end:if
	case iCALL2:
		when Node[pPrimary].pLeft != nNODE:
			Code(Node[pPrimary].pLeft);
		Code(Node[pPrimary].pRight);
		EmitWithPhoMode("call    EAX", PHO_Mode_Invalidate);
	default:
		StopInternal(__FILE__, __LINE__);
	end:switch

	Reg_TARGET = RegA;
	Ref.pType = Node[pPrimary].pType;
	Ref.ID = iREG;
	Ref.IX = RegA;
	Ref.Offset = 0;
end

/*****************************************************************************/

word CodePrimary(word pPrimary; ValueRef @Ref)

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iCALL, iCALL2:
		Code_CALL(pPrimary, @Ref);

	case iINDEX:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_INDEX(Node[pPrimary].pRight, @Ref);

	case iLPTR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_LPTR(Node[pPrimary].pRight, @Ref);

	case iADDR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_ADDR(Node[pPrimary].pRight, @Ref);

	case iFIELD:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	default:
		word pType = Code(pPrimary);
		Ref.ID = iREG;
		Ref.RO = 0;
		Ref.pType = pType;
		Ref.Offset = 0;
		Ref.IX = Reg_TARGET;
	end

	return Ref.pType;
end

/*****************************************************************************/

word Code_LOAD(word pPrimary; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if Ref.ID==iREG then
		//when Ref.IX != Reg_TARGET:
		//	StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		return Ref.pType;
	end:if

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy3(@Buff, "mov     ", @CodeReg(NULL, Reg_TARGET, Size), ",  ");
		ValueRef_Code(@Buff, @Ref);
	default:
		strcpy3(@Buff, "lea     ", @CodeReg(NULL, Reg_TARGET, 4), ",  ");
		ValueRef_Code_ForLEA(@Buff, @Ref);
	end:select

	Emit(@Buff);

	PHO_LinkNode(Reg_TARGET, pPrimary);
	return Ref.pType;
end

/*****************************************************************************/

void Code_STORE(ValueRef @Ref; word pLinkStore, pLinkLoad)
	char Buff[nBUFF];
	Buff[0] = #0;

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy(@Buff,"mov     ");
		ValueRef_Code(@Buff, @Ref);

		/*when Ref.IX != Reg_TARGET & Ref.IX != RegNone:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);*/

		select
		case Reg_TARGET != Reg_ALT_TARGET:
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, Reg_ALT_TARGET, Size)));
			PHO_LinkNode(Reg_ALT_TARGET, pLinkLoad);
			PHO_LinkNode_Store(Reg_ALT_TARGET, pLinkStore);
		case Ref.IX==RegA:
			Emit_RestoreReg(RegB, "restored in Code_STORE");
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegB, Size)));
			PHO_LinkNode(RegB, pLinkLoad);
			PHO_LinkNode_Store(RegB, pLinkStore);
		case Ref.IX==RegB:
			Emit_RestoreReg(RegA, "restored in Code_STORE");
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegA, Size)));
			PHO_LinkNode(RegA, pLinkLoad);
			PHO_LinkNode_Store(RegA, pLinkStore);
		end:select
	default:
		strcpy(@Buff,"lea     EDI,  ");
		ValueRef_Code_ForLEA(@Buff, @Ref);
		Emit(@Buff);

		if Reg_TARGET != Reg_ALT_TARGET then
			Emit(@strcpy2(@Buff,"mov     ESI,  ",@CodeReg(NULL, Reg_ALT_TARGET, 4)));
		else
			EmitWithExprComment("pop     ESI", "restored in Code_STORE");
		end:if

		Emit("cld");
		Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
		Emit("rep     movsb");
		PHO_RegConnectConst(RegC, 0);
	end:select
end

/*****************************************************************************/

word Code_CAST(char @Buff; word P; word pTypeTo; word pTypeFrom; word Reg; word @Complexity)
	Complexity = 0;

	select
	case pTypeFrom == nDICT:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeFrom == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case T_Equal(pTypeTo, pTypeFrom):
		pass;
	case (T_IsInteger(pTypeTo) | pTypeTo == st_char)&
	     (T_IsInteger(pTypeFrom) | pTypeFrom == st_char):
		word SizeTo = T_SizeOf(pTypeTo);
		word SizeFrom = T_SizeOf(pTypeFrom);
		/*
			unsigned(16) into unsigned(32)  zero-extension
			unsigned(16) into signed(32)    zero-extension
			signed(16) into signed(32)      sign-extension
			signed(16) into unsigned(32)    sign-extension
		*/
		if SizeTo > SizeFrom then
			if T_IsSigned(pTypeFrom) then
				Complexity = 1;
				if @Buff != NULL then
					Emit(@CodeCmdRegReg(@Buff, "movsx", Reg, SizeTo, Reg, SizeFrom));
				end:if
			else
				Complexity = 1;
				if @Buff != NULL then
					Emit(@CodeCmdRegReg(@Buff, "movzx", Reg, SizeTo, Reg, SizeFrom));
				end:if
			end:if
		end:if
	case T_IsPtr(pTypeTo) & T_IsPtr(pTypeFrom):
		pass;
	case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom):
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end

	return pTypeTo;
end

/*****************************************************************************/

/*
	Для оптимизации генерируемого кода, нам требуется уметь отвечать на два вопроса:
	* Может ли ветка кода быть закодирована как MemRef (и формирование данного MemRef).
	* Может ли ветка кода быть закодирована с использованием только одного регистра.

	Для веток Primary алгоритм ответа на эти вопросы содержит по большей части
	идентичный код и отличается только в деталях.
	Эта вспомогательная функция проводит анализ веток Primary для одного из указанных
	вариантов анализа в зависимости от значения параметра Query.
*/

define Query_MemoryOperand 0
define Query_SingleRegOperand 1

struct OperandQuery of
	word Query;
	ValueRef Ref;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query);
bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q);

bool QueryOperandStatus_CAST(word pPrimary; OperandQuery @_Q)
	word pTypeFrom = Node[Node[pPrimary].pLeft].pType;
	word pTypeTo = Node[pPrimary].pType;
	when !QueryOperandStatus_(Node[pPrimary].pLeft, @_Q):
		return false;
	word Complexity = 0;
	DisableEmit();
	pTypeTo = Code_CAST(NULL, pPrimary, pTypeTo, pTypeFrom, RegA, @Complexity);
	EnableEmit();
	if Complexity == 0 then
		ValueRef @Ref = @_Q.Ref;
		Ref.pType = pTypeTo;
		return true;
	else
		return false;
	end:if
end

bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q)
	ValueRef @Ref = @_Q.Ref;
	word Query = _Q.Query;

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iLPTR:
		if Query == Query_SingleRegOperand then
			return QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		else
			return false;
		end:if

	case iINDEX:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_ArrayDeref(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if NodeIsLiteralWord(pIndex) then
			word IndexingOffset = Size * Node[pIndex].Value;
			Ref.Offset = Ref.Offset + int(IndexingOffset);
		else
			if Query != Query_SingleRegOperand then
				return false;
			end:if

			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
			Ref.IX = RegA;
		end:if

	case iADDR:
		if Query != Query_SingleRegOperand then
			return false;
		end:if

		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_DerefPtr(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
			pIndex = nNODE;
		end:if

		if pIndex < nNODE then
			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
		end:if
		Ref.Offset = 0;
		Ref.IX = RegA;

	case iFIELD:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	case iCAST, iREINTERPRET_CAST:
		return QueryOperandStatus_CAST(pPrimary, @_Q);
	default:
		return false;
	end

	return true;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query)
	when (Query == Query_SingleRegOperand) & (@pTypeFinal != NULL):
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);

	OperandQuery _Q;
	_Q.Query = Query;
	bool Result = QueryOperandStatus_(pPrimary, @_Q);

	if Result then
		switch Query of
		case Query_MemoryOperand:
			ValueRef @Ref = @_Q.Ref;
			word Size = SizeOfType(Ref.pType);
			select
			case IsNativeOperandSize(Size):
				if @Buff !=  NULL then
					Buff[0] = #0;
					ValueRef_Code(@Buff, @Ref);
				end
				when @pTypeFinal != NULL:
					pTypeFinal = Ref.pType;
				return true;
			default:
				return false;
			end:select
		case Query_SingleRegOperand:
			pass;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		end:switch
	end:if

	return Result;
end

/*****************************************************************************/

/*
	Если узел pPrimary может быть закодирован как MemRef,
	выводит в буфер Buff этот MemRef, а в pTypeFinal записывает тип выражения.
	Возввращает true при этом.
	Если узел pPrimary не может быть закодирован как MemRef, возвращает false.
*/

bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal)
	return QueryOperandStatus(@Buff, pPrimary, @pTypeFinal, Query_MemoryOperand);
end

bool NodeCanBeEncodedAsMemoryOperand(word pPrimary)
	return QueryOperandStatus(NULL, pPrimary, NULL, Query_MemoryOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister_(word P)
	when NodeCanBeEncodedAsImm(P):
		return true;

	word ID = Node[P].ID;

	switch ID of
	case iADD, iBIT_OR, iBIT_XOR, iBIT_AND:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		if
			(CodeRequiresSingleRegister_(pRight)) &
			(
				NodeCanBeEncodedAsImm(pLeft) |
				NodeCanBeEncodedAsMemoryOperand(pLeft)
			)
		then
			return true;
		end:if
		return false;
	case iSUB:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		return false;
	case iMUL:
		if T_SizeOf(Node[P].pType) != 4 then
			return false;
		end:if
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			NodeCanBeEncodedAsImm(pRight) &
			CodeRequiresSingleRegister_(pLeft)
		then
			return true;
		end:if
		if
			NodeCanBeEncodedAsImm(pLeft) &
			CodeRequiresSingleRegister_(pRight)
		then
			return true;
		end:if
		return false;
	case iBIT_NOT, iNEG:
		return CodeRequiresSingleRegister_(Node[P].pLeft);
	case iCAST, iREINTERPRET_CAST:
		word pTypeFrom = Node[Node[P].pLeft].pType;
		word pTypeTo = Node[P].pType;
		when !CodeRequiresSingleRegister_(Node[P].pLeft):
			return false;
		word Complexity = 0;
		pTypeTo = Code_CAST(NULL, P, pTypeTo, pTypeFrom, RegA, @Complexity);
		if Complexity < 2 then
			return true;
		else
			return false;
		end:if
	end:switch

	return QueryOperandStatus(NULL, P, NULL, Query_SingleRegOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister(word P)
	bool Result;
	DisableEmit();
	Result = CodeRequiresSingleRegister_(P);
	EnableEmit();
	return Result;
end

/*****************************************************************************/

/** Checks if the operands can be swapped for no cost, but we should change the operation ID as well.
    Returns the ID of swapped operation, if the operation is swappable.
    Returns the same ID, if the operation is commutative.
    Returns zero otherwise.
*/
word CheckOperationSwappable(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return ID;
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end

/*****************************************************************************/

bool DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightRegD(word ID)
	switch ID of
	case
		iDIV,
		iMOD:
		return false;
	default:
		return true;
	end:switch
end

bool DoesOperationAllowRightReg(word ID; word RegRight)
	switch ID of
	case
		iDIV,
		iMOD:
		if RegRight == RegD then
			return false;
		else
			return true;
		end
	default:
		return true;
	end:switch
end


/** A heuristic to determine whether it might be advantageous to change the order in which operands are evaluated.
    Returns NULL, if the operand evaluation should not be reordered.
    Returns a string describing the reason of reordering (for debugging purposes),
    if the operand evaluation should be reordered.
*/
char @CheckOperandReordering(word pLeft; word pRight)
	when !ReorderOperands:
		return NULL;

	when NodeCanBeEncodedAsImm(pRight):
		return NULL;

	when CodeRequiresSingleRegister(pRight):
		return NULL;

	when NodeCanBeEncodedAsImm(pLeft):
		return "Imm on the left";

	when CodeRequiresSingleRegister(pLeft):
		return "Single-register operand on the left";

	return NULL;
end

/*****************************************************************************/

word TryDropCastBeforeCmp(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	when ID < iLT | iGT < ID:
		return nNODE;

	when Node[pRight].Value > 255: /* TODO: this case should be optimized out on the semantic analysis phase */
		return nNODE;

	when Node[pLeft].ID != iCAST & Node[pLeft].ID != iREINTERPRET_CAST:
		return nNODE;

	word pTypeFrom = Node[Node[pLeft].pLeft].pType;
	word pTypeTo = Node[pLeft].pType;

	when pTypeFrom != st_char & pTypeFrom != st_byte:
		return nNODE;

	when pTypeTo != st_word:
		return nNODE;

	return Node[pLeft].pLeft;
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight):
		pass;
	case NodeCanBeEncodedAsImm(pLeft):
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2=Code(pLeft);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	word done = Emit_MUL_Reg_Const(Reg_TARGET, Size, RightValue);
	when done == 0:
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

define operandNotReady 0
define operandReg      1
define operandImm      2
define operandMemRef   3

word CodeBinOp(char @Buff; word P; LABEL @F; LABEL @T; LABEL @M)
	Buff[0] = #0;

	forever do
		word pType = TryCodeFastMult(@Buff,P);
		when pType < nDICT:
			return pType;
		exit;
	end:forever

	word ID = Node[P].ID;

	bool opIsComparison = false;
	bool useSetCC = true;
	word Reg_TARGET_SavedForConditional = RegNone;

	if iLT <= ID & ID <= iGT then
		opIsComparison = true;
		if @F == NULL & @T == NULL & @M == NULL then
			/* The caller doesn't expect us to emit jumps,
			   the result should be in a register instead. */
			useSetCC = true;
			Reg_TARGET_SavedForConditional = Reg_TARGET;
		else
			/* The caller does expect us to emit jumps,
			   the final register value is irrelevant. */
			useSetCC = false;
			/* Since these operations don't return the result in any register,
			   we can reset Reg_TARGET freely. */
			Reg_TARGET=RegA;
		end:if
	end

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if Reg_TARGET != RegA then
			when Reg_ALT_TARGET == RegA:
				Emit_SaveReg(RegA, "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
	end:switch

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	char BuffRightOperand[nBUFF];
	word leftOperand  = operandNotReady;
	word rightOperand = operandNotReady;

	forever do
		when !ReorderOperands:
			exit;

		/*
			The usual calculation scheme is:
				Reg1  <- LeftOperand
				Reg2  <- RightOperand
				OP    Reg1,  Reg2

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) then

			/*
				## Immediate constant on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  ImmValue
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2,  ImmValue
					Op    Reg1,  Reg1
			*/
			if NodeCanBeEncodedAsImm(pRight) then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  ImmValue
				Instead of:
					mov   Reg1,  ImmValue
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				ID = swappedID;
				rightOperand = operandImm;
				exit;
			end:if

		end:if

		if DoesOperationAllowRightMemRef(ID) then

			/*
				## Simple memory reference on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  [MemRef]
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2, [MemRef]
					Op    Reg1, Reg2
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL) then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  [MemRef]
				Instead of:
					mov   Reg1,  [MemRef]
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & NodeCanBeEncodedAsMemoryOperand(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL);
				ID = swappedID;
				rightOperand = operandMemRef;
				exit;
			end:if

		end:if

		exit;
	end:forever

	/*
		TODO: проверять не только Reg_TARGET, но и среди других регистров искать.
	*/
	word rightReg = RegNone;
	word fSwap=0;
	word pType;
	word regReuse = 0;
	select
	case (rightOperand == operandImm) &
	     (T_SizeOf(Node[pRight].pType) == 4) &
	     (PHO_RegContainsConst(Reg_TARGET, Node[pRight].Value)):
		 regReuse = 1;
	case PHO_CheckRegForNode(Reg_TARGET, pRight):
		 regReuse = 2;
	end:select

	if regReuse != 0 then
		word swappedID = CheckOperationSwappable(ID);
		if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			ID = swappedID;
			leftOperand = operandReg;
			rightOperand = operandMemRef;
			pType = Node[pLeft].pType;
			if regReuse == 1 then
				EmitWithExprComment("", "Const reuse in CodeBinOp");
			else
				EmitWithExprComment("", "Node link reuse in CodeBinOp");
			end
		end:if
	end:if

	switch rightOperand of
	case operandImm:
		word pLeft2 = TryDropCastBeforeCmp(P);
		when pLeft2 < nNODE:
			pLeft = pLeft2;

		if opIsComparison & ! useSetCC then
			when CodeRequiresSingleRegister(pLeft):
				Reg_TARGET = ChooseEmptyReg();
		end:if

		pType=Code(pLeft);

	case operandMemRef:
		if leftOperand == operandNotReady then
			if PHO_CheckRegForNode(Reg_TARGET, pLeft) then
				pType = Node[pLeft].pType;
			else
				if iLT <= ID & ID <= iGT then
					when CodeRequiresSingleRegister(pLeft):
						Reg_TARGET = ChooseEmptyReg();
				end:if

				pType=Code(pLeft);
			end:if
		end:if

		word RegLinked = LookupRegForNode(pRight);
		if RegLinked != RegNone & DoesOperationAllowRightReg(ID, RegLinked)then
			EmitWithExprComment("", "Node link reuse in CodeBinOp");
			rightOperand = operandReg;
			rightReg = RegLinked;
		end:if

	case operandReg:
		when leftOperand != operandReg:
			StopInternalCodegen(__FILE__, __LINE__);

	case operandNotReady:
		char @reorderingReason = @CheckOperandReordering(pLeft, pRight);
		if @reorderingReason != NULL then
			EmitWithExprComment("", "Reordering in CodeBinOp");
			EmitWithExprComment("", @reorderingReason);
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			inc fSwap;
		end:if

		rightOperand = operandReg;
		rightReg = RegB;
		if CodeRequiresSingleRegister(pRight) then
			if DoesOperationAllowRightRegD(ID) & !PHO_RegContainsAConst(RegD) then
				rightReg = RegD;
			else
				rightReg = RegC;
			end:if
		end:if

		/*
			Если мы оказались здесь, значит нам нужны 2 регистра,
			и значение одного из них потребуется не потерять при вычислении
			правого операнда.

			Назначаем Reg_ALT_TARGET, если вызывающий код этого не сделал,
			сохраняем регистр, если вызывающий код уже использует Reg_ALT_TARGET.
		*/
		word Saved_Reg_ALT_TARGET = Reg_ALT_TARGET;
		if Reg_TARGET != RegA then
			when Reg_ALT_TARGET == RegA:
				Emit_SaveReg(RegA, "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
		when Reg_ALT_TARGET != RegA:
			Reg_ALT_TARGET = RegA;

		pType = Code(pLeft);
		if Reg_TARGET != Reg_ALT_TARGET then
			/* Операнд был возвращён в другом регистре. */
			Emit_MOV_or_XCHG(Reg_ALT_TARGET, Reg_TARGET, 4);
		end

		when Reg_ALT_TARGET != RegA:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);

		Reg_TARGET = rightReg;
		Code(pRight);

		if Reg_TARGET == Reg_ALT_TARGET then
			Emit_RestoreReg(rightReg, "restored in CodeBinOp");
			Buff[0] = #0;
			inc fSwap;
		end
		Reg_TARGET = Reg_ALT_TARGET;

		Reg_ALT_TARGET = Saved_Reg_ALT_TARGET;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		forever do
			/* We can handle it by changing the operation ID */
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 then
				ID = swappedID;
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit(@CodeCmdRegReg(@Buff, "xchg", Reg_TARGET, 4, rightReg, 4));
				Buff[0] = #0;
				exit;
			end:switch

			/* In other cases, swapped operands shouldn't happen. */
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:forever
	end:if

	word Size=SizeOfType(pType);

	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = as_unsigned(-Value);

		switch Value of
		case 1:
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-1):
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case 2:
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-2):
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		end:switch
	end:if

	word _MeaningfulFlags = 0;

	select
	case opIsComparison:

		if !useSetCC then
			/* Reorder for easier handling. */
			if @T == NULL then
				switch ID of
				case iLT: ID=iGE;
				case iLE: ID=iGT;
				case iEQ: ID=iNE;
				case iNE: ID=iEQ;
				case iGE: ID=iLT;
				case iGT: ID=iLE;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				end:switch

				@T = @F;
				@F = NULL;
			end:if

			if @T == NULL | @F != NULL then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
		end:if

		select
		case rightOperand == operandImm:
			word Value = Node[pRight].Value;
			word PHO_Load_Value = Value;
			bool SkipCmp = false;
			switch Value of
			case 0:
				select
				case (ID == iEQ) | (ID == iNE):
					if (MeaningfulFlags & Flag_Zero) != 0 then
						pass; /* ! */
						SkipCmp = true;
					else
						Emit_TEST_Reg_Self(Reg_TARGET, Size);
						SkipCmp = true;
						if fSwap==0 then
							PHO_LinkNode(Reg_TARGET, pLeft);
						end:if
					end:if
				case (MeaningfulFlags & (Flag_Zero | Flag_Sign)) == (Flag_Zero | Flag_Sign):
					select
					case (ID == iGE) & T_IsSigned(pType):
						ID = iBRANCH_NSF;
						SkipCmp = true;
					case (ID == iLT) & T_IsSigned(pType):
						ID = iBRANCH_SF;
						SkipCmp = true;
					end:select
				end:select
			case 1:
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
					dec PHO_Load_Value;
					SkipCmp = true;
				end:if
			case word(-1):
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
					inc PHO_Load_Value;
					SkipCmp = true;
				end:if
			end:switch
			if !SkipCmp then
				BuffRightOperand[0] = #0;
				if PHO_EncodeRegContainingConst(@BuffRightOperand, Value, Size) != 0 then
					EmitPhoSkip(
						@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand)
					);
				else
					EmitPhoSkip(
						@CodeCmdRegConst(@Buff, "cmp", Reg_TARGET, Size, Value)
					);
				end:if
				if fSwap==0 then
					PHO_LinkNode(Reg_TARGET, pLeft);
				end:if
			end:if
			when (Size == 4) & (ID == iNE):
				PHO_RegConnectConst(Reg_TARGET, PHO_Load_Value);
		case rightOperand == operandMemRef:
			EmitPhoSkip(
				@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand)
			);
			if fSwap==0 then
				PHO_LinkNode(Reg_TARGET, pLeft);
			end:if
		case rightOperand == operandReg:
			EmitPhoSkip(
				@CodeCmdRegReg(@Buff, "cmp", Reg_TARGET, Size, rightReg, Size)
			);
			if fSwap==0 then
				PHO_LinkNode(Reg_TARGET, pLeft);
				PHO_LinkNode(rightReg, pRight);
			end:if
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end

		char@ BranchCondition = "";
		select
		case T_IsSigned(pType):
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			case iBRANCH_SF: @BranchCondition = "s ";
			case iBRANCH_NSF: @BranchCondition = "ns";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
		end:select

		if useSetCC then
			Reg_TARGET = Reg_TARGET_SavedForConditional;
			word pResultType = Node[P].pType;
			word ResultSize = T_SizeOf(pResultType);
			char Cmd[8];
			strcpy2(@Cmd,"set",@BranchCondition);
			Buff[0] = #0;
			Emit(@CodeCmdReg(@Buff, @Cmd, Reg_TARGET, 1));
			select
			case ResultSize == 1:
				pass;
			case ResultSize <= 4:
				Buff[0] = #0;
				Emit(@CodeCmdRegReg(@Buff, "movzx", Reg_TARGET, 4, Reg_TARGET, 1));
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
			return pResultType;
		else
			EmitBranchToLabel(@BranchCondition, @T);
			return st_cond_branch;
		end:if

	case ID==iBIT_OR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"and     ");

	case ID==iADD:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pType):
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pType):
			strcpy(@Buff,"mul     ");
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		when Reg_TARGET != RegA:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);

		switch rightOperand of
		case operandImm:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		case operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:switch

		Emit(@Buff);
		return pType;

	case ID==iDIV | ID==iMOD:
		when Reg_TARGET != RegA:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);

		select
		case Size==1:
			if T_IsSigned(pType) then
				Emit("movsx   AX,   AL");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     AH,   AH");
				strcpy(@Buff,"div     ");
			end:if
		case Size==2:
			if rightOperand == operandReg & rightReg == RegD then
				word newRightReg = ChooseEmptyReg3();
				when newRightReg == RegNone:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				Emit_MOV_or_XCHG(newRightReg, rightReg, Size);
				rightReg = newRightReg;
			end:if

			if T_IsSigned(pType) then
				Emit("cwq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     DX,   DX");
				strcpy(@Buff,"div     ");
			end:if
		case Size==4:
			if rightOperand == operandReg & rightReg == RegD then
				word newRightReg = ChooseEmptyReg3();
				when newRightReg == RegNone:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				Emit_MOV_or_XCHG(newRightReg, rightReg, Size);
				rightReg = newRightReg;
			end:if

			if T_IsSigned(pType) then
				Emit("cdq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     EDX,  EDX");
				strcpy(@Buff,"div     ");
			end:if
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		select
		case rightOperand == operandImm:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		Emit(@Buff);

		if ID==iMOD then
			select
			case Size==1:
				Emit("mov     AL,   AH");
			case Size==2:
				if Reg_ALT_TARGET == RegNone then
					Reg_TARGET = RegD;
				else
					Emit_MOV_or_XCHG(RegA, RegD, Size);
				end:if
			case Size==4:
				if Reg_ALT_TARGET == RegNone then
					Reg_TARGET = RegD;
				else
					Emit_MOV_or_XCHG(RegA, RegD, Size);
				end:if
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:select
		end:if

		return pType;

	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:select

	select
	case IsNativeOperandSize(Size):
		select
		case rightOperand == operandImm:
			/*
				XXX: The commented out code is mostly useless in the current implementation
				I can't find any expression when that condition actually triggers.
				May be useful when a full-featured register allocation strategy will be implemented.
			*/
			/*if PHO_EncodeRegContainingConst(@BuffRightOperand, Node[pRight].Value, Size) != 0 then
				CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
			else*/
				CodeRegConst(@Buff, Reg_TARGET, Size, Node[pRight].Value);
			/*end:if*/
		case rightOperand == operandMemRef:
			CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
		case rightOperand == operandReg:
			CodeRegReg(@Buff, Reg_TARGET, Size, rightReg, Size);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select
		Emit(@Buff);
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:select

	MeaningfulFlags = _MeaningfulFlags;
	return pType;
end

/*****************************************************************************/

/*
	Генерация кода для условных переходов из булевых выражений.

	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M)
	char Buff[nBUFF];
	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when @T != NULL & @F != NULL: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	when Node[P].pType != st_bool:
		StopInternalCodegen(__FILE__, __LINE__);

	/* These operations don't return the result in any register,
	instead a conditional jump is the result. So we reset Reg_TARGET here. */
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;

	switch Node[P].ID of
	case iLITERAL:
		select
		case Node[P].Value == 0 & @F != NULL:
			EmitJumpToLabel(@F);
		case Node[P].Value != 0 & @T != NULL:
			EmitJumpToLabel(@T);
		end:select
		return st_cond_branch;

	case iLT, iLE, iEQ, iNE, iGE, iGT:
		return CodeBinOp(@Buff, P, @F, @T, @M);

	case iNOT:
		return CodeBooleanExpr(Node[P].pLeft, @T, @F, @M);
	case iOR:
		return Code_OR(P, @F, @T, @M, @Buff);
	case iXOR:
		Code_XOR(P, @F, @T, @M, @Buff);
		//return st_cond_branch;
	case iEQV:
		Code_EQV(P, @F, @T, @M, @Buff);
		//return st_cond_branch;
	case iAND:
		return Code_AND(P, @F, @T, @M, @Buff);

	default:
		when CodeRequiresSingleRegister(P):
			Reg_TARGET = ChooseEmptyReg();
		Code(P);
		word Size = T_SizeOf(Node[P].pType);
		Emit_TEST_Reg_Self(Reg_TARGET, Size);
		select
		case @F != NULL:
			EmitBranchToLabel("z", @F);
		case @T != NULL:
			EmitBranchToLabel("nz", @T);
			when Size == 4:
				PHO_RegConnectConst(Reg_TARGET, 0);
		end:select
		return st_cond_branch;

	end:switch
end

/*****************************************************************************/

word CodeBooleanExprNoJumpTargets(word P)
/*
		CodeBooleanExpr(P, NULL, L_TRUE, L_FALSE);
	L_FALSE:
		mov Reg, 0
		jmp L_END
	L_TRUE:
		mov Reg, 1
	L_END:
*/

	word pType = Node[P].pType;
	word Size = T_SizeOf(pType);

	LABEL @L_FALSE = @LabelResolve(P, lFALSE);
	LABEL @L_TRUE = @LabelResolve(P, lTRUE);
	LABEL @L_END = @LabelResolve(P, lEND);

	word Saved_Reg_TARGET = Reg_TARGET;
	when CodeBooleanExpr(P, NULL, @L_TRUE, @L_FALSE) != st_cond_branch:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	Reg_TARGET = Saved_Reg_TARGET;

	EmitLabelIfUsed(@L_FALSE);
	Emit_Load_Constant(Reg_TARGET, Size, 0);

	if LabelIsUsed(@L_TRUE) then
		EmitJumpToLabel(@L_END);
		EmitLabel(@L_TRUE);
		Emit_Load_Constant(Reg_TARGET, Size, 1);
		EmitLabel(@L_END);
	end

	return Node[P].pType;
end

/*****************************************************************************/

word Code_INCDEC(word pPrimary)
	char Buff[nBUFF];
	Buff[0] = #0;

	ValueRef Ref;
	CodePrimary(Node[pPrimary].pLeft, @Ref);

	if Node[pPrimary].ID==iINC then
		strcpy(@Buff,"inc     ");
	else
		strcpy(@Buff,"dec     ");
	end:if

	word Size = T_SizeOf(Ref.pType);
	select
	case IsNativeOperandSize(Size):
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
	end:select

	Emit(@ValueRef_Code(@Buff, @Ref));

	return st_void;
end

/*****************************************************************************/

word Code_ASSIGN(word P)
	word P1 = Node[P].pLeft;
	if Node[P1].pRight < nNODE then
		word RegRight = LookupRegForNode(Node[P1].pRight);
		select
		case RegRight != RegNone & CodeRequiresSingleRegister(Node[P1].pLeft):
			EmitWithExprComment("", "Node link reuse in Code_ASSIGN (1)");
			Reg_ALT_TARGET = RegNone;
			Reg_TARGET = RegRight;

			Reg_ALT_TARGET = Reg_TARGET;
			Reg_TARGET = ChooseEmptyReg2();
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		case !CodeRequiresSingleRegister(Node[P1].pLeft)
		& CodeRequiresSingleRegister(Node[P1].pRight):
			Reg_TARGET = RegA;
			Reg_ALT_TARGET = RegNone;
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);

			Reg_ALT_TARGET = Ref.IX;
			Reg_TARGET = ChooseEmptyReg2();
			Code(Node[P1].pRight);

			Reg_ALT_TARGET = Reg_TARGET;
			Reg_TARGET = RegNone;
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		default:
			Reg_ALT_TARGET = PHO_LookupRegForNode(Node[P1].pRight);
			if Reg_ALT_TARGET == RegNone then
				if CodeRequiresSingleRegister(Node[P1].pLeft) then
					Reg_TARGET = ChooseOptimalRegForNode(Node[P1].pRight, RegA);
				else
					Reg_TARGET = RegA;
				end:if
				Code(Node[P1].pRight);
				Reg_ALT_TARGET = Reg_TARGET;
			else
				EmitWithExprComment("", "Node link reuse in Code_ASSIGN (2)");
			end

			Reg_TARGET = ChooseEmptyReg2();
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		end
	else
		Reg_TARGET = RegA;
		Reg_ALT_TARGET = RegNone;
		Code(Node[P1].pLeft);
	end

	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;
	return Node[P].pType;
end

/*****************************************************************************/

word CodePrimaryWrapped(word P)
	if PHO_CheckRegForNode(Reg_TARGET, P) then
		EmitWithExprComment("", "Node link reuse in CodePrimaryWrapped");
		return Node[P].pType;
	end:if

	ValueRef Ref;
	CodePrimary(P, @Ref);
	Code_LOAD(P, @Ref);
	return Ref.pType;
end

/*****************************************************************************/

word Code(word P)
	char Buff[nBUFF];
	Buff[0] = #0;

	when P == nNODE:
		return st_void;
		//StopInternalCodegen(__FILE__, __LINE__);

	when P > nNode:
		StopInternalCodegen(__FILE__, __LINE__);

	EmitWithSourceNote(NULL, P);

	switch Node[P].ID of
	case iNULL:
		Emit_Load_Constant(Reg_TARGET, 4, 0);
		return Node[P].pType;

	case iLITERAL:
		Emit_Load_Constant(Reg_TARGET, T_SizeOf(Node[P].pType), Node[P].Value);
		return Node[P].pType;

	case iFUNC:
		CodeLoadLabel(@Buff, Reg_TARGET, Node[P].Value);
		Emit(@Buff);
		return Node[P].pType;

	case iINC, iDEC:
		return Code_INCDEC(P);

	case iDATA, iPARM, iLOCAL, iSTRING,
	     iCALL, iCALL2, iINDEX, iLPTR, iADDR, iFIELD:
		return CodePrimaryWrapped(P);

	case iCAST, iREINTERPRET_CAST:
		word pTypeFrom = Code(Node[P].pLeft);
		word pTypeTo = Node[P].pType;
		word Complexity = 0;
		return Code_CAST(@Buff, P, pTypeTo, pTypeFrom, Reg_TARGET, @Complexity);

	case iBIT_NOT:
		word pType = Code(Node[P].pLeft);
		word  Size = SizeOfType(pType);
		Emit(@CodeCmdReg(@Buff, "not", Reg_TARGET, Size));

		return pType;

	case iNEG:
		if NodeIsLiteralWord(Node[P].pLeft) then
			Emit_Load_Constant(Reg_TARGET, 4, as_unsigned(-Node[Node[P].pLeft].Value));
			return Node[P].pType;
		end

		Code(Node[P].pLeft);

		Emit(@CodeCmdReg(@Buff, "neg", Reg_TARGET, T_SizeOf(Node[P].pType)));

		return Node[P].pType;

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
		return CodeBinOp(@Buff, P, NULL, NULL, NULL);

	case iOR, iAND, iNOT:
		return CodeBooleanExprNoJumpTargets(P);

	case iDEF_LOCAL:
		if nLocal>=nLOCAL then
			StopMemory();
		end

		word pType = Node[P].pType;
		word Size  = SizeOfType(pType);

		AllocatedFrameSize = AllocatedFrameSize + DefaultInStackAlign(Size);

		word i = nLocal;
		inc nLocal;
		Local[i].pType=pType;
		Local[i].Value=AllocatedFrameSize;
		when EmitDebugComments_LocalDefs:
			EmitComment(@strcpy4(@Buff, "iDEF_LOCAL: ",@Char[Node[P].Value]," ",@str(Local[i].Value)));

		Code(Node[P].pLeft);

	case iASSIGN:
		return Code_ASSIGN(P);

	case iINLINE:
		Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16, #0)));

	case iPUSH:
		Code_PUSH(P, @Buff);
	case iRETURN:
		return Code_RETURN(P, @Buff);
	case iSELECT:
		return Code_SELECT(P, @Buff);
	case iSWITCH:
		return Code_SWITCH(P, @Buff);
	case iWHILE:
		return Code_WHILE(P, @Buff);
	case iREPEAT:
		return Code_REPEAT(P, @Buff);
	case iCONTINUE:
		return Code_CONTINUE(P, @Buff);
	case iEXIT:
		return Code_EXIT(P, @Buff);
	case iEMPTY, iVIRTUAL_JUMP:
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:switch

	return nDICT;
end

/*****************************************************************************/

word pReturnVoid = nNODE;

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	if Dict[I].Sub != sMAIN then
		strcat(@Buff, @DictGetName(I));
	else
		strcat(@Buff, "<begin>");
	end:if
	strcat(@Buff," ##");
	LABEL L; L.Value = Dict[I].Label;
	EmitLabelWithComment(@L, @Buff);

	word S1 = 0;

	word pARGS = Func_GetArgs(I);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = S1 + 8;
		S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while

	PHO_InvalidateRegs();

	if EmitEnterInstruction & Dict[I].StackSize > 0 then
		Emit(@strcpy3(@Buff,"enter   ",@str(Dict[I].StackSize), ", 0"));
	else
		Emit("push    EBP");
		Emit("mov     EBP,  ESP");

		if Dict[I].StackSize > 0 then
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(Dict[I].StackSize)));
		end:if
	end:if

	if Dict[I].Sub == sMAIN then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == false then
					Code(Dict[J].pNode);
				end:if
			end:if

			inc J;
		end:while
	end:if

	pCurrentFunc = I;
	ParmFrameSize = S1;
	AllocatedFrameSize = 0;

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  pType = st_void;
	while P < nNODE do
		pType = Code(P);
		when pType == st_noreturn:
			exit;
		P = Node[P].pRight;
	end

	if pType != st_noreturn then
		if pReturnVoid == nNODE then
			pReturnVoid = Peek();
			Node[pReturnVoid].ID = iRETURN;
		end
		Code(pReturnVoid);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word EmitFunctions(char @Buff)
	word Start = 0;

	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				when Dict[I].Sub == sMAIN:
					Start = Dict[I].Label;
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when Start == 0:
		StopInternalCodegen(__FILE__, __LINE__);

	return Start;
end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word Start = EmitFunctions(@Buff);

	return Start;

end

/*****************************************************************************/

