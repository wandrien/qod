
/*
	Основная часть кодогенератора.
*/

namespace CodeEmitter of

/*****************************************************************************/

word Code(word P);
word Code_(word P; char @Buff);
word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M);
bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal);
bool CodeRequiresSingleRegister_(word P);
bool CodeRequiresSingleRegister(word P);

struct FunctionContext of
	word pFunc;
	word ParamFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
	word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */
	word StackSize;
	bool FramePointer;
end

void EmitFunctionEpilogue(char @Buff; FunctionContext @FnCtx);

FunctionContext FnCtx;

word Reg_TARGET;
word Reg_ALT_TARGET;
word RegAllocation[5];

void RegAllocate(word Reg)
	when RegAllocation[Reg] != 0:
		StopInternalCodegen(__FILE__, __LINE__);
	inc RegAllocation[Reg];
end

void RegFree(word Reg)
	when RegAllocation[Reg] != 1:
		StopInternalCodegen(__FILE__, __LINE__);
	dec RegAllocation[Reg];
end

/*****************************************************************************/

word RegChoiceOrder[4];

bool IsRegSelectable(word Reg)
	return Reg_ALT_TARGET != Reg & RegAllocation[Reg] == 0;
end

word ChooseEmptyRegRated()
	int BestRate = 100; /* the lower the better */
	word BestReg = RegNone;

	word I = 0;
	while I < countof(RegChoiceOrder) do
		word Reg = RegChoiceOrder[I];
		int Rate = PHO_GetRegRate(Reg);
		when Rate == 0:
			return Reg;
		if Rate < BestRate then
			BestRate = Rate;
			BestReg = Reg;
		end:if
		inc I;
	end:while
	return BestReg;
end

word ChooseEmptyReg_IgnoreConsts()
	when IsRegSelectable(RegA):
		return RegA;
	when IsRegSelectable(RegD):
		return RegD;
	when IsRegSelectable(RegC):
		return RegC;
	when IsRegSelectable(RegB):
		return RegB;
	return RegNone;
end

word ChooseEmptyReg()
	when IsRegSelectable(RegA) & !PHO_RegContainsAConst(RegA):
		return RegA;
	when IsRegSelectable(RegD) & !PHO_RegContainsAConst(RegD):
		return RegD;
	when IsRegSelectable(RegC) & !PHO_RegContainsAConst(RegC):
		return RegC;
	when IsRegSelectable(RegB) & !PHO_RegContainsAConst(RegB):
		return RegB;
	return ChooseEmptyReg_IgnoreConsts();
end

word ChooseEmptyReg2_IgnoreConsts()
	when IsRegSelectable(RegA):
		return RegA;
	when IsRegSelectable(RegB):
		return RegB;
	when IsRegSelectable(RegD):
		return RegD;
	when IsRegSelectable(RegC):
		return RegC;
	return RegNone;
end

word ChooseEmptyReg2()
	when IsRegSelectable(RegA) & !PHO_RegContainsAConst(RegA):
		return RegA;
	when IsRegSelectable(RegB) & !PHO_RegContainsAConst(RegB):
		return RegB;
	when IsRegSelectable(RegD) & !PHO_RegContainsAConst(RegD):
		return RegD;
	when IsRegSelectable(RegC) & !PHO_RegContainsAConst(RegC):
		return RegC;
	return ChooseEmptyReg2_IgnoreConsts();
end

word ChooseEmptyReg3()
	when IsRegSelectable(RegB) & !PHO_RegContainsAConst(RegB):
		return RegB;
	when IsRegSelectable(RegC) & !PHO_RegContainsAConst(RegC):
		return RegC;
	when IsRegSelectable(RegB):
		return RegB;
	when IsRegSelectable(RegC):
		return RegC;
	return RegNone;
end

word ChooseOptimalRegForNode(word P; word RegDefault)
	select
	case NodeCanBeEncodedAsImm(P):
		word Value = Node[P].Value;
		if Value == 0 then
			return ChooseEmptyReg2();
		else
			return RegDefault;
		end:if
	case CodeRequiresSingleRegister(P):
		word Reg = ChooseEmptyReg2();
		if Reg != RegNone then
			return Reg;
		else
			return RegDefault;
		end:if
	default:
		return RegDefault;
	end:select
end

/*****************************************************************************/

word LookupRegForNode(word P)
	word Reg = PHO_LookupRegForNode(P);
	if Reg != RegNone then
		return Reg;
	end:if

	when !NodeCanBeEncodedAsImm(P):
		return RegNone;

	word Size = T_SizeOf(Node[P].pType);
	when (Size != 4) & (Size != 2) & (Size != 1):
		return RegNone;
	/* FIXME: проверять только часть регистра при необходимости */
	return PHO_FindRegWithConst(Node[P].Value);
end

/*****************************************************************************/

struct CODEBLOCK of
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = FnCtx.AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	FnCtx.AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P; char @Buff)
	while P < nNODE do
		word pType = Code_(P, @Buff);
		when pType == st_noreturn:
			return st_noreturn;
		P = Node[P].pRight;
	end
	return st_void;
end

word Code_Block(word P; char @Buff)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	word pType = Code_List(P, @Buff);
	Code_EndBlock(@CB);
	return pType;
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.qdi";

/*****************************************************************************/

void Emit_SaveReg(word Reg; char @Comment)
	char Buff[nBUFF];
	Buff[0] = #0;
	EmitWithExprComment(@EncodePushReg(@Buff, Reg, Mach.AllowedRegSize), @Comment);
end

void Emit_RestoreReg(word Reg; char @Comment)
	char Buff[nBUFF];
	Buff[0] = #0;
	EmitWithExprComment(@EncodePopReg(@Buff, Reg, Mach.AllowedRegSize), @Comment);
end

/*****************************************************************************/

void Code_ADDR(word P1; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if !T_IsPtr(Ref.pType) then
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:if

	word pTypeDeref = T_DerefPtr(Ref.pType);
	word Size = T_SizeOf(pTypeDeref);

	word pIndex = P1;

	if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
		pIndex = nNODE;
	end:if

	if pIndex < nNODE then
		select
		case Ref.IX == RegNone:
			pass;
		case Ref.IX == Reg_ALT_TARGET:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		case Reg_ALT_TARGET != RegNone:
			if Reg_TARGET != Reg_ALT_TARGET then
				Emit_SaveReg(Reg_ALT_TARGET, "saved in Code_ADDR");
			end:if
			Buff[0] = #0;
			Emit_XCHG_Reg_Reg(Ref.IX, Reg_ALT_TARGET, Mach.AllowedRegSize);
			Reg_TARGET = Ref.IX;
			Ref.IX = Reg_ALT_TARGET;
		default:
			Reg_ALT_TARGET = Ref.IX;
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		Code_(pIndex, @Buff);
		Emit_MUL_Reg_Const(Reg_TARGET, 4, Size);

		if Reg_TARGET == Reg_ALT_TARGET then
			if Ref.IX != RegNone then
				Ref.IX = RegB;
				Emit_RestoreReg(Ref.IX, "restored in Code_ADDR");
			end:if
		end:if
	end:if

	char @TX = @EncodeReg(NULL, Reg_TARGET, 4);

	switch Ref.ID of
	case iDATA, iPARM, iLOCAL, iREF:
		if pIndex < nNODE then
			strcpy3(@Buff,"add     ",@TX,",  ");
		else
			strcpy3(@Buff,"mov     ",@TX,",  ");
		end:if
		Emit(@ValueRef_Encode(@Buff, @Ref));
	case iREG:
		if Ref.IX != RegNone then
			if Reg_TARGET != Ref.IX then
				char @RX = @EncodeReg(NULL, Ref.IX, 4);
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  dword ");
					strcat7(@Buff,"[",@TX,"+",@RX,"+",@istr(Ref.Offset),"]");
					EmitPhoInvalidate(@Buff);
				else
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@RX));
				end:if
			end:if
		else
			//Reg_TARGET = Ref.IX;
			pass;
		end:if
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:switch

	if Reg_TARGET == Reg_ALT_TARGET | Reg_ALT_TARGET == RegNone then
		Ref.IX = Reg_TARGET;
	else
		word Reg_TARGET_tmp = Reg_TARGET;
		if Ref.IX != RegNone then
			when (Reg_ALT_TARGET == RegNone):
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = Reg_ALT_TARGET;
		end:if

		Ref.IX = Reg_TARGET_tmp;
	end:if

	Ref.pType = pTypeDeref;
	Ref.ID = iREF;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_INDEX(word P1; ValueRef @Ref)
	Ref.pType = T_DerefArray(Ref.pType);
	word Size = T_SizeOf(Ref.pType);
	select
	case NodeIsLiteralWord(P1):
		word IndexingOffset = Size * Node[P1].Value;
		Ref.Offset = Ref.Offset + int(IndexingOffset);
	case Ref.IX == RegNone:
		Code(P1);
		Ref.IX = Reg_TARGET;
		Emit_MUL_Reg_Const(Ref.IX, 4, Size);
		when Reg_ALT_TARGET == RegNone:
			Reg_ALT_TARGET = Ref.IX;
	default:
		when Reg_ALT_TARGET != RegNone & Reg_ALT_TARGET != Ref.IX:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		Reg_TARGET = ChooseEmptyReg();
		when Reg_TARGET == Reg_ALT_TARGET | Reg_TARGET == RegNone:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		Code(P1);
		Emit_MUL_Reg_Const(Reg_TARGET, 4, Size);
		if Reg_TARGET == Reg_ALT_TARGET then
			when Reg_TARGET != Ref.IX:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = ChooseEmptyReg();
			Emit_RestoreReg(Reg_TARGET, "restored in Code_INDEX");
		end:if
		Emit_CmdRegReg("add", Ref.IX, 4, Reg_TARGET, 4);
		Reg_TARGET = Ref.IX;
	end:select
end

/*****************************************************************************/

void Code_LPTR(word P1; ValueRef @Ref)
	char Buff [nBUFF];
	Buff[0] = #0;

	char @TX = @EncodeReg(NULL, Reg_TARGET, 4);

	if Ref.IX != RegNone then
		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"add     ",@TX,",  ");
			Emit(@ValueRef_Encode_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			EmitPhoInvalidate(@ValueRef_Encode_ForLEA(@Buff, @Ref));
		case iREF:
			if Reg_TARGET != Ref.IX then
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  ");
					EmitPhoInvalidate(@ValueRef_Encode_ForLEA(@Buff, @Ref));
				else
					Emit_MOV_Reg_Reg(Reg_TARGET, Ref.IX, Mach.PointerSize);
				end
			else
				when Ref.Offset != 0:
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@istr(Ref.Offset)));
			end
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	else
		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"mov     ",@TX,",  ");
			Emit(@ValueRef_Encode_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			EmitPhoInvalidate(@ValueRef_Encode_ForLEA(@Buff, @Ref));
		case iREF:
			pass;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	end:if

	Ref.pType = T_PtrTo(Ref.pType);
	Ref.ID = iREG;
	Ref.IX = Reg_TARGET;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_CALL(word pPrimary; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if Reg_ALT_TARGET == RegA & Reg_TARGET != RegA then
		Emit_SaveReg(RegA, "saved in Code_CALL");
	end:if
	Reg_TARGET = RegA;

	switch Node[pPrimary].ID of
	case iCALL:
		when Node[pPrimary].pLeft != nNODE:
			Code_(Node[pPrimary].pLeft, @Buff);
		word pFunc = NodeGetDict(pPrimary);
		if Dict[pFunc].Sub == SUBCLASS.sSYS then
			EmitWithPhoMode(
				@strcpy3(@Buff,"call   [@",@str(Dict[pFunc].Label),"]"),
				PHO_Mode_Invalidate
			);
		else
			EmitWithPhoModeAndComment(
				@strcpy2(@Buff,"call    @",@str(Dict[pFunc].Label)),
				PHO_Mode_Invalidate,
				@DictGetName(pFunc)
			);
		end:if
	case iCALL2:
		when Node[pPrimary].pLeft != nNODE:
			Code_(Node[pPrimary].pLeft, @Buff);
		Code_(Node[pPrimary].pRight, @Buff);
		EmitWithPhoMode("call    EAX", PHO_Mode_Invalidate);
	default:
		StopInternal(__FILE__, __LINE__);
	end:switch

	Reg_TARGET = RegA;
	Ref.pType = Node[pPrimary].pType;
	Ref.ID = iREG;
	Ref.IX = RegA;
	Ref.Offset = 0;
end

/*****************************************************************************/

word CodePrimary(word pPrimary; ValueRef @Ref)

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iCALL, iCALL2:
		Code_CALL(pPrimary, @Ref);

	case iINDEX:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_INDEX(Node[pPrimary].pRight, @Ref);

	case iLPTR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_LPTR(Node[pPrimary].pRight, @Ref);

	case iADDR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_ADDR(Node[pPrimary].pRight, @Ref);

	case iFIELD:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	default:
		word pType = Code(pPrimary);
		Ref.ID = iREG;
		Ref.RO = 0;
		Ref.pType = pType;
		Ref.Offset = 0;
		Ref.IX = Reg_TARGET;
	end

	return Ref.pType;
end

/*****************************************************************************/

word Code_LOAD(word pPrimary; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if Ref.ID==iREG then
		//when Ref.IX != Reg_TARGET:
		//	StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		return Ref.pType;
	end:if

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy3(@Buff, "mov     ", @EncodeReg(NULL, Reg_TARGET, Size), ",  ");
		ValueRef_Encode(@Buff, @Ref);
	default:
		strcpy3(@Buff, "lea     ", @EncodeReg(NULL, Reg_TARGET, Mach.PointerSize), ",  ");
		ValueRef_Encode_ForLEA(@Buff, @Ref);
	end:select

	Emit(@Buff);

	PHO_LinkNode(Reg_TARGET, pPrimary);
	return Ref.pType;
end

/*****************************************************************************/

void Code_STORE(ValueRef @Ref; word pLinkStore, pLinkLoad)
	char Buff[nBUFF];
	Buff[0] = #0;

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy(@Buff,"mov     ");
		ValueRef_Encode(@Buff, @Ref);

		/*when Ref.IX != Reg_TARGET & Ref.IX != RegNone:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);*/

		select
		case Reg_TARGET != Reg_ALT_TARGET:
			Emit(@strcat2(@Buff,", ",@EncodeReg(NULL, Reg_ALT_TARGET, Size)));
			PHO_LinkNode(Reg_ALT_TARGET, pLinkLoad);
			PHO_LinkNode_Store(Reg_ALT_TARGET, pLinkStore);
		case Ref.IX==RegA:
			Emit_RestoreReg(RegB, "restored in Code_STORE");
			Emit(@strcat2(@Buff,", ",@EncodeReg(NULL, RegB, Size)));
			PHO_LinkNode(RegB, pLinkLoad);
			PHO_LinkNode_Store(RegB, pLinkStore);
		case Ref.IX==RegB:
			Emit_RestoreReg(RegA, "restored in Code_STORE");
			Emit(@strcat2(@Buff,", ",@EncodeReg(NULL, RegA, Size)));
			PHO_LinkNode(RegA, pLinkLoad);
			PHO_LinkNode_Store(RegA, pLinkStore);
		end:select
	default:
		strcpy(@Buff,"lea     EDI,  ");
		ValueRef_Encode_ForLEA(@Buff, @Ref);
		Emit(@Buff);

		if Reg_TARGET != Reg_ALT_TARGET then
			Emit(@strcpy2(@Buff,"mov     ESI,  ",@EncodeReg(NULL, Reg_ALT_TARGET, Mach.PointerSize)));
		else
			EmitWithExprComment("pop     ESI", "restored in Code_STORE");
		end:if

		Emit("cld");
		Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
		Emit("rep     movsb");
		PHO_RegConnectConst(RegC, 0);
	end:select
end

/*****************************************************************************/

word Code_CAST(char @Buff; word P; word pTypeTo; word pTypeFrom; word Reg; word @Complexity)
	Complexity = 0;

	when Node[P].ID == iNOOP_CAST:
		return pTypeTo;

	select
	case pTypeFrom == nDICT:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeFrom == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case T_Equal(pTypeTo, pTypeFrom):
		pass;
	case (T_IsInteger(pTypeTo) | pTypeTo == st_char)&
	     (T_IsInteger(pTypeFrom) | pTypeFrom == st_char):
		word SizeTo = T_SizeOf(pTypeTo);
		word SizeFrom = T_SizeOf(pTypeFrom);
		/*
			unsigned(16) into unsigned(32)  zero-extension
			unsigned(16) into signed(32)    zero-extension
			signed(16) into signed(32)      sign-extension
			signed(16) into unsigned(32)    sign-extension
		*/
		if SizeTo > SizeFrom then
			if T_IsSigned(pTypeFrom) then
				Complexity = 1;
				if @Buff != NULL then
					Emit_MOVSX_Reg_Reg(Reg, SizeTo, Reg, SizeFrom);
				end:if
			else
				Complexity = 1;
				if @Buff != NULL then
					Emit_MOVZX_Reg_Reg(Reg, SizeTo, Reg, SizeFrom);
				end:if
			end:if
		end:if
	case T_IsPtr(pTypeTo) & T_IsPtr(pTypeFrom):
		pass;
	case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom):
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end

	when Complexity == 0:
		Node[P].ID = iNOOP_CAST;

	return pTypeTo;
end

/*****************************************************************************/

/*
	Для оптимизации генерируемого кода, нам требуется уметь отвечать на два вопроса:
	* Может ли ветка кода быть закодирована как MemRef (и формирование данного MemRef).
	* Может ли ветка кода быть закодирована с использованием только одного регистра.

	Для веток Primary алгоритм ответа на эти вопросы содержит по большей части
	идентичный код и отличается только в деталях.
	Эта вспомогательная функция проводит анализ веток Primary для одного из указанных
	вариантов анализа в зависимости от значения параметра Query.
*/

define Query_MemoryOperand 0
define Query_SingleRegOperand 1

struct OperandQuery of
	word Query;
	ValueRef Ref;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query);
bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q);

bool QueryOperandStatus_CAST(word pPrimary; OperandQuery @_Q)
	word pTypeFrom = Node[Node[pPrimary].pLeft].pType;
	word pTypeTo = Node[pPrimary].pType;
	when !QueryOperandStatus_(Node[pPrimary].pLeft, @_Q):
		return false;
	word Complexity = 0;
	DisableEmit();
	pTypeTo = Code_CAST(NULL, pPrimary, pTypeTo, pTypeFrom, RegA, @Complexity);
	EnableEmit();
	if Complexity == 0 then
		ValueRef @Ref = @_Q.Ref;
		Ref.pType = pTypeTo;
		return true;
	else
		return false;
	end:if
end

bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q)
	ValueRef @Ref = @_Q.Ref;
	word Query = _Q.Query;

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iLPTR:
		if Query == Query_SingleRegOperand then
			return QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		else
			return false;
		end:if

	case iINDEX:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_DerefArray(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if NodeIsLiteralWord(pIndex) then
			word IndexingOffset = Size * Node[pIndex].Value;
			Ref.Offset = Ref.Offset + int(IndexingOffset);
		else
			if Query != Query_SingleRegOperand then
				return false;
			end:if

			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
			Ref.IX = RegA;
		end:if

	case iADDR:
		if Query != Query_SingleRegOperand then
			return false;
		end:if

		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_DerefPtr(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
			pIndex = nNODE;
		end:if

		if pIndex < nNODE then
			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
		end:if
		Ref.Offset = 0;
		Ref.IX = RegA;

	case iFIELD:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	case iCAST, iREINTERPRET_CAST, iNOOP_CAST:
		return QueryOperandStatus_CAST(pPrimary, @_Q);
	default:
		return false;
	end

	return true;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query)
	when (Query == Query_SingleRegOperand) & (@pTypeFinal != NULL):
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);

	OperandQuery _Q;
	_Q.Query = Query;
	bool Result = QueryOperandStatus_(pPrimary, @_Q);

	if Result then
		switch Query of
		case Query_MemoryOperand:
			ValueRef @Ref = @_Q.Ref;
			word Size = SizeOfType(Ref.pType);
			select
			case IsNativeOperandSize(Size):
				if @Buff !=  NULL then
					Buff[0] = #0;
					ValueRef_Encode(@Buff, @Ref);
				end
				when @pTypeFinal != NULL:
					pTypeFinal = Ref.pType;
				return true;
			default:
				return false;
			end:select
		case Query_SingleRegOperand:
			pass;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		end:switch
	end:if

	return Result;
end

/*****************************************************************************/

/*
	Если узел pPrimary может быть закодирован как MemRef,
	выводит в буфер Buff этот MemRef, а в pTypeFinal записывает тип выражения.
	Возввращает true при этом.
	Если узел pPrimary не может быть закодирован как MemRef, возвращает false.
*/

bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal)
	return QueryOperandStatus(@Buff, pPrimary, @pTypeFinal, Query_MemoryOperand);
end

bool NodeCanBeEncodedAsMemoryOperand(word pPrimary)
	return QueryOperandStatus(NULL, pPrimary, NULL, Query_MemoryOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister_(word P)
	when NodeCanBeEncodedAsImm(P):
		return true;

	word ID = Node[P].ID;

	switch ID of
	case iADD, iBIT_OR, iBIT_XOR, iBIT_AND:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		if
			(CodeRequiresSingleRegister_(pRight)) &
			(
				NodeCanBeEncodedAsImm(pLeft) |
				NodeCanBeEncodedAsMemoryOperand(pLeft)
			)
		then
			return true;
		end:if
		return false;
	case iSUB:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		return false;
	case iMUL:
		if T_SizeOf(Node[P].pType) != 4 then
			return false;
		end:if
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			NodeCanBeEncodedAsImm(pRight) &
			CodeRequiresSingleRegister_(pLeft)
		then
			return true;
		end:if
		if
			NodeCanBeEncodedAsImm(pLeft) &
			CodeRequiresSingleRegister_(pRight)
		then
			return true;
		end:if
		return false;
	case iBIT_NOT, iNEG:
		return CodeRequiresSingleRegister_(Node[P].pLeft);
	case iNOOP_CAST:
		return CodeRequiresSingleRegister_(Node[P].pLeft);
	case iCAST, iREINTERPRET_CAST:
		word pTypeFrom = Node[Node[P].pLeft].pType;
		word pTypeTo = Node[P].pType;
		when !CodeRequiresSingleRegister_(Node[P].pLeft):
			return false;
		word Complexity = 0;
		pTypeTo = Code_CAST(NULL, P, pTypeTo, pTypeFrom, RegA, @Complexity);
		if Complexity < 2 then
			return true;
		else
			return false;
		end:if
	end:switch

	return QueryOperandStatus(NULL, P, NULL, Query_SingleRegOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister(word P)
	bool Result;
	DisableEmit();
	Result = CodeRequiresSingleRegister_(P);
	EnableEmit();
	return Result;
end

/*****************************************************************************/

/** Checks if the operands can be swapped for no cost, but we should change the operation ID as well.
    Returns the ID of swapped operation, if the operation is swappable.
    Returns the same ID, if the operation is commutative.
    Returns zero otherwise.
*/
word CheckOperationSwappable(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return ID;
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end

/*****************************************************************************/

bool DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightRegD(word ID)
	switch ID of
	case
		iDIV,
		iMOD:
		return false;
	default:
		return true;
	end:switch
end

bool DoesOperationAllowRightReg(word ID; word RegRight)
	switch ID of
	case
		iDIV,
		iMOD:
		if RegRight == RegD then
			return false;
		else
			return true;
		end
	default:
		return true;
	end:switch
end


/** A heuristic to determine whether it might be advantageous to change the order in which operands are evaluated.
    Returns NULL, if the operand evaluation should not be reordered.
    Returns a string describing the reason of reordering (for debugging purposes),
    if the operand evaluation should be reordered.
*/
char @CheckOperandReordering(word pLeft; word pRight)
	when !ReorderOperands:
		return NULL;

	when NodeCanBeEncodedAsImm(pRight):
		return NULL;

	when CodeRequiresSingleRegister(pRight):
		return NULL;

	when NodeCanBeEncodedAsImm(pLeft):
		return "Imm on the left";

	when CodeRequiresSingleRegister(pLeft):
		return "Single-register operand on the left";

	return NULL;
end

/*****************************************************************************/

word DropNoOpCast(word P)
	switch Node[P].ID of
	case iNOOP_CAST:
		return Node[P].pLeft;
	case iCAST, iREINTERPRET_CAST:
		word pLeft = Node[P].pLeft;
		word pTypeFrom = Node[pLeft].pType;
		word pTypeTo = Node[P].pType;
		word Complexity = 0;
		Code_CAST(NULL, P, pTypeTo, pTypeFrom, RegNone, @Complexity);
		if Node[P].ID != iNOOP_CAST then
			return P;
		else
			return pLeft;
		end
	default:
		return P;
	end:switch
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight):
		pass;
	case NodeCanBeEncodedAsImm(pLeft):
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2 = Code_(pLeft, @Buff);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	when !Emit_MUL_Reg_Const(Reg_TARGET, Size, RightValue):
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

word GetCommonOperandType(word pLeft; word pRight)
	word pTypeLeft = Node[pLeft].pType;
	word pTypeRight = Node[pRight].pType;
	when T_IsNulltype(pTypeRight):
		return pTypeLeft;
	when T_IsNulltype(pTypeLeft):
		return pTypeRight;
	when T_Equal(pTypeLeft, pTypeRight):
		return pTypeLeft;
	StopAtNodeInternalCodegen(__FILE__, __LINE__, pLeft);
end

/*****************************************************************************/

define operandNotReady 0
define operandReg      1
define operandImm      2
define operandMemRef   3

word CodeBinOp(char @Buff; word P; LABEL @F; LABEL @T; LABEL @M)
	Buff[0] = #0;

	forever do
		word pType = TryCodeFastMult(@Buff,P);
		when pType < nDICT:
			return pType;
		exit;
	end:forever

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;
	word pResultType = Node[P].pType;
	word ResultSize = SizeOfType(pResultType);
	bool opSwappable = (CheckOperationSwappable(ID) != 0);

	/* Variables related to comparison OPs */
	bool opIsComparison = false;
	bool useSetCC = true;
	bool allowEasyTargetSwitch = false;
	word Reg_TARGET_SavedForConditional = RegNone;
	word pCmpOperandType = nDICT;
	word CmpOperandSize = 0;

	if iLT <= ID & ID <= iGT then
		opIsComparison = true;

		/* The operand type may be lost during dropping redundant operand casts
		   below in the function. So save it here.
		*/
		pCmpOperandType = GetCommonOperandType(pLeft, pRight);
		CmpOperandSize = SizeOfType(pCmpOperandType);

		if @F == NULL & @T == NULL & @M == NULL then
			/* The caller doesn't expect us to emit jumps,
			   the result should be in a register instead. */
			useSetCC = true;
			Reg_TARGET_SavedForConditional = Reg_TARGET;
		else
			/* The caller does expect us to emit jumps,
			   the final register value is irrelevant. */
			useSetCC = false;
			/* Since these operations don't return a result in any register,
			   we may reset Reg_TARGET freely. */
			allowEasyTargetSwitch = true;
		end:if
	end

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if Reg_TARGET != RegA then
			when Reg_ALT_TARGET == RegA:
				Emit_SaveReg(RegA, "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
	end:switch

	pLeft = DropNoOpCast(pLeft);
	pRight = DropNoOpCast(pRight);

	char BuffRightOperand[nBUFF];
	word leftOperand  = operandNotReady;
	word rightOperand = operandNotReady;

	forever do
		when !ReorderOperands:
			exit;

		/*
			The usual calculation scheme is:
				Reg1  <- LeftOperand
				Reg2  <- RightOperand
				OP    Reg1,  Reg2

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) then

			/*
				## Immediate constant on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  ImmValue
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2,  ImmValue
					Op    Reg1,  Reg1
			*/
			if NodeCanBeEncodedAsImm(pRight) then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  ImmValue
				Instead of:
					mov   Reg1,  ImmValue
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if opSwappable & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				ID = CheckOperationSwappable(ID);
				rightOperand = operandImm;
				exit;
			end:if

		end:if

		if DoesOperationAllowRightMemRef(ID) then

			/*
				## Simple memory reference on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  [MemRef]
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2, [MemRef]
					Op    Reg1, Reg2
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL) then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  [MemRef]
				Instead of:
					mov   Reg1,  [MemRef]
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if opSwappable & NodeCanBeEncodedAsMemoryOperand(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL);
				ID = CheckOperationSwappable(ID);
				rightOperand = operandMemRef;
				exit;
			end:if

		end:if

		exit;
	end:forever

	word rightReg = RegNone;
	word fSwap=0;

	forever do

		word leftRegPreloaded = LookupRegForNode(pLeft);
		word rightRegPreloaded = RegNone;

		switch ID of
		case iEQ, iNE:
			when leftRegPreloaded == RegNone | !(NodeIsLiteralZero(pRight) | NodeIsNull(pRight)):
				rightRegPreloaded = LookupRegForNode(pRight);
		default:
			rightRegPreloaded = LookupRegForNode(pRight);
		end:switch

		when leftRegPreloaded == RegNone & rightRegPreloaded == RegNone:
			exit;

		bool leftAsRight =
		  (leftRegPreloaded != RegNone)
		& DoesOperationAllowRightReg(ID, leftRegPreloaded);
		bool rightAsRight =
		  (rightRegPreloaded != RegNone)
		& DoesOperationAllowRightReg(ID, rightRegPreloaded);

		bool leftAsLeft =
		  (leftRegPreloaded == Reg_TARGET)
		| (allowEasyTargetSwitch & leftRegPreloaded != RegNone);

		bool rightAsLeft =
		  (rightRegPreloaded == Reg_TARGET)
		| (allowEasyTargetSwitch & rightRegPreloaded != RegNone);

		if leftAsLeft & rightAsRight then
			leftOperand = operandReg;
			rightOperand = operandReg;
			Reg_TARGET = leftRegPreloaded;
			rightReg = rightRegPreloaded;
			exit;
		end

		if opSwappable & rightAsLeft & leftAsRight then
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			ID = CheckOperationSwappable(ID);
			leftOperand = operandReg;
			rightOperand = operandReg;
			Reg_TARGET = rightRegPreloaded;
			rightReg = leftRegPreloaded;
			exit;
		end:if

		if DoesOperationAllowRightMemRef(ID) then
			if leftAsLeft & NodeCanBeEncodedAsMemoryOperand(pRight) then
				leftOperand = operandReg;
				rightOperand = operandMemRef;
				Reg_TARGET = leftRegPreloaded;
				CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL);
				exit;
			end:if

			if opSwappable & rightAsLeft & NodeCanBeEncodedAsMemoryOperand(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				ID = CheckOperationSwappable(ID);
				leftOperand = operandReg;
				rightOperand = operandMemRef;
				Reg_TARGET = rightRegPreloaded;
				CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL);
				exit;
			end:if
		end:if

		if DoesOperationAllowRightImm(ID) then
			if leftAsLeft
			&  NodeCanBeEncodedAsImm(pRight)
			then
				leftOperand = operandReg;
				rightOperand = operandImm;
				Reg_TARGET = leftRegPreloaded;
				exit;
			end:if

			if opSwappable
			&  rightAsLeft
			&  NodeCanBeEncodedAsImm(pLeft)
			then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				ID = CheckOperationSwappable(ID);
				leftOperand = operandReg;
				rightOperand = operandImm;
				Reg_TARGET = rightRegPreloaded;
				exit;
			end:if
		end:if

		if rightRegPreloaded != Reg_TARGET
		&  rightAsRight
		&  CodeRequiresSingleRegister(pLeft)
		then
			rightOperand = operandReg;
			rightReg = rightRegPreloaded;
			exit;
		end:if

		if opSwappable
		&  leftRegPreloaded != Reg_TARGET
		&  leftRegPreloaded != RegNone
		&  CodeRequiresSingleRegister(pRight)
		then
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			ID = CheckOperationSwappable(ID);
			rightOperand = operandReg;
			rightReg = leftRegPreloaded;
			exit;
		end:if

		if opSwappable
		&  rightAsLeft
		&  CodeRequiresSingleRegister(pLeft)
		&  !NodeCanBeEncodedAsImm(pRight) then
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			ID = CheckOperationSwappable(ID);
			leftOperand = operandReg;
			Reg_TARGET = rightRegPreloaded;
			select
			case DoesOperationAllowRightMemRef(ID) & NodeCanBeEncodedAsMemoryOperand(pRight):
				rightOperand = operandMemRef;
				CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL);
			default:
				rightOperand = operandNotReady;
				rightReg = RegNone;
			end:select
			exit;
		end:if

		exit;
	end:forever

	if allowEasyTargetSwitch & (leftOperand == operandNotReady) then
		word Reg;
		if NodeCanBeEncodedAsMemoryOperand(pLeft) then
			Reg = ChooseEmptyRegRated();
		else
			Reg = ChooseEmptyReg();
		end:if
		when Reg != RegNone:
			Reg_TARGET = Reg;
	end:if


	switch rightOperand of
	case operandImm:
		if leftOperand == operandNotReady then
			Code_(pLeft, @Buff); Buff[0] = #0;
			leftOperand = operandReg;
		end:if

	case operandMemRef:
		if leftOperand == operandNotReady then
			Code_(pLeft, @Buff); Buff[0] = #0;
			leftOperand = operandReg;
		end:if

		word RegLinked = LookupRegForNode(pRight);
		if RegLinked != RegNone & DoesOperationAllowRightReg(ID, RegLinked)then
			EmitWithExprComment("", "Node link reuse in CodeBinOp");
			rightOperand = operandReg;
			rightReg = RegLinked;
		end:if

	case operandReg:
		if leftOperand == operandNotReady then
			when Reg_TARGET == rightReg | !CodeRequiresSingleRegister(pLeft):
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			Code_(pLeft, @Buff); Buff[0] = #0;
			leftOperand = operandReg;
		end:if

		when leftOperand != operandReg:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);

	case operandNotReady:
		char @reorderingReason = @CheckOperandReordering(pLeft, pRight);
		if @reorderingReason != NULL then
			EmitWithExprComment("", "Reordering in CodeBinOp");
			EmitWithExprComment("", @reorderingReason);
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			inc fSwap;
		end:if

		rightOperand = operandReg;
		rightReg = RegB;
		if CodeRequiresSingleRegister(pRight) then
			if DoesOperationAllowRightRegD(ID) & !PHO_RegContainsAConst(RegD) then
				rightReg = RegD;
			else
				rightReg = RegC;
			end:if
		end:if

		/*
			Если мы оказались здесь, значит нам нужны 2 регистра,
			и значение одного из них потребуется не потерять при вычислении
			правого операнда.

			Назначаем Reg_ALT_TARGET, если вызывающий код этого не сделал,
			сохраняем регистр, если вызывающий код уже использует Reg_ALT_TARGET.
		*/
		word Saved_Reg_ALT_TARGET = Reg_ALT_TARGET;
		if Reg_TARGET != RegA then
			when Reg_ALT_TARGET == RegA:
				Emit_SaveReg(RegA, "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
		when Reg_ALT_TARGET != RegA:
			Reg_ALT_TARGET = RegA;

		Code_(pLeft, @Buff); Buff[0] = #0;
		if Reg_TARGET != Reg_ALT_TARGET then
			/* Операнд был возвращён в другом регистре. */
			Emit_MOV_or_XCHG(Reg_ALT_TARGET, Reg_TARGET, 4);
		end

		when Reg_ALT_TARGET != RegA:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);

		Reg_TARGET = rightReg;
		Code_(pRight, @Buff); Buff[0] = #0;

		if Reg_TARGET == Reg_ALT_TARGET then
			Emit_RestoreReg(rightReg, "restored in CodeBinOp");
			inc fSwap;
		end
		Reg_TARGET = Reg_ALT_TARGET;

		Reg_ALT_TARGET = Saved_Reg_ALT_TARGET;

	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:switch

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		forever do
			/* We can handle it by changing the operation ID */
			if opSwappable then
				ID = CheckOperationSwappable(ID);
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit_XCHG_Reg_Reg(Reg_TARGET, rightReg, Mach.AllowedRegSize);
				exit;
			end:switch

			/* In other cases, swapped operands shouldn't happen. */
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:forever
	end:if


	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = as_unsigned(-Value);

		switch as_signed(Value) of
		case 1:
			if PreferIncDec(Reg_TARGET, ResultSize) > 0 then
				Emit_INC_Reg(Reg_TARGET, ResultSize);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pResultType;
			end:if
		case -1:
			if PreferIncDec(Reg_TARGET, ResultSize) > 0 then
				Emit_DEC_Reg(Reg_TARGET, ResultSize);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pResultType;
			end:if
		case 2:
			if PreferIncDec(Reg_TARGET, ResultSize) > 1 then
				Emit_INC_Reg(Reg_TARGET, ResultSize);
				Emit_INC_Reg(Reg_TARGET, ResultSize);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pResultType;
			end:if
		case -2:
			if PreferIncDec(Reg_TARGET, ResultSize) > 1 then
				Emit_DEC_Reg(Reg_TARGET, ResultSize);
				Emit_DEC_Reg(Reg_TARGET, ResultSize);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pResultType;
			end:if
		end:switch
	end:if

	word _MeaningfulFlags = 0;

	select
	case opIsComparison:

		if !useSetCC then
			/* Reorder for easier handling. */
			if @T == NULL then
				switch ID of
				case iLT: ID=iGE;
				case iLE: ID=iGT;
				case iEQ: ID=iNE;
				case iNE: ID=iEQ;
				case iGE: ID=iLT;
				case iGT: ID=iLE;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				end:switch

				@T = @F;
				@F = NULL;
			end:if

			if @T == NULL | @F != NULL then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
		end:if

		select
		case rightOperand == operandImm:
			word Value = Node[pRight].Value;
			word PHO_Load_Value = Value;
			bool SkipCmp = false;
			switch Value of
			case 0:
				select
				case (ID == iEQ) | (ID == iNE):
					if (MeaningfulFlags & Flag_Zero) != 0 then
						pass; /* ! */
						SkipCmp = true;
					else
						Emit_TEST_Reg_Self(Reg_TARGET, CmpOperandSize);
						SkipCmp = true;
						if fSwap==0 then
							PHO_LinkNode(Reg_TARGET, pLeft);
						end:if
					end:if
				case (MeaningfulFlags & (Flag_Zero | Flag_Sign)) == (Flag_Zero | Flag_Sign):
					select
					case (ID == iGE) & T_IsSigned(pCmpOperandType):
						ID = iBRANCH_NSF;
						SkipCmp = true;
					case (ID == iLT) & T_IsSigned(pCmpOperandType):
						ID = iBRANCH_SF;
						SkipCmp = true;
					end:select
				end:select
			case 1:
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, CmpOperandSize) != 0 then
					Emit_DEC_Reg(Reg_TARGET, CmpOperandSize);
					dec PHO_Load_Value;
					SkipCmp = true;
				end:if
			case word(-1):
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, CmpOperandSize) != 0 then
					Emit_INC_Reg(Reg_TARGET, CmpOperandSize);
					inc PHO_Load_Value;
					SkipCmp = true;
				end:if
			end:switch
			if !SkipCmp then
				BuffRightOperand[0] = #0;
				if PHO_EncodeRegContainingConst(@BuffRightOperand, Value, CmpOperandSize) != 0 then
					EmitPhoSkip(
						@EncodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, CmpOperandSize, @BuffRightOperand)
					);
				else
					EmitPhoSkip(
						@EncodeCmdRegConst(@Buff, "cmp", Reg_TARGET, CmpOperandSize, Value)
					);
				end:if
				if fSwap==0 then
					PHO_LinkNode(Reg_TARGET, pLeft);
				end:if
			end:if
			when (CmpOperandSize == 4) & (ID == iNE):
				PHO_RegConnectConst(Reg_TARGET, PHO_Load_Value);
		case rightOperand == operandMemRef:
			EmitPhoSkip(
				@EncodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, CmpOperandSize, @BuffRightOperand)
			);
			if fSwap==0 then
				PHO_LinkNode(Reg_TARGET, pLeft);
			end:if
		case rightOperand == operandReg:
			EmitPhoSkip(
				@EncodeCmdRegReg(@Buff, "cmp", Reg_TARGET, CmpOperandSize, rightReg, CmpOperandSize)
			);
			if fSwap==0 then
				PHO_LinkNode(Reg_TARGET, pLeft);
				PHO_LinkNode(rightReg, pRight);
			end:if
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end

		char@ BranchCondition = "";
		select
		case T_IsSigned(pCmpOperandType):
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			case iBRANCH_SF: @BranchCondition = "s ";
			case iBRANCH_NSF: @BranchCondition = "ns";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
		end:select

		if useSetCC then
			Reg_TARGET = Reg_TARGET_SavedForConditional;
			char Cmd[8];
			strcpy2(@Cmd,"set",@BranchCondition);
			Buff[0] = #0;
			Emit(@EncodeCmdReg(@Buff, @Cmd, Reg_TARGET, 1));
			select
			case ResultSize == 1:
				pass;
			case ResultSize <= Mach.AllowedRegSize:
				Emit_MOVZX_Reg_Reg(Reg_TARGET, ResultSize, Reg_TARGET, 1);
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
			return pResultType;
		else
			EmitBranchToLabel(@BranchCondition, @T);
			return st_cond_branch;
		end:if

	case ID==iBIT_OR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"and     ");

	case ID==iADD:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pResultType):
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pResultType):
			strcpy(@Buff,"mul     ");
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		switch rightOperand of
		case operandImm:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		case operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case operandReg:
			EncodeReg(@Buff, rightReg, ResultSize);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:switch

		EmitPhoSkip(@Buff);

		PHO_InvalidateReg(RegA);
		PHO_InvalidateReg(RegD);

		return pResultType;

	case ID==iDIV | ID==iMOD:
		select
		case ResultSize==1:
			if T_IsSigned(pResultType) then
				Emit("movsx   AX,   AL");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     AH,   AH");
				strcpy(@Buff,"div     ");
			end:if
		case ResultSize==2:
			if rightOperand == operandReg & rightReg == RegD then
				word newRightReg = ChooseEmptyReg3();
				when newRightReg == RegNone:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				Emit_MOV_or_XCHG(newRightReg, rightReg, ResultSize);
				rightReg = newRightReg;
			end:if

			if T_IsSigned(pResultType) then
				Emit("cwq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     DX,   DX");
				strcpy(@Buff,"div     ");
			end:if
		case ResultSize==4:
			if rightOperand == operandReg & rightReg == RegD then
				word newRightReg = ChooseEmptyReg3();
				when newRightReg == RegNone:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
				Emit_MOV_or_XCHG(newRightReg, rightReg, ResultSize);
				rightReg = newRightReg;
			end:if

			if T_IsSigned(pResultType) then
				Emit("cdq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     EDX,  EDX");
				strcpy(@Buff,"div     ");
			end:if
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		select
		case rightOperand == operandImm:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			EncodeReg(@Buff, rightReg, ResultSize);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select

		Emit(@Buff);

		if ID==iMOD then
			select
			case ResultSize==1:
				Emit("mov     AL,   AH");
			case ResultSize==2:
				if Reg_ALT_TARGET == RegNone then
					Reg_TARGET = RegD;
				else
					Emit_MOV_or_XCHG(RegA, RegD, ResultSize);
				end:if
			case ResultSize==4:
				if Reg_ALT_TARGET == RegNone then
					Reg_TARGET = RegD;
				else
					Emit_MOV_or_XCHG(RegA, RegD, ResultSize);
				end:if
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:select
		end:if

		PHO_InvalidateReg(RegA);
		PHO_InvalidateReg(RegD);

		return pResultType;

	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:select

	select
	case IsNativeOperandSize(ResultSize):
		select
		case rightOperand == operandImm:
			EncodeRegConst(@Buff, Reg_TARGET, ResultSize, Node[pRight].Value);
		case rightOperand == operandMemRef:
			EncodeRegFmt(@Buff, Reg_TARGET, ResultSize, @BuffRightOperand);
		case rightOperand == operandReg:
			EncodeRegReg(@Buff, Reg_TARGET, ResultSize, rightReg, ResultSize);
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:select
		Emit(@Buff);
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:select

	MeaningfulFlags = _MeaningfulFlags;
	return pResultType;
end

/*****************************************************************************/

/*
	Генерация кода для условных переходов из булевых выражений.

	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M)
	char Buff[nBUFF];
	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when @T != NULL & @F != NULL: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	when Node[P].pType != st_bool:
		StopInternalCodegen(__FILE__, __LINE__);

	/* These operations don't return the result in any register,
	instead a conditional jump is the result. So we reset Reg_TARGET here. */
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;

	switch Node[P].ID of
	case iLITERAL:
		select
		case Node[P].Value == 0 & @F != NULL:
			EmitJumpToLabel(@F);
		case Node[P].Value != 0 & @T != NULL:
			EmitJumpToLabel(@T);
		end:select
		return st_cond_branch;

	case iLT, iLE, iEQ, iNE, iGE, iGT:
		return CodeBinOp(@Buff, P, @F, @T, @M);

	case iNOT:
		return CodeBooleanExpr(Node[P].pLeft, @T, @F, @M);
	case iOR:
		return Code_OR(P, @F, @T, @M, @Buff);
	case iXOR:
		Code_XOR(P, @F, @T, @M, @Buff);
		//return st_cond_branch;
	case iEQV:
		Code_EQV(P, @F, @T, @M, @Buff);
		//return st_cond_branch;
	case iAND:
		return Code_AND(P, @F, @T, @M, @Buff);

	default:
		when CodeRequiresSingleRegister(P):
			Reg_TARGET = ChooseEmptyReg();
		Code_(P, @Buff); Buff[0] = #0;
		word Size = T_SizeOf(Node[P].pType);
		Emit_TEST_Reg_Self(Reg_TARGET, Size);
		select
		case @F != NULL:
			EmitBranchToLabel("z", @F);
		case @T != NULL:
			EmitBranchToLabel("nz", @T);
			when Size == 4:
				PHO_RegConnectConst(Reg_TARGET, 0);
		end:select
		return st_cond_branch;

	end:switch
end

/*****************************************************************************/

word CodeBooleanExprNoJumpTargets(word P)
/*
		CodeBooleanExpr(P, NULL, L_TRUE, L_FALSE);
	L_FALSE:
		mov Reg, 0
		jmp L_END
	L_TRUE:
		mov Reg, 1
	L_END:
*/

	word pType = Node[P].pType;
	word Size = T_SizeOf(pType);

	LABEL @L_FALSE = @LabelResolve(P, JmpLbl.lFALSE);
	LABEL @L_TRUE = @LabelResolve(P, JmpLbl.lTRUE);
	LABEL @L_END = @LabelResolve(P, JmpLbl.lEND);

	word Saved_Reg_TARGET = Reg_TARGET;
	when CodeBooleanExpr(P, NULL, @L_TRUE, @L_FALSE) != st_cond_branch:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	Reg_TARGET = Saved_Reg_TARGET;

	EmitLabelIfUsed(@L_FALSE);
	Emit_Load_Constant(Reg_TARGET, Size, 0);

	if LabelIsUsed(@L_TRUE) then
		EmitJumpToLabel(@L_END);
		EmitLabel(@L_TRUE);
		Emit_Load_Constant(Reg_TARGET, Size, 1);
		EmitLabel(@L_END);
	end

	return Node[P].pType;
end

/*****************************************************************************/

word Code_INCDEC(word pPrimary; char @Buff)
	ValueRef Ref;
	CodePrimary(Node[pPrimary].pLeft, @Ref);

	if Node[pPrimary].ID==iINC then
		strcpy(@Buff,"inc     ");
	else
		strcpy(@Buff,"dec     ");
	end:if

	word Size = T_SizeOf(Ref.pType);
	select
	case IsNativeOperandSize(Size):
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
	end:select

	Emit(@ValueRef_Encode(@Buff, @Ref));

	return st_void;
end

/*****************************************************************************/

word Code_ASSIGN(word P; char @Buff)
	word P1 = Node[P].pLeft;
	if Node[P1].pRight < nNODE then
		word RegRight = LookupRegForNode(Node[P1].pRight);
		select
		case RegRight != RegNone & CodeRequiresSingleRegister(Node[P1].pLeft):
			EmitWithExprComment("", "Node link reuse in Code_ASSIGN (1)");
			Reg_ALT_TARGET = RegNone;
			Reg_TARGET = RegRight;

			Reg_ALT_TARGET = Reg_TARGET;
			Reg_TARGET = ChooseEmptyReg2();
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		case !CodeRequiresSingleRegister(Node[P1].pLeft)
		& CodeRequiresSingleRegister(Node[P1].pRight):
			Reg_TARGET = RegA;
			Reg_ALT_TARGET = RegNone;
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);

			Reg_ALT_TARGET = Ref.IX;
			Reg_TARGET = ChooseEmptyReg2();
			Code_(Node[P1].pRight, @Buff);

			Reg_ALT_TARGET = Reg_TARGET;
			Reg_TARGET = RegNone;
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		default:
			Reg_ALT_TARGET = PHO_LookupRegForNode(Node[P1].pRight);
			if Reg_ALT_TARGET == RegNone then
				if CodeRequiresSingleRegister(Node[P1].pLeft) then
					Reg_TARGET = ChooseOptimalRegForNode(Node[P1].pRight, RegA);
				else
					Reg_TARGET = RegA;
				end:if
				Code_(Node[P1].pRight, @Buff);
				Reg_ALT_TARGET = Reg_TARGET;
			else
				EmitWithExprComment("", "Node link reuse in Code_ASSIGN (2)");
			end

			Reg_TARGET = ChooseEmptyReg2();
			ValueRef Ref;
			CodePrimary(Node[P1].pLeft, @Ref);
			Code_STORE(@Ref, Node[P1].pLeft, Node[P1].pRight);
		end
	else
		Reg_TARGET = RegA;
		Reg_ALT_TARGET = RegNone;
		Code_(Node[P1].pLeft, @Buff);
	end

	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;
	return Node[P].pType;
end

/*****************************************************************************/

word CodePrimaryWrapped(word P)
	if PHO_CheckRegForNode(Reg_TARGET, P) then
		EmitWithExprComment("", "Node link reuse in CodePrimaryWrapped");
		return Node[P].pType;
	end:if

	ValueRef Ref;
	CodePrimary(P, @Ref);
	Code_LOAD(P, @Ref);
	return Ref.pType;
end

/*****************************************************************************/

word Code_(word P; char @Buff)
	Buff[0] = #0;

	when P == nNODE:
		return st_void;
		//StopInternalCodegen(__FILE__, __LINE__);

	when P > nNode:
		StopInternalCodegen(__FILE__, __LINE__);

	EmitWithSourceNote(NULL, P);

	switch Node[P].ID of
	case iDATA, iPARM, iLOCAL, iSTRING,
	     iCALL, iCALL2, iINDEX, iLPTR, iADDR, iFIELD:
		return CodePrimaryWrapped(P);

	case iNULL:
		Emit_Load_Constant(Reg_TARGET, 4, 0);
		return Node[P].pType;

	case iLITERAL:
		Emit_Load_Constant(Reg_TARGET, T_SizeOf(Node[P].pType), Node[P].Value);
		return Node[P].pType;

	case iFUNC:
		Emit(@EncodeLoadLabel(@Buff, Reg_TARGET, Node[P].Value));
		return Node[P].pType;

	case iINC, iDEC:
		return Code_INCDEC(P, @Buff);

	case iNOOP_CAST:
		Code_(Node[P].pLeft, @Buff);
		return Node[P].pType;

	case iCAST, iREINTERPRET_CAST:
		word pTypeFrom = Code_(Node[P].pLeft, @Buff);
		word pTypeTo = Node[P].pType;
		word Complexity = 0;
		return Code_CAST(@Buff, P, pTypeTo, pTypeFrom, Reg_TARGET, @Complexity);

	case iBIT_NOT:
		word pType = Code_(Node[P].pLeft, @Buff);
		word  Size = SizeOfType(pType);
		Emit(@EncodeCmdReg(@Buff, "not", Reg_TARGET, Size));

		return pType;

	case iNEG:
		if NodeIsLiteralWord(Node[P].pLeft) then
			Emit_Load_Constant(Reg_TARGET, 4, as_unsigned(-Node[Node[P].pLeft].Value));
			return Node[P].pType;
		end

		Code_(Node[P].pLeft, @Buff);

		Emit(@EncodeCmdReg(@Buff, "neg", Reg_TARGET, T_SizeOf(Node[P].pType)));

		return Node[P].pType;

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
		return CodeBinOp(@Buff, P, NULL, NULL, NULL);

	case iOR, iAND, iNOT:
		return CodeBooleanExprNoJumpTargets(P);

	case iDEF_LOCAL:
		if nLocal>=nLOCAL then
			StopMemory();
		end

		word pType = Node[P].pType;
		word Size  = SizeOfType(pType);

		FnCtx.AllocatedFrameSize = FnCtx.AllocatedFrameSize + DefaultInStackAlign(Size);

		word i = nLocal;
		inc nLocal;
		Local[i].pType = pType;
		Local[i].Value = FnCtx.AllocatedFrameSize;
		when EmitDebugComments_LocalDefs:
			EmitComment(@strcpy4(@Buff, "iDEF_LOCAL: ",@Char[Node[P].Value]," ",@str(Local[i].Value)));

		Code_(Node[P].pLeft, @Buff);

	case iASSIGN:
		return Code_ASSIGN(P, @Buff);

	case iINLINE:
		Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16, #0)));

	case iPUSH:
		Code_PUSH(P, @Buff);
	case iRETURN:
		return Code_RETURN(P, @Buff);
	case iSELECT:
		return Code_SELECT(P, @Buff);
	case iSWITCH:
		return Code_SWITCH(P, @Buff);
	case iWHILE:
		return Code_WHILE(P, @Buff);
	case iREPEAT:
		return Code_REPEAT(P, @Buff);
	case iCONTINUE:
		return Code_CONTINUE(P, @Buff);
	case iEXIT:
		return Code_EXIT(P, @Buff);
	case iEMPTY, iVIRTUAL_JUMP:
		pass;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:switch

	return nDICT;
end

word Code(word P)
	char Buff[nBUFF];
	return Code_(P, @Buff);
end

/*****************************************************************************/

void EmitFunctionPrologue(char @Buff; FunctionContext @FnCtx)
	if OmitRedundantFramePointer & FnCtx.ParamFrameSize == 0 & FnCtx.StackSize == 0 then
		FnCtx.FramePointer = false;
	else
		FnCtx.FramePointer = true;
	end

	if FnCtx.FramePointer then
		/*
			enter 1FEh, 0        - c8 fe 01 00
			push  ebp            - 55
			mov   ebp, esp       - 89 e5
			sub   esp, 07Eh      - 83 ec 7e
			sub   esp, 0FEh      - 81 ec fe 00 00 00
			enter is always 4 bytes, with 0FFFFh is the maximum possible value
			sub esp, num is 3 bytes for signed byte operand, 6 bytes otherwise
		*/
		select
		case FnCtx.StackSize == 0:
			Emit("push    EBP");
			Emit("mov     EBP,  ESP");
		case EmitEnterInstruction & (FnCtx.StackSize <= 0xFFFF):
			Emit(@strcpy3(@Buff,"enter   ",@str(FnCtx.StackSize), ", 0"));
		default:
			Emit("push    EBP");
			Emit("mov     EBP,  ESP");
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(FnCtx.StackSize)));
		end:select
	end:if
end

void EmitFunctionEpilogue(char @Buff; FunctionContext @FnCtx)
	if FnCtx.FramePointer then
		/*
			leave            - c9
			pop    ebp       - 5d
			mov    esp, ebp  - 89 ec
		*/
		select
		case FnCtx.StackSize == 0:
			Emit("pop     EBP");
		case EmitLeaveInstruction:
			Emit("leave");
		default:
			Emit("mov     ESP,  EBP");
			Emit("pop     EBP");
		end:select
	end:if

	if FnCtx.ParamFrameSize > 0 then
		Emit(@strcpy2(@Buff,"ret     ",@str(FnCtx.ParamFrameSize)));
	else
		Emit("ret");
	end:if
end

/*****************************************************************************/

word Assign_ParamLabels(word pFunc)
	word Result = 0;
	word pARGS = Func_GetArgs(pFunc);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = Result + 8;
		Result = Result + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while
	return Result;
end

word pReturnVoid = nNODE;

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	strcat(@Buff, @DictGetName(I));
	if Dict[I].Sub == SUBCLASS.sSTART_FUNC then
		strcat(@Buff, "<entry>");
	end:if
	strcat(@Buff," ##");
	LABEL L; L.Value = Dict[I].Label;
	EmitLabelWithComment(@L, @Buff);

	FnCtx.pFunc = I;
	FnCtx.ParamFrameSize = Assign_ParamLabels(FnCtx.pFunc);
	FnCtx.AllocatedFrameSize = 0;
	FnCtx.StackSize = Dict[I].StackSize;

	PHO_InvalidateRegs();

	EmitFunctionPrologue(@Buff, @FnCtx);

	if Dict[I].Sub == SUBCLASS.sSTART_FUNC then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == CLASS.cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == false then
					Code_(Dict[J].pNode, @Buff);
				end:if
			end:if

			inc J;
		end:while
	end:if

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  pType = st_void;
	while P < nNODE do
		pType = Code_(P, @Buff);
		when pType == st_noreturn:
			exit;
		P = Node[P].pRight;
	end

	if pType != st_noreturn then
		if pReturnVoid == nNODE then
			pReturnVoid = Peek();
			Node[pReturnVoid].ID = iRETURN;
		end
		Code_(pReturnVoid, @Buff);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

void EmitFunctions(char @Buff)
	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == CLASS.cFUNC & Dict[I].Sub != SUBCLASS.sSYS & Dict[I].Used != 0:
				if Dict[I].Sub == SUBCLASS.sSTART_FUNC then
					EntryLabel = Dict[I].Label;
					EmitEntrySymbol(@Buff);
				end:if
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when EntryLabel == 0:
		StopInternalCodegen(__FILE__, __LINE__);
end

/*****************************************************************************/

void EmitSection_Code(char @Buff)
	RegChoiceOrder[0] = RegA;
	RegChoiceOrder[1] = RegD;
	RegChoiceOrder[2] = RegC;
	RegChoiceOrder[3] = RegB;

	EmitStringNL("");
	EmitCodeSectionStart(@Buff);
	if !RODataEnabled then
		EmitROData();
	end:if
	EmitFunctions(@Buff);
	EmitCodeSectionEnd(@Buff);
end

/*****************************************************************************/

void EmitSection_ROData(char @Buff)
	if RODataEnabled then
		EmitStringNL("");
		EmitRODataSectionStart(@Buff);
		EmitROData();
		EmitRODataSectionEnd(@Buff);
	end:if
end

/*****************************************************************************/

end:namespace

alias EmitSection_ROData = CodeEmitter.EmitSection_ROData;
alias EmitSection_Code = CodeEmitter.EmitSection_Code;
