
/*
	Вспомогательные функции для генерирования в листинг названий регистров, меток и т.п.
*/

/*****************************************************************************/

define RegNone 0
define RegA    1
define RegB    2
define RegC    3
define RegD    4

/*****************************************************************************/

word NativeRegSize = 4;

bool IsNativeOperandSize(word Size)
	word S = NativeRegSize;
	when Size > NativeRegSize:
		return false;
	forever do
		when S == 0:
			return false;
		when S == Size:
			return true;
		S = S / 2;
	end:forever
end

/*****************************************************************************/

/*
	Помещает в Buff обозначение регистра Reg в режиме RegMode
	RegMode:
		1 - 8 бит
		2 - 16 бит
		4 - 32 бита

	Если @Buff == NULL,
		возвращает указатель на статическую строку с именем регистра.
*/
char @CodeReg(char @Buff; word Reg; word RegMode)

	char @R = NULL;

	switch Reg of
	case RegA:
		switch RegMode of
			case 1: @R = " AL";
			case 2: @R = " AX";
			case 4: @R = "EAX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegB:
		switch RegMode of
			case 1: @R = " BL";
			case 2: @R = " BX";
			case 4: @R = "EBX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegC:
		switch RegMode of
			case 1: @R = " CL";
			case 2: @R = " CX";
			case 4: @R = "ECX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegD:
		switch RegMode of
			case 1: @R = " DL";
			case 2: @R = " DX";
			case 4: @R = "EDX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	default: StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	if @Buff != NULL then
		strcat(@Buff, @R);
		return @Buff;
	end:if

	return @R;

end

/*****************************************************************************/

/* Помещает в Buff обозначение указанной метки. */
char @CodeLabel(char @Buff; word Label)

	strcat2(@Buff, " @", @str(Dict[Label].Label));
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff обозначения регистра и преформатированного операнда. */
char @CodeRegFmt(char @Buff; word Reg1; word RegMode1; char @Fmt2)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	strcat(@Buff, @Fmt2);
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff обозначения 2-х регистров. */
char @CodeRegReg(char @Buff; word Reg1; word RegMode1; word Reg2; word RegMode2)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	CodeReg(@Buff, Reg2, RegMode2);
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff обозначения регистра и константного значения. */
char @CodeRegConst(char @Buff; word Reg1; word RegMode1; word Value)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	strcat(@Buff, @str(Value));
	return @Buff;

end

/*****************************************************************************/
/* Помещает в Buff код для операции и добавляет отступ. */
char @CodeCmd(char @Buff; char @Cmd)

	word prefix_len = strlen(@Buff);
	word cmd_len = strlen(@Cmd);

	memcpy(@Buff[prefix_len], @Cmd, cmd_len);

	while cmd_len < 8 do
		Buff[prefix_len + cmd_len] = ' ';
		inc cmd_len;
	end

	Buff[prefix_len + cmd_len] = #0;

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и преворматированного правого операнда. */
char @CodeCmdRegFmt(char @Buff; char @Cmd; word Reg1; word RegMode1; char @Fmt2)
	CodeCmd(@Buff, @Cmd);
	CodeRegFmt(@Buff, Reg1, RegMode1, @Fmt2);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и и регистра. */
char @CodeCmdRegReg(char @Buff; char @Cmd; word Reg1; word RegMode1; word Reg2; word RegMode2)
	CodeCmd(@Buff, @Cmd);
	CodeRegReg(@Buff, Reg1, RegMode1, Reg2, RegMode2);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и константы. */
char @CodeCmdRegConst(char @Buff; char @Cmd; word Reg; word RegMode; word Value)
	CodeCmd(@Buff, @Cmd);
	CodeRegConst(@Buff, Reg, RegMode, Value);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции с регистром. */
char @CodeCmdReg(char @Buff; char @Cmd; word Reg; word RegMode)
	CodeCmd(@Buff, @Cmd);
	CodeReg(@Buff, Reg, RegMode);
	return @Buff;
end

/*****************************************************************************/

char @CodePushReg(char @Buff; word Reg; word RegMode)
	return @CodeCmdReg(@Buff, "push", Reg, RegMode);
end

char @CodePopReg(char @Buff; word Reg; word RegMode)
	return @CodeCmdReg(@Buff, "pop", Reg, RegMode);
end

char @CodeXchgRegReg(char @Buff; word Reg1; word Reg2; word RegMode)
	return @CodeCmdRegReg(@Buff, "xchg", Reg1, RegMode, Reg2, RegMode);
end

/*****************************************************************************/

/* Помещает в Buff код загрузки константы в регистр. */
char @CodeLoadConstant(char @Buff; word Reg; word RegMode; word Value)
	select
	case Value == 0:
		CodeCmdRegReg(@Buff, "xor", Reg, RegMode, Reg, RegMode);
	default:
		CodeCmdRegConst(@Buff, "mov", Reg, RegMode, Value);
	end
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код загрузки метки в регистр. */
char @CodeLoadLabel(char @Buff; word Reg; word Label)

	strcat(@Buff, "mov     ");
	CodeReg(@Buff, Reg, 4);
	strcat(@Buff, ",");
	CodeLabel(@Buff, Label);

	return @Buff;
end

/*****************************************************************************/

char CodeOffsetAddenum_Buff[nBUFF];
char @CodeOffsetAddenum(int Offset)
	select
	case Offset > 0:
		strcpy2(@CodeOffsetAddenum_Buff,"+",@istr(Offset));
	case Offset < 0:
		strcpy2(@CodeOffsetAddenum_Buff,"-",@istr(-Offset));
	default:
		CodeOffsetAddenum_Buff[0] = #0;
	end:select
	return @CodeOffsetAddenum_Buff;
end

/*****************************************************************************/

/*

ID             Value Location                  LValue    Indirect
iSTRING, RO=0: [@@RWLITERALS + IX + Offset]    Yes       Yes
iSTRING, RO=1: [@@ROLITERALS + IX + Offset]    No        Yes
iDATA:         [@@DATA       + IX + Offset]    Yes       Yes
iPARM:         [EBP          + IX + Offset]    Yes       Yes
iLOCAL:        [EBP          + IX + Offset]    Yes       Yes       (Offset is negative)
iREF:          [               IX + Offset]    Yes       Yes
iREG                           IX + Offset     No        No
iCONST                              Offset     No        No
*/

struct ValueRef of
	word ID;
	word RO;
	word pType;
	int  Offset;
	word IX;
end

bool ValueRef_IsLValue(ValueRef@ vref)
	switch vref.ID of
	case iSTRING:
		when vref.RO == 0:
			return true;
		return false;
	case iDATA, iPARM, iLOCAL, iREF:
		return true;
	case iREG, iCONST:
		return false;
	default:
		StopInternal(__FILE__, __LINE__);
	end:switch
end

bool ValueRef_IsIndirect(ValueRef@ vref)
	switch vref.ID of
	case iSTRING, iDATA, iPARM, iLOCAL, iREF:
		return true;
	case iREG, iCONST:
		return false;
	default:
		StopInternal(__FILE__, __LINE__);
	end:switch
end

/*****************************************************************************/

/*
	Распаковывает из узлов iDATA, iPARM, iLOCAL и iSTRING информацию об объекте.
	Offset - смещение относительно специфичного источника.
	Напр., для iDATA - смещение от начала секции данных.
*/
void ValueRef_ExtractDataInfo(ValueRef @Ref; word P)
	word Value = Node[P].Value;

	Ref.IX = 0;
	Ref.ID = Node[P].ID;

	switch Ref.ID of
	case iDATA:
		Ref.pType  = Dict[Value].pType;
		Ref.Offset = as_signed(Dict[Value].Label);
		when Ref.Offset < 0:
			StopInternal(__FILE__, __LINE__);
		Ref.RO     = 0;

	case iPARM:
		when Dict[Value].Class != cARG:
			StopInternal(__FILE__, __LINE__);
		Ref.pType  = Dict[Value].pType;
		Ref.Offset = as_signed(Dict[Value].Label);
		Ref.RO     = 0;

	case iLOCAL:
		Ref.pType  = Local[Value].pType;
		Ref.Offset = -Local[Value].Value;
		Ref.RO     = 0;

	case iSTRING:
		Ref.pType  = Dict[Value].pType;
		Ref.Offset = as_signed(Dict[Value].Label);
		Ref.RO     = Dict[Value].RO;

	default:
		StopInternal(__FILE__, __LINE__);
	end

end

/*****************************************************************************/

void ValueRef_Apply_FIELD(ValueRef @Ref; word P)

	word F = Node[P].Value;

	when Dict[F].Class != cFIELD:
		StopInternalCodegen(__FILE__, __LINE__);

	Ref.pType = Dict[F].pType;
	int Offset = Ref.Offset + int(Dict[F].Label);
	when Offset < Ref.Offset:
		StopInternalCodegen(__FILE__, __LINE__);
	Ref.Offset = Offset;
end

/*****************************************************************************/

/*

iDATA:    [@@DATA + IX + offset]
iPARM:    [EBP    + IX + offset]
iLOCAL:   [EBP    + IX + offset]
iREF:     [         IX + offset]

*/

char @ValueRef_Code_(char @Buff; word Size; word ID; word IX; int Offset)

	char@ SizeMarker = "";
	char@ Prefix = "";

	char@ Plus_RX = "";
	char@ RX = "";

	select
	case Size == 0:
		@SizeMarker = "";
	case Size == 1:
		@SizeMarker = "byte  ";
	case Size == 2:
		@SizeMarker = "word  ";
	case Size == 4:
		@SizeMarker = "dword ";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	if IX != RegNone then
		@Plus_RX = "+";
		@RX = @CodeReg(NULL, IX, 4);
	end

	switch ID of
	case iDATA:
		@Prefix = "[@@DATA";
	case iPARM, iLOCAL:
		@Prefix = "[EBP";
	case iREF:
		when IX == RegNone:
			StopInternalCodegen(__FILE__, __LINE__);
		@Prefix = "[";
		@Plus_RX = "";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	strcat6(@Buff, @SizeMarker, @Prefix, @Plus_RX, @RX, @CodeOffsetAddenum(Offset), "]");

	return @Buff;
end

char @ValueRef_Code(char @Buff; ValueRef @Ref)
	return @ValueRef_Code_(@Buff, T_SizeOf(Ref.pType), Ref.ID, Ref.IX, Ref.Offset);
end

char @ValueRef_Code_ForLEA(char @Buff; ValueRef @Ref)
	return @ValueRef_Code_(@Buff, 0, Ref.ID, Ref.IX, Ref.Offset);
end

/*
iSTRING, RO=0: @@RWLITERALS + Offset
iSTRING, RO=1: @@ROLITERALS + Offset
iDATA:         @@DATA       + Offset
*/

char @ValueRef_Code_StaticOffset(char @Buff; ValueRef @Ref)
	char @Prefix = "";
	switch Ref.ID of
	case iDATA:
		@Prefix = "@@DATA";
	case iSTRING:
		if Ref.RO == 0 then
			@Prefix = "@@RWLITERALS";
		else
			@Prefix = "@@ROLITERALS";
		end:if
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	strcat2(@Buff, @Prefix, @CodeOffsetAddenum(Ref.Offset));
	return @Buff;
end


/*****************************************************************************/

char @CodeMemRef_Reg_Mult_Reg_Offset(char @Buff; word Size; word Reg1; word Reg2; word RegMode; word Mult; int Offset)

	char@ SizeMarker = "";
	select
	case Size == 0:
		@SizeMarker = "";
	case Size == 1:
		@SizeMarker = "byte  ";
	case Size == 2:
		@SizeMarker = "word  ";
	case Size == 4:
		@SizeMarker = "dword ";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	strcat3(@Buff, @SizeMarker, "[", @CodeReg(NULL, Reg1, RegMode));

	if Mult > 1 then
		strcat2(@Buff, "*", @str(Mult));
	end:if

	if Reg2 != RegNone then
		strcat2(@Buff, "+", @CodeReg(NULL, Reg2, RegMode));
	end:if

	select
	case Offset > 0:
		strcat3(@Buff, "+", @istr(Offset), "]");
	case Offset < 0:
		strcat3(@Buff, "-", @istr(-Offset), "]");
	default:
		strcat(@Buff, "]");
	end:select

	return @Buff;
end

/*****************************************************************************/

void Emit_IMUL_Reg_Const(word Reg; word RegMode; word Value)
	char Buff[nBUFF];
	Buff[0] = #0;

	select
	case Value==2:
		CodeCmdRegReg(@Buff, "add", Reg, RegMode, Reg, RegMode);
	case Value==4:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 2);
	case Value==8:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 3);
	case Value==16:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 4);
	case Value==32:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 5);
	case Value==64:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 6);
	case Value==128:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 7);
	case Value==256:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 8);
	case Value==512:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 9);
	case Value>1:
		CodeCmdRegConst(@Buff, "imul", Reg, RegMode, Value);
	case Value<1:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	Emit(@Buff);
end

/*****************************************************************************/

void Emit_TEST_Reg_Self(word Reg; word RegMode)
	char Buff[nBUFF];
	Buff[0] = #0;
	EmitPhoSkip(@CodeCmdRegReg(@Buff, "test", Reg, RegMode, Reg, RegMode));
end

/*****************************************************************************/

void Emit_Load_Constant(word Reg; word RegMode; word Value)
	when PHO_Try_Emit_Load_Constant(Reg, RegMode, Value):
		return;

	char Buff[nBUFF];
	Buff[0] = #0;
	Emit(@CodeLoadConstant(@Buff, Reg, RegMode, Value));
end

/*****************************************************************************/

/** Returns nonzero if INC/DEC is preferred over ADD/SUB for the given register and the compilation options.
  Returns 1 if a single INC/DEC is preferred over <ADD/SUB reg, 1>.
  Returns 2 if a couple of INC/DEC is preferred over <ADD/SUB reg, 2>.
*/
word PreferIncDec(word Reg; word RegMode)
	/* <INC AL> and <ADD AL, 1> have the same size */
	when Reg == RegA & RegMode == 1:
		return 0;

	if EmitShortCode != 0 then /* We don't care about the speed */
		word x86CodeMode = 4; /* FIXME: 4 for 32-bit code and 2 for 16-bit code */
		when RegMode == x86CodeMode:
			/* <ADD EAX, 1> takes 3 bytes and <INC EAX> takes just 1. So 2 INCs are okay, */
			return 2;
		return 1;
	end:if

	when SlowIncDec != 0: /* P4 not happy about INC/DEC. */
		/* Details: https://github.com/dotnet/runtime/issues/7697 */
		return 0;

	/* INC/DEC seems to be ok, so use it, but we aren't crazy enoght about the code size to use double INC/DEC. */
	return 1;
end

/*****************************************************************************/
