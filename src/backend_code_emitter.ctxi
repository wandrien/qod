
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */

/*
Active register.

When entering a function for generating code for an operation:

 * If fEAX == RegA, the caller expects the result to be places in RegA.
   The code may use both RegA and RegB and should return the result in RegA.

 * If fEAX == RegB, the caller expects the result to be places in RegB.
   RegA is used by the caller to store a value.
   The code either returns the result in RegB and keeps the value of RegA untouched.
   Or stores RegA on the stack, sets fEAX = RegA and return the result in RegA.
   In the latter case, the caller normally pops the value from the stack to RegB,
   and does the calculation with the swapped arguments.
*/
word fEAX;

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		_Code(P,0,0,0);
		P = Node[P].pRight;
	end
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	Code_List(P);
	Code_EndBlock(@CB);
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word pPrimary)

	char Buff [nBUFF];
	Buff[0] = #0;

	word IncID=Node[pPrimary].ID;
	if IncID==iINC | IncID==iDEC then
		fEAX=RegA;
		pPrimary = Node[pPrimary].pLeft;
	end

	word nIndx__unused;
	word pType;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(pPrimary, @pType, @nIndx__unused, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do
		Buff[0] = #0;
		select
		case P1>=nNODE:
			select
			case IncID==iINC | IncID==iDEC:
				if IX==RegB then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:if

				if IncID==iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=SizeOfType(pType);
				select
				case Size==1 | Size==4:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:select

				Emit(@CodeDataIX_offset(@Buff, Size, ID, IX, Ofs));

			case ID!=iCALL:
				word Size = SizeOfType(pType);

				select
				case Size==1 | Size==4:
					strcpy(@Buff,"mov     ");
					CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);
				default:
					strcpy(@Buff,"lea     EDI,  ");
					CodeDataIX_offset(@Buff, 0, ID, IX, Ofs);
				end:select

				select
				case fEAX!=RegA:
					select
					case Size==1:
						Emit(@strcat(@Buff,", AL"));
					case Size==4:
						Emit(@strcat(@Buff,", EAX"));

					default:
						Emit("mov     ESI,  EAX");
						Emit(@Buff);
					end:select

				case IX==RegA:
					select
					case Size==1:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", BL"));
					case Size==4:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", EBX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select

				case IX==RegB:
					select
					case Size==1:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", AL"));
					case Size==4:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", EAX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select
				end:select

				if Size!=1 & Size!=4 then
					Emit("cld");
					Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
					Emit("rep     movsb");
				end:if
			end:select

			exit;

		case Node[P1].ID==iLOAD:

			if IX==RegNone & ID==iCALL then
				return pType;
			end:if

			word Size = SizeOfType(pType);

			select
			case Size==1 | Size==4:
				strcpy3(@Buff, "mov     ", @CodeReg(NULL, fEAX, Size), ",  ");
				CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);
			default:
				strcpy3(@Buff, "lea     ", @CodeReg(NULL, fEAX, 4), ",  ");
				CodeDataIX_offset(@Buff, 0, ID, IX, Ofs);
			end:select

			Emit(@Buff);

			return pType;

		case Node[P1].ID==iLPTR:
			if fEAX!=RegA | IX==RegB then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			end:if

			if IX!=RegNone then
				select
				case ID==iDATA:
					Emit(@strcpy2(@Buff,"add     EAX,  @@DATA+",@str(Ofs)));
				case ID==iPARM:
					Emit(@strcpy3(@Buff,"lea     EAX,  [EBP+EAX+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcpy3(@Buff,"lea     EAX,  [EBP+EAX-",@str(Ofs),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy3(@Buff,"add     EAX,  ", @s,@str(Ofs)));
				case ID==iREF & Ofs!=0:
					Emit(@strcpy2(@Buff,"add     EAX,  ",@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcpy2(@Buff,"mov     EAX,  @@DATA+",@str(Ofs)));
				case ID==iPARM:
					Emit(@strcpy3(@Buff,"lea     EAX,  [EBP+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcpy3(@Buff,"lea     EAX,  [EBP-",@str(Ofs),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy3(@Buff,"mov     EAX,  ", @s,@str(Ofs)));
				case ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			return nDICT;

		case Node[P1].ID==iCALL:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub==sSYS then
				Emit(@strcpy3(@Buff,"call   [@",@str(Dict[Node[P1].Value].Label),"]"));
			else
				EmitLine(0,
					@strcpy2(@Buff,"call    @",@str(Dict[Node[P1].Value].Label)),
					@DictGetName(Node[P1].Value)
					);
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID==iCALL2:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit("call    EAX");

			pType=Dict[Node[P1].Value].pType;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID==iINDEX:

			word  C   = 0;
			word  N   = 0;
			word  IX1 = RegNone;
			word fIX  = 1;
			do
				if Node[Node[P1].pLeft].ID==iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					select
					case IX1==RegB:
						if fEAX!=RegA then
							if IX!=0 then
								StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
							end:if

							fEAX=RegA;
						else
							if IX!=RegA then
								StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
							end:if

							fIX=0;
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						_Code(Node[P1].pLeft,0,0,0);

						Emit("pop     EBX");
						Emit(@strcpy2(@Buff,"imul    EBX,  ",@str(N*Node[P1].Value)));
						Emit("add     EAX,  EBX");

						IX1=RegA;

					case IX1==RegA:
						if fEAX!=RegA | IX!=RegNone then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							Emit("pop     EBX");
							Emit(@strcpy2(@Buff,"imul    EBX,  ",@str(N*Node[P1].Value)));
						else
							Emit(@strcpy2(@Buff,"imul    EAX,  ",@str(N*Node[P1].Value)));
						end:if

						Emit("add     EAX,  EBX");

						fEAX=RegA;

					case IX==RegB:
						if fEAX==RegA then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						fEAX=RegA;
						fIX =0;

						_Code(Node[P1].pLeft,0,0,0);

						IX1=RegA;

					case IX==RegA:
						if fEAX!=RegA then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end:if

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							fIX=0;
							IX1=RegA;
						else
							IX1=RegB;
						end:if

						fEAX=RegA;

					default:
						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							IX1=RegA;
						else
							IX1=RegB;
						end:if
					end:select

					C=C*Node[P1].Value;
					N=1;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

			if IX1!=RegNone then
				Size = Size * N;
				Emit_IMUL_Reg_Const(IX1, 4, Size);

				if IX!=RegNone then
					select
					case IX1==RegB:
						if IX!=RegNone | fIX==0 then
							StopInternalCodegen(__FILE__, __LINE__);
						end:if

						Emit("add     EAX,  EBX");

					case IX1==RegA:
						if fIX!=0 then
							StopInternalCodegen(__FILE__, __LINE__);
						end

						Emit("pop     EBX");
						Emit("add     EAX,  EBX");

						IX=RegA;

					default:
						StopInternalCodegen(__FILE__, __LINE__);
					end:select
				else
					IX=IX1;
				end:if
			end:if

		case Node[P1].ID==iADDR:
			if T_IsPtr(pType) == 0 then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			end:if

			pType = T_DerefPtr(pType);

			if Node[P1].pLeft<nNODE then
				word Size = SizeOfType(pType);

				select
				case IX==RegB:
					if fEAX!=RegA then
						Emit("push    EAX");
					end:if

					Emit("xchg    EAX,  EBX");
					IX  =RegA;
					fEAX=RegB;

				case IX==RegA:
					fEAX=RegB;
				end:select

				_Code(Node[P1].pLeft,0,0,0);

				Emit_IMUL_Reg_Const(fEAX, 4, Size);
				if fEAX==RegA then
					if IX!=RegNone then
						Emit("pop     EBX");
						IX=RegB;
					end:if
					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX==RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=RegNone then
				char RX[4];
				if IX==RegA then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end:if

				select
				case ID==iDATA:
					Emit(@strcat5(@Buff,"[@@DATA+",@RX,"+",@str(Ofs),"]"));
				case ID==iPARM:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"-",@str(Ofs),"]"));
				case ID==iREF:
					Emit(@strcat5(@Buff,"[",@RX,"+",@str(Ofs),"]"));
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcat3(@Buff,"[@@DATA+",@str(Ofs),"]")); // FASM
				case ID==iPARM:
					Emit(@strcat3(@Buff,"[EBP+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat3(@Buff,"[EBP-",@str(Ofs),"]"));
				//TODO Пpовеpить!
				case ID==iCALL:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			if fEAX==RegA then
				IX=RegA;
			else
				if IX!=RegNone then
					fEAX=RegA;
				end:if

				IX=RegB;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID==iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);
			when T_IsArray(pType) != 0:
				pType = T_ArrayDeref(pType);

		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

word CodeAsMemoryOperand(char @Buff; word pPrimary)

	word ID = Node[pPrimary].ID;

	switch ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		null;
	default:
		return 0;
	end:switch

	word nIndx;
	word pType;
	word  Ofs;
	word  RO;
	ID=ExtractDataInfo(pPrimary, @pType, @nIndx, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do

		select
		case P1>=nNODE:
			return 0;

		case Node[P1].ID==iLOAD:
			word Size = SizeOfType(pType);

			select
			case Size==1 | Size==4:
				Buff[0] = #0;
				CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);
				return 1;

			default:
				return 0;
			end:select

		case Node[P1].ID==iINDEX:

			word  C   = 0;
			word  N   = 0;
			do
				if Node[Node[P1].pLeft].ID==iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					return 0;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

		case Node[P1].ID==iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);
			nIndx = T_ArrayGetSizeOr0(pType);
			when T_IsArray(pType) != 0:
				pType = T_ArrayDeref(pType);

		default:
			return 0;
		end:select

		P1=Node[P1].pRight;
	end:do

	return 0;

end

/*****************************************************************************/

word NodeCanBeEncodedAsImm(word P)
	word ID=Node[P].ID;
	switch ID of
	case iCHAR, iWORD, iINT, iNULL:
		return 1;
	default:
		return 0;
	end:switch
end

/** Return non-zero if the operands can be swapped for no cost. */
word IsOperationCommutative(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return 1;
	default:
		return 0;
	end:switch
end

/** Return non-zero if the operands can be swapped for no cost, but we should change the operation ID as well.
 Return the code of swapped operation.
*/
word IsOperationSwappable(word ID)
	switch ID of
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end


word DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return 1;
	default:
		return 0;
	end:switch
end

word DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return 1;
	default:
		return 0;
	end:switch
end

/*****************************************************************************/

word TryDropCastBeforeCmp(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	when ID < iLT | iGT < ID:
		return nNODE;

	when Node[pRight].Value > 255: /* TODO: this case should be optimized out on the semantic analysis phase */
		return nNODE;

	when Node[pLeft].ID != iCAST:
		return nNODE;

	word pTypeFrom = Node[Node[pLeft].pLeft].pType;
	word pTypeTo = Node[pLeft].pType;

	when pTypeFrom != st_char & pTypeFrom != st_byte:
		return nNODE;

	when pTypeTo != st_word:
		return nNODE;

	return Node[pLeft].pLeft;
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P; word F; word T; word M)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight) != 0:
		null;
	case NodeCanBeEncodedAsImm(pLeft) != 0:
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2=_Code(pLeft,0,0,0);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	word done = Emit_MUL_Reg_Const(fEAX, Size, RightValue);
	when done == 0:
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

define operandReg    0
define operandImm    1
define operandMemRef 2

word CodeBinOp(char @Buff; word P; word F; word T; word M)
	Buff[0] = #0;

	word ID = Node[P].ID;

	if iLT <= ID & ID <= iGT then
		/* These operations don't return the result in any register,
		instead a conditional jump is the result. So we can reset fEAX freely. */
		fEAX=RegA;
	end

	do
		word pType = TryCodeFastMult(@Buff,P,0,0,0);
		when pType < nDICT:
			return pType;
		exit;
	end:do

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if fEAX!=RegA then
			EmitLine(0, "push    EAX", "saved in CodeBinOp");
			fEAX=RegA;
		end
	end:switch

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	char BuffRightOperand[nBUFF];
	word rightOperand = operandReg;

	do
		/*
			The usual calculation scheme is:
				RegA  <- LeftOperand
				RegB  <- RightOperand
				OP    RegA,  RegB

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) != 0 then

			/*
				## Immediate constant on the right.
				Do:
					RegA  <- LeftOperand
					Op    RegA,  ImmValue
				Instead of:
					RegA  <- LeftOperand
					mov   RegB,  ImmValue
					Op    RegA,  RegB
			*/
			if NodeCanBeEncodedAsImm(pRight) != 0 then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					RegA  <- RightOperand
					Op    RegA,  ImmValue
				Instead of:
					mov   RegA,  ImmValue
					RegB  <- RightOperand
					Op    RegA,  RegB
			*/
			if IsOperationCommutative(ID) != 0 & NodeCanBeEncodedAsImm(pLeft) != 0 then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = IsOperationSwappable(ID);
			if swappedID != 0 & NodeCanBeEncodedAsImm(pLeft) != 0 then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				ID = swappedID;
				exit;
			end:if


		end:if

		if DoesOperationAllowRightMemRef(ID) != 0 then

			/*
				## Simple memory reference on the right.
				Do:
					RegA  <- LeftOperand
					Op    RegA,  [MemRef]
				Instead of:
					RegA  <- LeftOperand
					mov   RegB, [MemRef]
					Op    RegA, RegB
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight) != 0 then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					RegA  <- RightOperand
					Op    RegA,  [MemRef]
				Instead of:
					mov   RegA,  [MemRef]
					RegB  <- RightOperand
					Op    RegA,  RegB
			*/
			if IsOperationCommutative(ID) != 0 & CodeAsMemoryOperand(@BuffRightOperand, pLeft) != 0 then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = IsOperationSwappable(ID);
			if swappedID != 0 & CodeAsMemoryOperand(@BuffRightOperand, pLeft) != 0 then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				exit;
			end:if

		end:if

		exit;
	end:do

	word rightReg = RegNone;
	word fSwap=0;
	word pType;

	select
	case rightOperand == operandImm:
		word pLeft2 = TryDropCastBeforeCmp(P);
		when pLeft2 < nNODE:
			pLeft = pLeft2;

		pType=_Code(pLeft,0,0,0);

	case rightOperand == operandMemRef:
		pType=_Code(pLeft,0,0,0);

	case NodeCanBeEncodedAsImm(pLeft) != 0:
		if fEAX!=RegA then
			EmitLine(0, "push    EAX", "saved in CodeBinOp");
			fEAX=RegA;
		end

		_Code(pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(pLeft,0,0,0);
		fSwap=1;
		when fEAX != RegB:
			StopInternalCodegen(__FILE__, __LINE__);

		fEAX = RegA;
		rightReg = RegB;

	case Node[Node[pLeft].pLeft].ID==iLOAD & Node[Node[pRight].pLeft].ID!=iLOAD:
		if fEAX!=RegA then
			EmitLine(0, "push    EAX", "saved in CodeBinOp");
			fEAX=RegA;
		end

		_Code(pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(pLeft,0,0,0);
		fSwap=1;
		when fEAX != RegB:
			StopInternalCodegen(__FILE__, __LINE__);

		fEAX = RegA;
		rightReg = RegB;

	default:
		if fEAX!=RegA then
			EmitLine(0, "push    EAX", "saved in CodeBinOp");
			fEAX=RegA;
		end

		pType=_Code(pLeft,0,0,0);
		fEAX =RegB;
		_Code(pRight,0,0,0);
		if fEAX==RegA then
			EmitLine(0, "pop     EBX", "restored in CodeBinOp");
			fSwap=1;
		end

		fEAX = RegA;
		rightReg = RegB;

	end:select

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		do
			/* We can handle it by changing the operation ID */
			word swappedID = IsOperationSwappable(ID);
			if swappedID != 0 then
				ID = swappedID;
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit("xchg    EAX,  EBX");
				exit;
			end:switch

			/* If the operation is commutative, we don't care about the order. */
			when IsOperationCommutative(ID) != 0:
				exit;

			/* In other cases, swapped operands shouldn't happen. */
			StopInternalCodegen(__FILE__, __LINE__);
		end:do
	end:if


	word Size=4;
	if pType<nDICT then
		Size=SizeOfType(pType);
	end

	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = -Value;

		select
		case Value == 1 & PreferIncDec(fEAX, Size) > 0:
			Emit(@CodeCmdReg(@Buff, "inc", fEAX, Size));
			return pType;
		case Value == -1 & PreferIncDec(fEAX, Size) > 0:
			Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			return pType;
		case Value == 2 & PreferIncDec(fEAX, Size) > 1:
			Emit(@CodeCmdReg(@Buff, "inc", fEAX, Size));
			Emit(@Buff);
			return pType;
		case Value == -2 & PreferIncDec(fEAX, Size) > 1:
			Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			Emit(@Buff);
			return pType;
		end:select
	end:if

	select
	case iLT<=ID & ID<=iGT:

		select
		case rightOperand == operandImm:
			select
			case Node[pRight].Value == 0 & (ID == iEQ | ID == iNE):
				Emit(@CodeCmdRegReg(@Buff, "test", fEAX, Size, fEAX, Size));
			case Node[pRight].Value == 1 & (ID == iEQ | ID == iNE) & PreferIncDec(fEAX, Size) != 0:
				Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			default:
				Emit(@CodeCmdRegConst(@Buff, "cmp", fEAX, Size, Node[pRight].Value));
			end:select
		case rightOperand == operandMemRef:
			Emit(@CodeCmdRegFmt(@Buff, "cmp", fEAX, Size, @BuffRightOperand));
		case rightOperand == operandReg:
			Emit(@CodeCmdRegReg(@Buff, "cmp", fEAX, Size, rightReg, Size));
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end

		if T==0 then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
            end:switch

            T=F;
            F=0;
		end:if

		if T==0 | F!=0 then
			StopInternalCodegen(__FILE__, __LINE__);
		end

		char@ BranchCondition = "";
		select
		case pType==st_int:
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, T);

		return nDICT;

	case ID==iBIT_OR:
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		strcpy(@Buff,"and     ");

	case ID==iADD:
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pType) != 0:
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pType) != 0:
			strcpy(@Buff,"mul     ");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		select
		case rightOperand == operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		Emit(@Buff);
		return pType;

	case ID==iDIV:
		select
		case pType==st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
		case pType==st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
		case pType==st_int:
			Emit("cdq");
			Emit("idiv    EBX");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		return pType;

	case ID==iMOD:
		select
		case pType==st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
			Emit("xchg    AL,   AH");
		case pType==st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
			Emit("xchg    EAX,  EDX");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		return pType;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	select
	case Size==1 | Size==4:
		select
		case rightOperand == operandImm:
			/*
				XXX: The commented out code is mostly useless in the current implementation
				I can't find any expression when that condition actually triggers.
				May be useful when a full-featured register allocation strategy will be implemented.
			*/
			/*if PHO_EncodeRegContainingConst(@BuffRightOperand, Node[pRight].Value, Size) != 0 then
				CodeRegFmt(@Buff, fEAX, Size, @BuffRightOperand);
			else*/
				CodeRegConst(@Buff, fEAX, Size, Node[pRight].Value);
			/*end:if*/
		case rightOperand == operandMemRef:
			CodeRegFmt(@Buff, fEAX, Size, @BuffRightOperand);
		case rightOperand == operandReg:
			CodeRegReg(@Buff, fEAX, Size, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
		Emit(@Buff);
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	return pType;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff[nBUFF];

	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when M != 0: /* M может быть установлено только когда F или T установлены */
		when T == 0 & F == 0:
			StopInternalCodegen(__FILE__, __LINE__);

	when T != 0 & F != 0: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	if T != 0 | F != 0 then
		when NodeTypeIs(P, st_bool) == 0: /* T и F имеют смысл только для булевых вычислений. */
			StopInternalCodegen(__FILE__, __LINE__);

		switch Node[P].ID of
		case iBOOL:
			select
			case Node[P].Value == 0 & F != 0:
				EmitJumpToLabel(F);
			case Node[P].Value != 0 & T != 0:
				EmitJumpToLabel(T);
			end:select
			return st_bool;

		case iLT, iLE, iEQ, iNE, iGE, iGT:
			return CodeBinOp(@Buff, P, F, T, M);

		case iNOT:
			return Code(Node[P].pLeft, T, F, M);
		case iOR:
			Code_OR(P, F, T, M, @Buff);
			return st_bool;
		case iXOR:
			Code_XOR(P, F, T, M, @Buff);
			return st_bool;
		case iEQV:
			Code_EQV(P, F, T, M, @Buff);
			return st_bool;
		case iAND:
			Code_AND(P, F, T, M, @Buff);
			return st_bool;

		case iDATA, iPARM, iLOCAL:
			Code(P, 0, 0, 0);
			Emit(@CodeCmdRegReg(@Buff, "test", fEAX, 4, fEAX, 4));
			select
			case F != 0:
				EmitBranchToLabel("z", F);
			case T != 0:
				EmitBranchToLabel("nz", T);
			end:select

		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	else
		switch Node[P].ID of
		case iNULL:
			Emit_Load_Constant(fEAX, 4, 0);
			return Node[P].pType;

		case iBOOL:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_bool;

		case iCHAR:
			Emit_Load_Constant(fEAX, 1, Node[P].Value);
			return st_char;

		case iWORD:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_word;

		case iINT:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_int;

		case iFUNC:
			CodeLoadLabel(@Buff, fEAX, Node[P].Value);
			Emit(@Buff);
			return nDICT;

		case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
			return Code1(P);

		case iCAST:
			word pTypeFrom = Code(Node[P].pLeft, 0, 0, 0);
			word pTypeTo = Node[P].pType;

			select
			case pTypeFrom == nDICT:
				null; /* FIXME: should trigger internal error */
				//StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeFrom == st_void:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeTo == st_void:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeTo == pTypeFrom:
				null;
			case T_Equal(pTypeTo, pTypeFrom) == 1:
				null;
			case pTypeTo==st_char & pTypeFrom==st_byte:
				null;
			case pTypeTo==st_char & pTypeFrom==st_word:
				null;
			case pTypeTo==st_char & pTypeFrom==st_int:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_char:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_int:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_word:
				null;
			case pTypeTo==st_word & pTypeFrom==st_char:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_word & pTypeFrom==st_byte:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_word & pTypeFrom==st_int:
				null;
			case pTypeTo==st_int & pTypeFrom==st_char:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_int & pTypeFrom==st_byte:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_int & pTypeFrom==st_word:
				null;
			case T_IsPtr(pTypeTo) == 1 & T_IsPtr(pTypeFrom) == 1:
				null;
			case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom) == 1:
				null;
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
			return pTypeTo;

		case iBIT_NOT:
			word pType = Code(Node[P].pLeft, 0, 0, 0);
			word  Size = SizeOfType(pType);
			Emit(@CodeCmdReg(@Buff, "not", fEAX, Size));

			return pType;

		case iNEG:
			if Node[Node[P].pLeft].ID==iWORD then
				Emit_Load_Constant(fEAX, 4, -Node[Node[P].pLeft].Value);
				return st_int;
			end

			Code(Node[P].pLeft,0,0,0);

			Emit(@CodeCmdReg(@Buff, "neg", fEAX, 4));

			return st_int;

		case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
			return CodeBinOp(@Buff, P, 0, 0, 0);

		case iDEF_LOCAL:
		  if nLocal>=nLOCAL then
			StopMemory();
		  end

		  word pType = Node[P].pType;
		  word Size  = SizeOfType(pType);

		  AllocatedFrameSize =
			  AllocatedFrameSize + DefaultInStackAlign(Size);

		  Local[nLocal].pType=pType;
		  Local[nLocal].Value=AllocatedFrameSize;
		  inc   nLocal;

		  Code(Node[P].pLeft,0,0,0);

		case iASSIGN:
			P    = Node[P].pLeft;
			fEAX = RegA;
			if Node[P].pRight < nNODE then
				Code(Node[P].pRight, 0, 0, 0);
				fEAX = RegB;
			end

			Code(Node[P].pLeft, 0, 0, 0);

		case iINLINE:
			Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16)));

		case iPUSH:
			Code_PUSH(P, @Buff);
		case iRETURN:
			Code_RETURN(P, @Buff);
		case iSELECT:
			Code_SELECT(P, @Buff);
		case iSWITCH:
			Code_SWITCH(P, @Buff);
		case iWHILE:
			Code_WHILE(P, @Buff);
		case iREPEAT:
			Code_REPEAT(P, @Buff);
		case iCONTINUE:
			Code_CONTINUE(P, @Buff);
		case iEXIT:
			Code_EXIT(P, @Buff);
		case iEMPTY:
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:switch

	end:if

	return nDICT;
end

/*****************************************************************************/

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	if Dict[I].Sub != sMAIN then
		strcat(@Buff, @DictGetName(I));
	else
		strcat(@Buff, "<begin>");
	end:if
	strcat(@Buff," ##");
	EmitLine(Dict[I].Label, "", @Buff);

	word S1 = 0;

	word pARGS = FindInNamespace("args", I);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = S1 + 8;
		S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while

	PHO_InvalidateRegs();

	if EmitEnterInstruction != 0 & Dict[I].StackSize > 0 then
		Emit(@strcpy3(@Buff,"enter   ",@str(Dict[I].StackSize), ", 0"));
	else
		Emit("push    EBP");
		Emit("mov     EBP,  ESP");

		if Dict[I].StackSize > 0 then
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(Dict[I].StackSize)));
		end:if
	end:if

	if Dict[I].Sub == sMAIN then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == 0 then
					Code(Dict[J].pNode, 0, 0, 0);
				end:if
			end:if

			inc J;
		end:while
	end:if

	pFunc = I;
	ParmFrameSize = S1;
	AllocatedFrameSize = 0;

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  ID;
	while P < nNODE do
		_Code(P, 0, 0, 0);
		ID = Node[P].ID;
		P  = Node[P].pRight;
	end

	if ID!=iRETURN then
		word pRet = Peek();
		Node[pRet].ID = iRETURN;
		_Code(pRet, 0, 0, 0);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word EmitFunctions(char @Buff)
	word Start = 0;

	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				when Dict[I].Sub == sMAIN:
					Start = Dict[I].Label;
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when Start == 0:
		StopInternalCodegen(__FILE__, __LINE__);

	return Start;
end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word Start = EmitFunctions(@Buff);

	return Start;

end

/*****************************************************************************/

