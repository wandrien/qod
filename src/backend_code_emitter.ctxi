
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */
word fEAX;  /* Маркер активного регистра. (Cуть этого хака более ясна его автору - Хохлову, нежели мне. VU) */

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		_Code(P,0,0,0);
		P = Node[P].pRight;
	end
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	Code_List(P);
	Code_EndBlock(@CB);
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word pPrimary)

	char Buff [nBUFF];
	Buff[0] = #0;

	word IncID=Node[pPrimary].ID;
	if IncID=iINC | IncID=iDEC then
		fEAX=RegA;
		pPrimary = Node[pPrimary].pLeft;
	end

	word nIndx;
	word pType;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(pPrimary, @pType, @nIndx, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do
		Buff[0] = #0;
		select
		case P1>=nNODE:
			select
			case IncID=iINC | IncID=iDEC:
				if IX=RegB then
					StopAnNodeInternalCodegen(pPrimary);
				end:if

				if IncID=iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=Dict[pType].Value;
				select
				case Size=1:
					strcat(@Buff,"byte  ");     // FASM
				case Size=4:
					strcat(@Buff,"dword ");     // FASM
				default:
					StopAnNodeInternalCodegen(pPrimary);
				end:select

				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));

			case ID!=iCALL:
				word Size = SizeOfType(pType, 0);

				select
				case Size=1:
					strcpy(@Buff,"mov     byte  ");     // FASM
				case Size=4:
					strcpy(@Buff,"mov     dword ");     // FASM
				default:
					strcpy(@Buff,"lea     EDI,  ");
				end:select

				CodeDataIX_offset(@Buff, ID, IX, Ofs);

				select
				case fEAX!=RegA:
					select
					case Size=1:
						Emit(@strcat(@Buff,", AL"));
					case Size=4:
						Emit(@strcat(@Buff,", EAX"));

					default:
						Emit("mov     ESI,  EAX");
						Emit(@Buff);
					end:select

				case IX=RegA:
					select
					case Size=1:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", BL"));
					case Size=4:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", EBX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select

				case IX=RegB:
					select
					case Size=1:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", AL"));
					case Size=4:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", EAX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select
				end:select

				if Size!=1 & Size!=4 then
					Emit("cld");
					Emit(@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
					Emit("rep     movsb");
				end:if
			end:select

			exit;

		case Node[P1].ID=iLOAD:
			word Size = SizeOfType(pType, 0);

			select
			case Size=1:
				if fEAX=RegA then
					strcpy(@Buff,"mov     AL,   byte  ");     // FASM
				else
					strcpy(@Buff,"mov     BL,   byte  ");     // FASM
				end:if

			case Size=4:
				if fEAX=RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if

			default:
				if fEAX=RegA then
					strcpy(@Buff,"lea     EAX,  ");
				else
					strcpy(@Buff,"lea     EBX,  ");
				end:if
			end:select

			if IX=RegNone & ID=iCALL then
				null;
			else
				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));
			end:if

			return pType;

		case Node[P1].ID=iLPTR:
			if fEAX!=RegA | IX=RegB then
				StopAnNodeInternalCodegen(P1);
			end:if

			if IX!=RegNone then
				select
				case ID=iDATA:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					char @s = "@@ROLITERALS+";
					when RO = 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"add     EAX,  "), @s),@str(Ofs)));
				case ID=iREF & Ofs!=0:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopAnNodeInternalCodegen(P1);
				end:select
			else
				select
				case ID=iDATA:
					Emit(@strcat(@strcpy(@Buff,"mov     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					char @s = "@@ROLITERALS+";
					when RO = 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"mov     EAX,  "), @s),@str(Ofs)));
				case ID!=iCALL:
					StopAnNodeInternalCodegen(P1);
				end:select
			end:if

			return nDICT;

		case Node[P1].ID=iCALL:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub=sSYS then
				Emit(@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Node[P1].Value].Value)),"]"));
			else
				Emit(@strcat(@strcpy(@Buff,"call    @"),@str(Dict[Node[P1].Value].Value)));
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID=iCALL2:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit("call    EAX");

			pType=Dict[Node[P1].Value].pType;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID=iINDEX:

			word  C   = 0;
			word  N   = 0;
			word  IX1 = RegNone;
			word fIX  = 1;
			do
				if Node[Node[P1].pLeft].ID=iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					select
					case IX1=RegB:
						if fEAX!=RegA then
							if IX!=0 then
								StopAnNodeInternalCodegen(P1);
							end:if

							fEAX=RegA;
						else
							if IX!=RegA then
								StopAnNodeInternalCodegen(P1);
							end:if

							fIX=0;
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						_Code(Node[P1].pLeft,0,0,0);

						Emit("pop     EBX");
						Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						Emit("add     EAX,  EBX");

						IX1=RegA;

					case IX1=RegA:
						if fEAX!=RegA | IX!=RegNone then
							StopAnNodeInternalCodegen(P1);
						end

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							Emit("pop     EBX");
							Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						else
							Emit(@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(N*Node[P1].Value)));
						end:if

						Emit("add     EAX,  EBX");

						fEAX=RegA;

					case IX=RegB:
						if fEAX=RegA then
							StopAnNodeInternalCodegen(P1);
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						fEAX=RegA;
						fIX =0;

						_Code(Node[P1].pLeft,0,0,0);

						IX1=RegA;

					case IX=RegA:
						if fEAX!=RegA then
							StopAnNodeInternalCodegen(P1);
						end:if

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							fIX=0;
							IX1=RegA;
						else
							IX1=RegB;
						end:if

						fEAX=RegA;

					default:
						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							IX1=RegA;
						else
							IX1=RegB;
						end:if
					end:select

					C=C*Node[P1].Value;
					N=1;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType, 0);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

			if IX1!=RegNone then
				Size = Size * N;
				Emit_IMUL_Reg_Const(IX1, 4, Size);

				if IX!=RegNone then
					select
					case IX1=RegB:
						if IX!=RegNone | fIX=0 then
							StopInternalCodegen();
						end:if

						Emit("add     EAX,  EBX");

					case IX1=RegA:
						if fIX!=0 then
							StopInternalCodegen();
						end

						Emit("pop     EBX");
						Emit("add     EAX,  EBX");

						IX=RegA;

					default:
						StopInternalCodegen();
					end:select
				else
					IX=IX1;
				end:if
			end:if

		case Node[P1].ID=iADDR:
			if T_IsPtr(pType) = 0 then
				StopAnNodeInternalCodegen(P1);
			end:if

			pType = T_DerefPtr(pType);

			if Node[P1].pLeft<nNODE then
				word Size = SizeOfType(pType, 0);

				select
				case IX=RegB:
					if fEAX!=RegA then
						Emit("push    EAX");
					end:if

					Emit("xchg    EAX,  EBX");
					IX  =RegA;
					fEAX=RegB;

				case IX=RegA:
					fEAX=RegB;
				end:select

				_Code(Node[P1].pLeft,0,0,0);

				Emit_IMUL_Reg_Const(fEAX, 4, Size);
				if fEAX=RegA then
					if IX!=RegNone then
						Emit("pop     EBX");
						IX=RegB;
					end:if
					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX=RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=RegNone then
				char RX[4];
				if IX=RegA then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end:if

				select
				case ID=iDATA:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"-"),@str(Ofs)),"]"));
				case ID=iREF:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"["),@RX),"+"),@str(Ofs)),"]"));
				default:
					StopAnNodeInternalCodegen(P1);
				end:select
			else
				select
				case ID=iDATA:
					Emit(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs)),"]")); // FASM
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs)),"]"));
				//TODO Пpовеpить!
				case ID=iCALL:
					null;
				default:
					StopAnNodeInternalCodegen(P1);
				end:select
			end:if

			if fEAX=RegA then
				IX=RegA;
			else
				if IX!=RegNone then
					fEAX=RegA;
				end:if

				IX=RegB;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID=iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);

		default:
			StopAnNodeInternalCodegen(P1);
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

word CodeBinOp(char @Buff; word P; word F; word T; word M)
	Buff[0] = #0;

	if iLT<=Node[P].ID & Node[P].ID<=iGT then
		fEAX=RegA;
	end

	if fEAX!=RegA then
		Emit("push    EAX");
		fEAX=RegA;
	end

	word fSwap=0;
	word pType;
	select
	case Node[Node[P].pRight].ID=iCHAR | Node[Node[P].pRight].ID=iWORD | Node[Node[P].pRight].ID=iINT:
		pType=_Code(Node[P].pLeft,0,0,0);
		fSwap=2;

	case Node[Node[P].pLeft].ID=iCHAR | Node[Node[P].pLeft].ID=iWORD | Node[Node[P].pLeft].ID=iINT:
		_Code(Node[P].pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(Node[P].pLeft,0,0,0);
		fSwap=1;

	case Node[Node[Node[P].pLeft].pLeft].ID=iLOAD:
		_Code(Node[P].pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(Node[P].pLeft,0,0,0);
		fSwap=1;

	default:
		pType=_Code(Node[P].pLeft,0,0,0);
		fEAX =RegB;
		_Code(Node[P].pRight,0,0,0);
		if fEAX=RegA then
			Emit("pop     EBX");
			fSwap=1;
		end
	end:select

	word ID=Node[P].ID;
	select
	case fSwap=1:
		switch ID of
		case iLT: ID=iGT;
		case iLE: ID=iGE;
		case iGE: ID=iLE;
		case iGT: ID=iLT;

		case iSUB, iDIV, iMOD:
              Emit("xchg    EAX,  EBX");
		end:switch

	case fSwap=2:
		switch ID of
		case iMUL, iDIV, iMOD:
			fEAX =RegB;
			_Code(Node[P].pRight,0,0,0);
		end:switch
	end:select

	fEAX=RegA;

	word Size=4;
	if pType<nDICT then
		Size=Dict[pType].Value;
	end

	select
	case iLT<=ID & ID<=iGT:
		select
		case Size=1:
			select
			case fSwap=2:
				Emit(@strcat(@strcpy(@Buff,"cmp     AL,   "),@str(Node[Node[P].pRight].Value)));
			default:
				Emit("cmp     AL,   BL");
			end

		case Size=4:
			select
			case fSwap=2:
				Emit(@strcat(@strcpy(@Buff,"cmp     EAX,  "),@str(Node[Node[P].pRight].Value)));
			default:
				Emit("cmp     EAX,  EBX");
			end

		default:
			StopInternalCodegen();
		end:select

		if T=0 then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen();
            end:switch

            T=F;
            F=0;
		end:if

		if T=0 | F!=0 then
			StopInternalCodegen();
		end

		char@ BranchCondition = "";
		select
		case pType=st_int:
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			default:
                  StopInternalCodegen();
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
                  StopInternalCodegen();
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, T);

		return nDICT;

	case ID=iBIT_OR:
		strcpy(@Buff,"or      ");

	case ID=iBIT_XOR:
		strcpy(@Buff,"xor     ");

	case ID=iBIT_AND:
		strcpy(@Buff,"and     ");

	case ID=iADD:
		strcpy(@Buff,"add     ");

	case ID=iSUB:
		strcpy(@Buff,"sub     ");

	case ID=iMUL:
		select
		case pType=st_byte:
			Emit("mul     BL");
		case pType=st_word:
			Emit("mul     EBX");
		case pType=st_int:
			Emit("imul    EBX");
		default:
			StopInternalCodegen();
		end:select

		return pType;

	case ID=iDIV:
		select
		case pType=st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
		case pType=st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
		case pType=st_int:
			Emit("xor     EDX,  EDX");
			Emit("idiv    EBX");
		default:
			StopInternalCodegen();
		end:select

		return pType;

	case ID=iMOD:
		select
		case pType=st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
			Emit("xchg    AL,   AH");
		case pType=st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
			Emit("xchg    EAX,  EDX");
		default:
			StopInternalCodegen();
		end:select

		return pType;

	default:
		StopInternalCodegen();
	end:select

	select
	case Size=1:
		select
		case fSwap=2:
			Emit(@strcat(@strcat(@Buff,"AL,   "),@str(Node[Node[P].pRight].Value)));
		default:
			Emit(@strcat(@Buff,"AL,   BL"));
		end:select

	case Size=4:
		select
		case fSwap=2:
			Emit(@strcat(@strcat(@Buff,"EAX,  "),@str(Node[Node[P].pRight].Value)));
		default:
			Emit(@strcat(@Buff,"EAX,  EBX"));
		end:select

	default:
		StopInternalCodegen();
	end:select

	return pType;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff[nBUFF];

	Buff[0] = #0;

	when M != 0: /* M может быть установлено только когда F или T установлены */
		when T = 0 & F = 0:
			StopInternalCodegen();

	when T != 0 & F != 0: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen();

	when T != 0 | F != 0: /* T и F имеют смысл только для булевых вычислений. */
		when NodeTypeIs(P, st_bool) = 0:
			StopInternalCodegen();

	switch Node[P].ID of
	case iNULL:
		Emit_Load_Constant(fEAX, 4, 0);
		return nDICT;

	case iBOOL:
		select
		case T = 0 & F = 0:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
		case Node[P].Value = 0 & F != 0:
			EmitJumpToLabel(F);
		case Node[P].Value != 0 & T != 0:
			EmitJumpToLabel(T);
		end:select
		return st_bool;

	case iCHAR:
		Emit_Load_Constant(fEAX, 1, Node[P].Value);
		return st_char;

	case iWORD:
		Emit_Load_Constant(fEAX, 4, Node[P].Value);
		return st_word;

	case iINT:
		Emit_Load_Constant(fEAX, 4, Node[P].Value);
		return st_int;

	case iFUNC:
		CodeLoadLabel(@Buff, fEAX, Node[P].Value);
		Emit(@Buff);
		return nDICT;

///////////////////////////////////////////////////////////////////////////////

	case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
		return Code1(P);

///////////////////////////////////////////////////////////////////////////////

	case iCAST:
		word pType = Code(Node[Node[P].pLeft].pLeft, 0, 0, 0);
		select
		case Node[P].Value=st_char & pType=st_byte:
			null;
		case Node[P].Value=st_char & pType=st_word:
			null;
		case Node[P].Value=st_char & pType=st_int:
			null;
		case Node[P].Value=st_byte & pType=st_char:
			null;
		case Node[P].Value=st_word & pType=st_char:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_word & pType=st_byte:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_char:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_byte:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_word:
			null;
		default:
			StopInternalCodegen();
		end
		return  Node[P].Value;

///////////////////////////////////////////////////////////////////////////////

	case iNOT:
		word pType = Code(Node[P].pLeft, 0, 0, 0);
		word  Size = Dict[pType].Value;
		Emit(@CodeCmdReg(@Buff, "not", fEAX, Size));

		return pType;

///////////////////////////////////////////////////////////////////////////////

	case iNEG:
		if Node[Node[P].pLeft].ID=iWORD then
			Emit_Load_Constant(fEAX, 4, -Node[Node[P].pLeft].Value);
			return st_int;
		end

		Code(Node[P].pLeft,0,0,0);

		Emit(@CodeCmdReg(@Buff, "neg", fEAX, 4));

		return st_int;

///////////////////////////////////////////////////////////////////////////////

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
		return CodeBinOp(@Buff, P, F, T, M);

///////////////////////////////////////////////////////////////////////////////

    case iDEF_LOCAL:
      if nLocal>=nLOCAL then
        StopMemory();
      end

      word pType = Node[P].pType;
      word Size  = SizeOfType(pType, 0);

      AllocatedFrameSize =
          AllocatedFrameSize + DefaultInStackAlign(Node[Node[P].pLeft].Value*Size);

      Local[nLocal].pType=pType;
      Local[nLocal].Value=AllocatedFrameSize;
      inc   nLocal;

      Code(Node[P].pLeft,0,0,0);
///////////////////////////////////////////////////////////////////////////////

	case iASSIGN:
		P    = Node[P].pLeft;
		fEAX = RegA;
		if Node[P].pRight < nNODE then
			Code(Node[P].pRight, 0, 0, 0);
			fEAX = RegB;
		end

		Code(Node[P].pLeft, 0, 0, 0);

///////////////////////////////////////////////////////////////////////////////

	case iINLINE:
		Emit(@strcat(@strcpy(@Buff,"db      0x"),@str2(Node[P].Value,16)));

///////////////////////////////////////////////////////////////////////////////
	case iOR:
		Code_OR(P, F, T, M, @Buff);
	case iXOR:
		Code_XOR(P, F, T, M, @Buff);
	case iEQV:
		Code_EQV(P, F, T, M, @Buff);
	case iAND:
		Code_AND(P, F, T, M, @Buff);
///////////////////////////////////////////////////////////////////////////////
	case iPUSH:
		Code_PUSH(P, F, T, M, @Buff);
	case iRETURN:
		Code_RETURN(P, F, T, M, @Buff);
///////////////////////////////////////////////////////////////////////////////
	case iSELECT:
		Code_SELECT(P, F, T, M, @Buff);
	case iSWITCH:
		Code_SWITCH(P, F, T, M, @Buff);
	case iWHILE:
		Code_WHILE(P, F, T, M, @Buff);
	case iREPEAT:
		Code_REPEAT(P, F, T, M, @Buff);
	case iCONTINUE:
		Code_CONTINUE(P, F, T, M, @Buff);
	case iEXIT:
		Code_EXIT(P, F, T, M, @Buff);
	case iEMPTY:
		null;
	default:
		StopInternalCodegen();
	end:switch

	return nDICT;
end

/*****************************************************************************/

/* Формирует листинг кода функций. */
word EmitFunctions(char @Buff)

	word S;

	word pRet = Peek();
	Node[pRet].ID = iRETURN;


	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class = cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				EmitStringNL("");
				strcpy(@Buff,"       ;;");
				if Dict[I].Sub != sMAIN then
					strcat(@Buff, @DictGetName(I));
				else
					strcat(@Buff, "begin");
					S = Dict[I].Value;
				end:if
				EmitLine(Dict[I].Value, @Buff);

				word S1 = 0;

				word pARGS = FindInNamespace("args", I);
				when pARGS >= nDICT:
					StopInternalCodegen();
				word pARG = Dict[pARGS].pFirst;
				while pARG < nDICT do
					Dict[pARG].Value = S1 + 8;
					S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType, Dict[pARG].nIndx));
					pARG = Dict[pARG].pNext;
				end:while

				PHO_InvalidateRegs();

				if EmitEnterInstruction != 0 & Dict[I].Stack > 0 then
					Emit(@strcat(@strcat(@strcpy(@Buff,"enter   "),@str(Dict[I].Stack)), ", 0"));
				else
					Emit("push    EBP");
					Emit("mov     EBP,  ESP");

					if Dict[I].Stack > 0 then
						Emit(@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(Dict[I].Stack)));
					end:if
				end:if

				if Dict[I].Sub = sMAIN then
					word  J = 0;
					while J < nDict do
						if Dict[J].Class = cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
							if Node[Dict[J].pNode].ID != iASSIGN then
								StopInternalCodegen();
							end:if
							if StaticDataIsZeroed = 0
							 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) = 0 then
								Code(Dict[J].pNode, 0, 0, 0);
							end:if
						end:if

						inc J;
					end:while
				end:if

				pFunc = I;
				ParmFrameSize = S1;
				AllocatedFrameSize = 0;

				CODEBLOCK CB;
				Code_BeginBlock(@CB);

				word  P = Dict[I].pNode;
				word  ID;
				while P < nNODE do
					_Code(P, 0, 0, 0);
					ID = Node[P].ID;
					P  = Node[P].pRight;
				end

				if ID!=iRETURN then
					_Code(pRet, 0, 0, 0);
				end

				Code_EndBlock(@CB);

		end // of select

		inc I;
	end // of while

	return S;

end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat = tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat = tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen();
	end

	EmitROData();

	word S = EmitFunctions(@Buff);

	return S;

end

/*****************************************************************************/

