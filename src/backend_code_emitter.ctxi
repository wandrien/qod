
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */

/*
Active register.

When entering a function for generating code for an operation:

 * If Reg_TARGET == RegA, the caller expects the result to be places in RegA.
   The code may use both RegA and RegB and should return the result in RegA.

 * If Reg_TARGET == RegB, the caller expects the result to be placed in RegB.
   RegA is used by the caller to store a value.
   The code either returns the result in RegB and keeps the value of RegA untouched.
   Or stores RegA on the stack, sets Reg_TARGET = RegA and return the result in RegA.
   In the latter case, the caller normally pops the value from the stack to RegB,
   and does the calculation with the swapped arguments.
*/

word Reg_TARGET;
word Reg_ALT_TARGET = RegA;
word RegAllocation[5];

void RegAllocate(word Reg)
	when RegAllocation[Reg] != 0:
		StopInternalCodegen(__FILE__, __LINE__);
	inc RegAllocation[Reg];
end

void RegFree(word Reg)
	when RegAllocation[Reg] != 1:
		StopInternalCodegen(__FILE__, __LINE__);
	dec RegAllocation[Reg];
end

/*****************************************************************************/

word ChooseEmptyReg()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;

	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;

	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;

	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;

	return RegNone;
end

word ChooseEmptyReg2()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;

	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;

	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;

	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;


	return RegNone;
end


/*****************************************************************************/

word Code(word P);
word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M);

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		word pType = Code(P);
		when pType == st_noreturn:
			return st_noreturn;
		P = Node[P].pRight;
	end
	return st_void;
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	word pType = Code_List(P);
	Code_EndBlock(@CB);
	return pType;
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

void Code_ADDR(char @Buff; word P1; ValueRef @Ref)
	if !T_IsPtr(Ref.pType) then
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:if

	Ref.pType = T_DerefPtr(Ref.pType);
	word Size = T_SizeOf(Ref.pType);

	word pLeft = Node[P1].pLeft;

	if pLeft < nNODE & NodeIsLiteralWord(pLeft) & Node[pLeft].Value == 0 then
		pLeft = nNODE;
	end:if

	if pLeft < nNODE then
		select
		case Ref.IX == RegNone:
			null;
		case Ref.IX == Reg_ALT_TARGET:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		case Reg_ALT_TARGET != RegNone:
			if Reg_TARGET != Reg_ALT_TARGET then
				EmitWithExprComment(@CodePushReg(@Buff, Reg_ALT_TARGET, 4),
					"saved in Code_ADDR");
			end:if
			Emit(@CodeXchgRegReg(@Buff, Ref.IX, Reg_ALT_TARGET, 4));
			Reg_TARGET = Ref.IX;
			Ref.IX = Reg_ALT_TARGET;
		default:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		Code(pLeft);
		Emit_IMUL_Reg_Const(Reg_TARGET, 4, Size);

		if Reg_TARGET == Reg_ALT_TARGET then
			if Ref.IX != RegNone then
				Ref.IX = RegB;
				EmitWithExprComment(@CodePopReg(@Buff, Ref.IX, 4), "restored in Code_ADDR");
			end:if
		end:if
	end:if

	char @TX = @CodeReg(NULL, Reg_TARGET, 4);

	if pLeft < nNODE then
		strcpy3(@Buff,"add     ",@TX,",  dword ");
	else
		strcpy3(@Buff,"mov     ",@TX,",  dword ");
	end:if

	if Ref.IX != RegNone then
		char @RX = @CodeReg(NULL, Ref.IX, 4);

		switch Ref.ID of
		case iDATA:
			Emit(@strcat5(@Buff,"[@@DATA+",@RX,"+",@str(Ref.Offset),"]"));
		case iPARM:
			Emit(@strcat5(@Buff,"[EBP+",@RX,"+",@str(Ref.Offset),"]"));
		case iLOCAL:
			Emit(@strcat5(@Buff,"[EBP+",@RX,"-",@str(Ref.Offset),"]"));
		case iREF:
			Emit(@strcat5(@Buff,"[",@RX,"+",@str(Ref.Offset),"]"));
		case iREG:
			if Reg_TARGET != Ref.IX then
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  dword ");
					strcat7(@Buff,"[",@TX,"+",@RX,"+",@str(Ref.Offset),"]");
					Emit(@Buff);
				else
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@RX));
				end:if
			end:if
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	else
		switch Ref.ID of
		case iDATA:
			Emit(@strcat3(@Buff,"[@@DATA+",@str(Ref.Offset),"]"));
		case iPARM:
			Emit(@strcat3(@Buff,"[EBP+",@str(Ref.Offset),"]"));
		case iLOCAL:
			Emit(@strcat3(@Buff,"[EBP-",@str(Ref.Offset),"]"));
		case iREG:
			Reg_TARGET = Ref.IX;
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	end:if

	if Reg_TARGET == Reg_ALT_TARGET | Reg_ALT_TARGET == RegNone then
		Ref.IX = Reg_TARGET;
	else
		word Reg_TARGET_tmp = Reg_TARGET;
		if Ref.IX != RegNone then
			when (Reg_ALT_TARGET == RegNone):
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = Reg_ALT_TARGET;
		end:if

		Ref.IX = Reg_TARGET_tmp;
	end:if

	Ref.ID = iREF;
	Ref.Offset = 0;
end

/*****************************************************************************/

word CodePrimary(word pPrimary)

	char Buff [nBUFF];
	Buff[0] = #0;

	word IncID=Node[pPrimary].ID;
	if IncID==iINC | IncID==iDEC then
		Reg_TARGET=RegA;
		pPrimary = Node[pPrimary].pLeft;
	end

	ValueRef Ref;
	ValueRef_ExtractDataInfo(@Ref, pPrimary);

	word P1 = Node[pPrimary].pLeft;
	do
		Buff[0] = #0;
		select
		case P1>=nNODE:
			select
			case IncID == iINC | IncID == iDEC:
				if Ref.IX > RegA then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:if

				if IncID==iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size = T_SizeOf(Ref.pType);
				select
				case IsNativeOperandSize(Size):
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:select

				Emit(@ValueRef_Code(@Buff, @Ref));

				return st_void;

			case Ref.ID == iREG:
				return Ref.pType;

			default:
				word Size = T_SizeOf(Ref.pType);

				select
				case IsNativeOperandSize(Size):
					strcpy(@Buff,"mov     ");
					ValueRef_Code(@Buff, @Ref);

					/*when Ref.IX != Reg_TARGET & Ref.IX != RegNone:
						StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);*/

					select
					case Reg_TARGET != Reg_ALT_TARGET:
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, Reg_ALT_TARGET, Size)));

					case Ref.IX==RegA:
						EmitWithExprComment("pop     EBX", "restored in CodePrimary (STORE)");
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegB, Size)));

					case Ref.IX==RegB:
						EmitWithExprComment("pop     EAX", "restored in CodePrimary (STORE)");
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegA, Size)));
					end:select
				default:
					strcpy(@Buff,"lea     EDI,  ");
					ValueRef_Code_ForLEA(@Buff, @Ref);
					Emit(@Buff);

					if Reg_TARGET != Reg_ALT_TARGET then
						Emit(@strcpy2(@Buff,"mov     ESI,  ",@CodeReg(NULL, Reg_ALT_TARGET, 4)));
					else
						EmitWithExprComment("pop     ESI", "restored in CodePrimary (STORE)");
					end:if

					Emit("cld");
					Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
					Emit("rep     movsb");
					PHO_RegLoadConst(RegC, 0);
				end:select

				return st_void;

			end:select

			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);

		case Node[P1].ID==iLOAD:

			if Ref.ID==iREG then
				when Ref.IX != Reg_TARGET:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				return Ref.pType;
			end:if

			word Size = T_SizeOf(Ref.pType);

			select
			case IsNativeOperandSize(Size):
				strcpy3(@Buff, "mov     ", @CodeReg(NULL, Reg_TARGET, Size), ",  ");
				ValueRef_Code(@Buff, @Ref);
			default:
				strcpy3(@Buff, "lea     ", @CodeReg(NULL, Reg_TARGET, 4), ",  ");
				ValueRef_Code_ForLEA(@Buff, @Ref);
			end:select

			Emit(@Buff);

			return Ref.pType;

		case Node[P1].ID==iLPTR:
			char @TX = @CodeReg(NULL, Reg_TARGET, 4);

			if Ref.IX != RegNone then
				if Reg_TARGET != Ref.IX then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:if

				switch Ref.ID of
				case iDATA:
					Emit(@strcpy4(@Buff,"add     ",@TX,",  @@DATA+",@str(Ref.Offset)));
				case iPARM:
					Emit(@strcpy7(@Buff,"lea     ",@TX,",  [EBP+",@TX,"+",@str(Ref.Offset),"]"));
				case iLOCAL:
					Emit(@strcpy7(@Buff,"lea     ",@TX,",  [EBP+",@TX,"-",@str(Ref.Offset),"]"));
				case iSTRING:
					char @s = "@@ROLITERALS+";
					when Ref.RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy5(@Buff,"add     ",@TX,",  ", @s,@str(Ref.Offset)));
				case iREF:
					when Ref.Offset != 0:
						Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@str(Ref.Offset)));
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:switch
			else
				switch Ref.ID of
				case iDATA:
					Emit(@strcpy4(@Buff,"mov     ",@TX,",  @@DATA+",@str(Ref.Offset)));
				case iPARM:
					Emit(@strcpy5(@Buff,"lea     ",@TX,",  [EBP+",@str(Ref.Offset),"]"));
				case iLOCAL:
					Emit(@strcpy5(@Buff,"lea     ",@TX,",  [EBP-",@str(Ref.Offset),"]"));
				case iSTRING:
					char @s = "@@ROLITERALS+";
					when Ref.RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy5(@Buff,"mov     ",@TX,",  ",@s,@str(Ref.Offset)));
				case iREF:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:switch
			end:if

			return T_PtrTo(Ref.pType);

		case Node[P1].ID==iCALL:
			if Reg_ALT_TARGET == RegA & Reg_TARGET != RegA then
				EmitWithExprComment("push    EAX", "saved in CodePrimary (iCALL)");
			end:if
			Reg_TARGET = RegA;
			Reg_ALT_TARGET = RegA;

			if Node[P1].pLeft<nNODE then
				Code(Node[P1].pLeft);
			end:if

			if Dict[Node[P1].Value].Sub==sSYS then
				Emit(@strcpy3(@Buff,"call   [@",@str(Dict[Node[P1].Value].Label),"]"));
			else
				EmitLine(NULL,
					@strcpy2(@Buff,"call    @",@str(Dict[Node[P1].Value].Label)),
					@DictGetName(Node[P1].Value)
					);
			end:if

			Ref.ID = iREG;
			Ref.IX = RegA;
			Ref.Offset = 0;

		case Node[P1].ID==iCALL2:
			if Reg_ALT_TARGET == RegA & Reg_TARGET != RegA then
				EmitWithExprComment("push    EAX", "saved in CodePrimary (iCALL2)");
			end:if
			Reg_TARGET = RegA;
			Reg_ALT_TARGET = RegA;

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				Code(Node[P2].pRight);
			end:if

			Code(Node[P2].pLeft);

			Emit("call    EAX");

			Ref.pType=Dict[Node[P1].Value].pType;

			Ref.ID = iREG;
			Ref.IX = RegA;
			Ref.Offset = 0;

		case Node[P1].ID==iINDEX:
			Ref.pType = T_ArrayDeref(Ref.pType);
			word Size = T_SizeOf(Ref.pType);

			if NodeIsLiteralWord(Node[P1].pLeft) then
				word IndexingOffset = Size * Node[Node[P1].pLeft].Value;
				if Ref.ID != iLOCAL then
					Ref.Offset = Ref.Offset + IndexingOffset;
				else
					Ref.Offset = Ref.Offset - IndexingOffset;
				end
			else
				Code(Node[P1].pLeft);
				Ref.IX = Reg_TARGET;
				Emit_IMUL_Reg_Const(Ref.IX, 4, Size);
				when Reg_ALT_TARGET == RegNone:
					Reg_ALT_TARGET = Ref.IX;
			end:if

		case Node[P1].ID==iADDR:
			Code_ADDR(@Buff, P1, @Ref);

		case Node[P1].ID==iFIELD:
			ValueRef_Apply_FIELD(@Ref, P1);

		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

word Code_CAST(char @Buff; word P; word pTypeTo; word pTypeFrom; word Reg; word @Complexity)
	Complexity = 0;

	select
	case pTypeFrom == nDICT:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeFrom == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == pTypeFrom:
		null;
	case T_Equal(pTypeTo, pTypeFrom):
		null;
	case (T_IsInteger(pTypeTo) | pTypeTo == st_char)&
	     (T_IsInteger(pTypeFrom) | pTypeFrom == st_char):
		word SizeTo = T_SizeOf(pTypeTo);
		word SizeFrom = T_SizeOf(pTypeFrom);
		if SizeTo > SizeFrom then
			Complexity = 1;
			word Mask;
			switch SizeFrom of
			case 1: Mask = 0xFF;
			case 2: Mask = 0xFFFF;
			default: StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
			Emit(@CodeCmdRegConst(@Buff, "and", Reg, SizeTo, Mask));
		end:if
	case T_IsPtr(pTypeTo) & T_IsPtr(pTypeFrom):
		null;
	case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom):
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end

	return pTypeTo;
end

/*****************************************************************************/

/*
	Для оптимизации генерируемого кода, нам требуется уметь отвечать на два вопроса:
	* Может ли ветка кода быть закодирована как MemRef (и формирование данного MemRef).
	* Может ли ветка кода быть закодирована с использованием только одного регистра.

	Для веток Primary алгоритм ответа на эти вопросы содержит по большей части
	идентичный код и отличается только в деталях.
	Эта вспомогательная функция проводит анализ веток Primary для одного из указанных
	вариантов анализа в зависимости от значения параметра Query.
*/

define Query_MemoryOperand 0
define Query_SingleRegOperand 1

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query)

	switch Node[pPrimary].ID of
	case iCAST:
		word pTypeFrom = Node[Node[pPrimary].pLeft].pType;
		word pTypeTo = Node[pPrimary].pType;
		bool RecursiveResult = QueryOperandStatus(@Buff, Node[pPrimary].pLeft, @pTypeFrom, Query);
		when !RecursiveResult:
			return RecursiveResult;
		word Complexity = 0;
		char tmpBuff[nBUFF]; tmpBuff[0] = #0;
		DisableEmit();
		pTypeTo = Code_CAST(@tmpBuff, pPrimary, pTypeTo, pTypeFrom, RegA, @Complexity);
		EnableEmit();
		if Complexity == 0 then
			when @pTypeFinal != NULL:
				pTypeFinal = pTypeTo;
			return RecursiveResult;
		else
			return false;
		end:if
	case iDATA, iPARM, iLOCAL, iSTRING:
		null;
	default:
		return false;
	end:switch

	ValueRef Ref;
	ValueRef_ExtractDataInfo(@Ref, pPrimary);

	word P1=Node[pPrimary].pLeft;
	do
		select
		case P1>=nNODE:
			return false;

		case Node[P1].ID==iLOAD:
			word Size = SizeOfType(Ref.pType);

			select
			case IsNativeOperandSize(Size):
				Buff[0] = #0;
				ValueRef_Code(@Buff, @Ref);
				when @pTypeFinal != NULL:
					pTypeFinal = Ref.pType;
				return true;

			default:
				return false;
			end:select

		case Node[P1].ID==iLPTR:
			if Query == Query_SingleRegOperand then
				return true;
			else
				return false;
			end:if

		case Node[P1].ID==iINDEX:
			Ref.pType = T_ArrayDeref(Ref.pType);
			word Size = SizeOfType(Ref.pType);

			if NodeIsLiteralWord(Node[P1].pLeft) then
				word IndexingOffset = Size * Node[Node[P1].pLeft].Value;
				if Ref.ID != iLOCAL then
					Ref.Offset = Ref.Offset + IndexingOffset;
				else
					Ref.Offset = Ref.Offset - IndexingOffset;
				end
			else
				if Query != Query_SingleRegOperand then
					return false;
				end:if

				when Ref.IX != RegNone:
					return false;
				when !CodeRequiresSingleRegister_(@Buff, Node[P1].pLeft, @pTypeFinal):
					return false;
				Ref.IX = RegA;
			end:if

		case Node[P1].ID==iADDR:
			if Query != Query_SingleRegOperand then
				return false;
			end:if

			Ref.pType = T_DerefPtr(Ref.pType);
			word Size = SizeOfType(Ref.pType);

			word pLeft = Node[P1].pLeft;

			if pLeft < nNODE & NodeIsLiteralWord(pLeft) & Node[pLeft].Value == 0 then
				pLeft = nNODE;
			end:if

			if pLeft < nNODE then
				when Ref.IX != RegNone:
					return false;
				when !CodeRequiresSingleRegister_(@Buff, pLeft, @pTypeFinal):
					return false;
			end:if
			Ref.Offset = 0;
			Ref.IX = RegA;

		case Node[P1].ID==iFIELD:
			ValueRef_Apply_FIELD(@Ref, P1);

		default:
			return false;
		end:select

		P1=Node[P1].pRight;
	end:do

	return false;

end

/*****************************************************************************/

/*
	Если узел pPrimary может быть закодирован как MemRef,
	выводит в буфер Buff этот MemRef, а в pTypeFinal записывает тип выражения.
	Возввращает true при этом.
	Если узел pPrimary не может быть закодирован как MemRef, возвращает false.
*/

bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal)
	return QueryOperandStatus(@Buff, pPrimary, @pTypeFinal, Query_MemoryOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister_(char @tmpBuff; word P; word @pTypeFinal)
	when NodeCanBeEncodedAsImm(P):
		return true;

	word ID = Node[P].ID;

	switch ID of
	case iADD, iBIT_OR, iBIT_XOR, iBIT_AND:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				CodeAsMemoryOperand(@tmpBuff, pRight, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pRight, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pLeft) |
				CodeAsMemoryOperand(@tmpBuff, pLeft, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iSUB:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				CodeAsMemoryOperand(@tmpBuff, pRight, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iMUL:
		if T_SizeOf(Node[P].pType) != 4 then
			return false;
		end:if
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			NodeCanBeEncodedAsImm(pRight) &
			CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		if
			NodeCanBeEncodedAsImm(pLeft) &
			CodeRequiresSingleRegister_(@tmpBuff, pRight, @pTypeFinal)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iBIT_NOT, iNEG:
		return CodeRequiresSingleRegister_(@tmpBuff, Node[P].pLeft, @pTypeFinal);
	case iCAST:
		word pTypeFrom = Node[Node[P].pLeft].pType;
		word pTypeTo = Node[P].pType;
		bool RecursiveResult = CodeRequiresSingleRegister_(@tmpBuff, Node[P].pLeft, @pTypeFrom);
		when !RecursiveResult:
			return RecursiveResult;
		word Complexity = 0;
		tmpBuff[0] = #0;
		pTypeTo = Code_CAST(@tmpBuff, P, pTypeTo, pTypeFrom, RegA, @Complexity);
		if Complexity < 2 then
			when @pTypeFinal != NULL:
				pTypeFinal = pTypeTo;
			return RecursiveResult;
		else
			return false;
		end:if
	end:switch

	return QueryOperandStatus(@tmpBuff, P, @pTypeFinal, Query_SingleRegOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister(word P)
	bool Result;
	word pTypeFinal;
	char tmpBuff[nBUFF];
	tmpBuff[0] = #0;
	DisableEmit();
	Result = CodeRequiresSingleRegister_(@tmpBuff, P, @pTypeFinal);
	EnableEmit();
	return Result;
end

/*****************************************************************************/

/** Returns true if the operands can be swapped for no cost. */
bool IsOperationCommutative(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return true;
	default:
		return false;
	end:switch
end

/** Checks if the operands can be swapped for no cost, but we should change the operation ID as well.
    Returns the code of swapped operation, if the operation is swappable.
    Returns zero otherwise.
*/
word CheckOperationSwappable(word ID)
	switch ID of
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end

bool DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightRegD(word ID)
	switch ID of
	case
		iDIV,
		iMOD:
		return false;
	default:
		return true;
	end:switch
end

/** A heuristic to determine whether it might be advantageous to change the order in which operands are evaluated.
    Returns NULL, if the operand evaluation should not be reordered.
    Returns a string describing the reason of reordering (for debugging purposes),
    if the operand evaluation should be reordered.
*/
char @CheckOperandReordering(word pLeft; word pRight)
	when NodeCanBeEncodedAsImm(pRight):
		return NULL;

	when CodeRequiresSingleRegister(pRight):
		return NULL;

	when NodeCanBeEncodedAsImm(pLeft):
		return "Imm on the left";

	when CodeRequiresSingleRegister(pLeft):
		return "Single-register operand on the left";

	return NULL;
end

/*****************************************************************************/

word TryDropCastBeforeCmp(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	when ID < iLT | iGT < ID:
		return nNODE;

	when Node[pRight].Value > 255: /* TODO: this case should be optimized out on the semantic analysis phase */
		return nNODE;

	when Node[pLeft].ID != iCAST:
		return nNODE;

	word pTypeFrom = Node[Node[pLeft].pLeft].pType;
	word pTypeTo = Node[pLeft].pType;

	when pTypeFrom != st_char & pTypeFrom != st_byte:
		return nNODE;

	when pTypeTo != st_word:
		return nNODE;

	return Node[pLeft].pLeft;
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight):
		null;
	case NodeCanBeEncodedAsImm(pLeft):
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2=Code(pLeft);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	word done = Emit_MUL_Reg_Const(Reg_TARGET, Size, RightValue);
	when done == 0:
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

define operandNotReady 0
define operandReg      1
define operandImm      2
define operandMemRef   3

word CodeBinOp(char @Buff; word P; LABEL @F; LABEL @T; LABEL @M)
	Buff[0] = #0;

	word ID = Node[P].ID;

	if iLT <= ID & ID <= iGT then
		/* These operations don't return the result in any register,
		instead a conditional jump is the result. So we can reset Reg_TARGET freely. */
		Reg_TARGET=RegA;
	end

	do
		word pType = TryCodeFastMult(@Buff,P);
		when pType < nDICT:
			return pType;
		exit;
	end:do

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if Reg_TARGET!=RegA then
			EmitWithExprComment("push    EAX", "saved in CodeBinOp");
			Reg_TARGET=RegA;
		end
	end:switch

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	char BuffRightOperand[nBUFF];
	word leftOperand  = operandNotReady;
	word rightOperand = operandNotReady;

	do
		/*
			The usual calculation scheme is:
				Reg1  <- LeftOperand
				Reg2  <- RightOperand
				OP    Reg1,  Reg2

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) then

			/*
				## Immediate constant on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  ImmValue
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2,  ImmValue
					Op    Reg1,  Reg1
			*/
			if NodeCanBeEncodedAsImm(pRight) then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  ImmValue
				Instead of:
					mov   Reg1,  ImmValue
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if IsOperationCommutative(ID) & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				ID = swappedID;
				exit;
			end:if

		end:if

		if DoesOperationAllowRightMemRef(ID) then

			/*
				## Simple memory reference on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  [MemRef]
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2, [MemRef]
					Op    Reg1, Reg2
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL) then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  [MemRef]
				Instead of:
					mov   Reg1,  [MemRef]
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				exit;
			end:if

		end:if

		exit;
	end:do

	word rightReg = RegNone;
	word fSwap=0;
	word pType;

	if (rightOperand == operandImm) &
	   (T_SizeOf(Node[pRight].pType) == 4) &
	   (PHO_RegContainsConst(Reg_TARGET, Node[pRight].Value))
	then
		do
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitWithExprComment("", "Const reuse in CodeBinOp");
				exit;
			end:if

			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitWithExprComment("", "Const reuse in CodeBinOp");
				exit;
			end:if

			exit;
		end:do
	end:if

	switch rightOperand of
	case operandImm:
		word pLeft2 = TryDropCastBeforeCmp(P);
		when pLeft2 < nNODE:
			pLeft = pLeft2;

		if iLT <= ID & ID <= iGT then
			when CodeRequiresSingleRegister(pLeft):
				Reg_TARGET = ChooseEmptyReg();
		end:if

		pType=Code(pLeft);

	case operandMemRef:
		if leftOperand == operandNotReady then
			if iLT <= ID & ID <= iGT then
				when CodeRequiresSingleRegister(pLeft):
					Reg_TARGET = ChooseEmptyReg();
			end:if

			pType=Code(pLeft);
		end:if

	case operandReg:
		null;

	case operandNotReady:
		char @reorderingReason = @CheckOperandReordering(pLeft, pRight);
		if @reorderingReason != NULL then
			EmitWithExprComment("", "Reordering in CodeBinOp");
			EmitWithExprComment("", @reorderingReason);
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			inc fSwap;
		end:if

		rightOperand = operandReg;
		rightReg = RegB;
		if CodeRequiresSingleRegister(pRight) then
			if DoesOperationAllowRightRegD(ID) & !PHO_RegContainsAConst(RegD) then
				rightReg = RegD;
			else
				rightReg = RegC;
			end:if
		end:if

		if Reg_TARGET != RegA then
			EmitWithExprComment("push    EAX", "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
		pType = Code(pLeft);
		Reg_TARGET  = rightReg;
		Code(pRight);
		when Reg_TARGET != rightReg & fSwap != 0:
			StopInternalCodegen(__FILE__, __LINE__);

		if Reg_TARGET==RegA then
			EmitWithExprComment("pop     EBX", "restored in CodeBinOp");
			inc fSwap;
		end
		Reg_TARGET = RegA;
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		do
			/* We can handle it by changing the operation ID */
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 then
				ID = swappedID;
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit(@CodeCmdRegReg(@Buff, "xchg", Reg_TARGET, 4, rightReg, 4));
				exit;
			end:switch

			/* If the operation is commutative, we don't care about the order. */
			when IsOperationCommutative(ID):
				exit;

			/* In other cases, swapped operands shouldn't happen. */
			StopInternalCodegen(__FILE__, __LINE__);
		end:do
	end:if

	word Size=SizeOfType(pType);

	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = -Value;

		switch Value of
		case 1:
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-1):
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case 2:
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-2):
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		end:switch
	end:if

	word _MeaningfulFlags = 0;

	select
	case iLT<=ID & ID<=iGT:

		if @T == NULL then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch

			@T = @F;
			@F = NULL;
		end:if

		if @T == NULL | @F != NULL then
			StopInternalCodegen(__FILE__, __LINE__);
		end

		select
		case rightOperand == operandImm:
			word Value = Node[pRight].Value;
			word PHO_Load_Value = Value;
			bool SkipCmp = false;
			switch Value of
			case 0:
				select
				case (ID == iEQ) | (ID == iNE):
					if (MeaningfulFlags & Flag_Zero) != 0 then
						null;
						SkipCmp = true;
					else
						Emit(@CodeCmdRegReg(@Buff, "test", Reg_TARGET, Size, Reg_TARGET, Size));
						SkipCmp = true;
					end:if
				case (MeaningfulFlags & (Flag_Zero | Flag_Sign)) == (Flag_Zero | Flag_Sign):
					select
					case (ID == iGE) & T_IsSigned(pType):
						ID = iBRANCH_NSF;
						SkipCmp = true;
					case (ID == iLT) & T_IsSigned(pType):
						ID = iBRANCH_SF;
						SkipCmp = true;
					end:select
				end:select
			case 1:
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
					dec PHO_Load_Value;
					SkipCmp = true;
				end:if
			case word(-1):
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
					inc PHO_Load_Value;
					SkipCmp = true;
				end:if
			end:switch
			if !SkipCmp then
				BuffRightOperand[0] = #0;
				if PHO_EncodeRegContainingConst(@BuffRightOperand, Value, Size) != 0 then
					Emit(@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand));
				else
					Emit(@CodeCmdRegConst(@Buff, "cmp", Reg_TARGET, Size, Value));
				end:if
			end:if
			when (Size == 4) & (ID == iNE):
				PHO_RegLoadConst(Reg_TARGET, PHO_Load_Value);
		case rightOperand == operandMemRef:
			Emit(@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand));
		case rightOperand == operandReg:
			Emit(@CodeCmdRegReg(@Buff, "cmp", Reg_TARGET, Size, rightReg, Size));
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end

		char@ BranchCondition = "";
		select
		case T_IsSigned(pType):
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			case iBRANCH_SF: @BranchCondition = "s ";
			case iBRANCH_NSF: @BranchCondition = "ns";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, @T);

		return nDICT;

	case ID==iBIT_OR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"and     ");

	case ID==iADD:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pType):
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pType):
			strcpy(@Buff,"mul     ");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		switch rightOperand of
		case operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch

		Emit(@Buff);
		return pType;

	case ID==iDIV | ID==iMOD:
		select
		case Size==1:
			if T_IsSigned(pType) then
				Emit("movsx   AX,   AL");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     AH,   AH");
				strcpy(@Buff,"div     ");
			end:if
		case Size==2:
			if T_IsSigned(pType) then
				Emit("cwq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     DX,   DX");
				strcpy(@Buff,"div     ");
			end:if
		case Size==4:
			if T_IsSigned(pType) then
				Emit("cdq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     EDX,  EDX");
				strcpy(@Buff,"div     ");
			end:if
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		select
		case rightOperand == operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		Emit(@Buff);

		if ID==iMOD then
			/*
				XCHG is encoded as a single byte for native-length registers:
				0x92 - xchg AX, DX (16-bit mode), xchg EAX, EDX (32-bit mode)
				MOV takes 2 bytes.
				So we prefer XCHG when optimizing for size.
				See also notes on XCHG performance:
				https://stackoverflow.com/questions/45766444/why-is-xchg-reg-reg-a-3-micro-op-instruction-on-modern-intel-architectures
			*/
			select
			case Size==1:
				Emit("mov     AL,   AH");
			case Size==2:
				if EmitShortCode != 0 then
					Emit("xchg    AX,   DX");
				else
					Emit("mov     AX,   DX");
				end:if
			case Size==4:
				if EmitShortCode != 0 then
					Emit("xchg    EAX,  EDX");
				else
					Emit("mov     EAX,  EDX");
				end:if
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:select
		end:if

		return pType;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	select
	case IsNativeOperandSize(Size):
		select
		case rightOperand == operandImm:
			/*
				XXX: The commented out code is mostly useless in the current implementation
				I can't find any expression when that condition actually triggers.
				May be useful when a full-featured register allocation strategy will be implemented.
			*/
			/*if PHO_EncodeRegContainingConst(@BuffRightOperand, Node[pRight].Value, Size) != 0 then
				CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
			else*/
				CodeRegConst(@Buff, Reg_TARGET, Size, Node[pRight].Value);
			/*end:if*/
		case rightOperand == operandMemRef:
			CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
		case rightOperand == operandReg:
			CodeRegReg(@Buff, Reg_TARGET, Size, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
		Emit(@Buff);
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	MeaningfulFlags = _MeaningfulFlags;
	return pType;
end

/*****************************************************************************/

/*
	Генерация кода для условных переходов из булевых выражений.

	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M)
	char Buff[nBUFF];
	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when @T != NULL & @F != NULL: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	when Node[P].pType != st_bool:
		StopInternalCodegen(__FILE__, __LINE__);

	/* These operations don't return the result in any register,
	instead a conditional jump is the result. So we reset Reg_TARGET here. */
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;

	switch Node[P].ID of
	case iLITERAL:
		select
		case Node[P].Value == 0 & @F != NULL:
			EmitJumpToLabel(@F);
		case Node[P].Value != 0 & @T != NULL:
			EmitJumpToLabel(@T);
		end:select
		return st_bool;

	case iLT, iLE, iEQ, iNE, iGE, iGT:
		return CodeBinOp(@Buff, P, @F, @T, @M);

	case iNOT:
		return CodeBooleanExpr(Node[P].pLeft, @T, @F, @M);
	case iOR:
		Code_OR(P, @F, @T, @M, @Buff);
		return st_bool;
	case iXOR:
		Code_XOR(P, @F, @T, @M, @Buff);
		//return st_bool;
	case iEQV:
		Code_EQV(P, @F, @T, @M, @Buff);
		//return st_bool;
	case iAND:
		Code_AND(P, @F, @T, @M, @Buff);
		return st_bool;

	case iDATA, iPARM, iLOCAL:
		when CodeRequiresSingleRegister(P):
			Reg_TARGET = ChooseEmptyReg();
		Code(P);
		Emit(@CodeCmdRegReg(@Buff, "test", Reg_TARGET, 4, Reg_TARGET, 4));
		select
		case @F != NULL:
			EmitBranchToLabel("z", @F);
		case @T != NULL:
			EmitBranchToLabel("nz", @T);
		end:select
		return st_bool;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch
end

/*****************************************************************************/

word Code(word P)
	char Buff[nBUFF];
	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	switch Node[P].ID of
	case iNULL:
		Emit_Load_Constant(Reg_TARGET, 4, 0);
		return Node[P].pType;

	case iLITERAL:
		Emit_Load_Constant(Reg_TARGET, T_SizeOf(Node[P].pType), Node[P].Value);
		return Node[P].pType;

	case iFUNC:
		CodeLoadLabel(@Buff, Reg_TARGET, Node[P].Value);
		Emit(@Buff);
		return Node[P].pType;

	case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
		return CodePrimary(P);

	case iCAST:
		word pTypeFrom = Code(Node[P].pLeft);
		word pTypeTo = Node[P].pType;
		word Complexity = 0;
		return Code_CAST(@Buff, P, pTypeTo, pTypeFrom, Reg_TARGET, @Complexity);

	case iBIT_NOT:
		word pType = Code(Node[P].pLeft);
		word  Size = SizeOfType(pType);
		Emit(@CodeCmdReg(@Buff, "not", Reg_TARGET, Size));

		return pType;

	case iNEG:
		if NodeIsLiteralWord(Node[P].pLeft) then
			Emit_Load_Constant(Reg_TARGET, 4, -Node[Node[P].pLeft].Value);
			return Node[P].pType;
		end

		Code(Node[P].pLeft);

		Emit(@CodeCmdReg(@Buff, "neg", Reg_TARGET, T_SizeOf(Node[P].pType)));

		return Node[P].pType;

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
		return CodeBinOp(@Buff, P, NULL, NULL, NULL);

	case iDEF_LOCAL:
		if nLocal>=nLOCAL then
			StopMemory();
		end

		word pType = Node[P].pType;
		word Size  = SizeOfType(pType);

		AllocatedFrameSize = AllocatedFrameSize + DefaultInStackAlign(Size);

		word i = nLocal;
		inc nLocal;
		Local[i].pType=pType;
		Local[i].Value=AllocatedFrameSize;
		when EmitDebugComments_LocalDefs:
			EmitLine(NULL, "", @strcpy4(@Buff, "iDEF_LOCAL: ",@Char[Node[P].Value]," ",@str(Local[i].Value)));

		Code(Node[P].pLeft);

	case iASSIGN:
		P = Node[P].pLeft;
		Reg_TARGET = RegA;
		Reg_ALT_TARGET = RegNone;

		if Node[P].pRight < nNODE then
			Code(Node[P].pRight);
			Reg_ALT_TARGET = Reg_TARGET;
			Reg_TARGET = RegB;
		end

		word pType = Code(Node[P].pLeft);
		Reg_TARGET = RegA;
		Reg_ALT_TARGET = RegA;
		return pType;

	case iINLINE:
		Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16)));

	case iPUSH:
		Code_PUSH(P, @Buff);
	case iRETURN:
		return Code_RETURN(P, @Buff);
	case iSELECT:
		return Code_SELECT(P, @Buff);
	case iSWITCH:
		return Code_SWITCH(P, @Buff);
	case iWHILE:
		return Code_WHILE(P, @Buff);
	case iREPEAT:
		return Code_REPEAT(P, @Buff);
	case iCONTINUE:
		return Code_CONTINUE(P, @Buff);
	case iEXIT:
		return Code_EXIT(P, @Buff);
	case iEMPTY, iVIRTUAL_JUMP:
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:switch

	return nDICT;
end

/*****************************************************************************/

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	if Dict[I].Sub != sMAIN then
		strcat(@Buff, @DictGetName(I));
	else
		strcat(@Buff, "<begin>");
	end:if
	strcat(@Buff," ##");
	LABEL L; L.Value = Dict[I].Label;
	EmitLine(@L, "", @Buff);

	word S1 = 0;

	word pARGS = FindInNamespace("args", I);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = S1 + 8;
		S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while

	PHO_InvalidateRegs();

	if EmitEnterInstruction != 0 & Dict[I].StackSize > 0 then
		Emit(@strcpy3(@Buff,"enter   ",@str(Dict[I].StackSize), ", 0"));
	else
		Emit("push    EBP");
		Emit("mov     EBP,  ESP");

		if Dict[I].StackSize > 0 then
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(Dict[I].StackSize)));
		end:if
	end:if

	if Dict[I].Sub == sMAIN then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == false then
					Code(Dict[J].pNode);
				end:if
			end:if

			inc J;
		end:while
	end:if

	pFunc = I;
	ParmFrameSize = S1;
	AllocatedFrameSize = 0;

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  pType = st_void;
	while P < nNODE do
		pType = Code(P);
		when pType == st_noreturn:
			exit;
		P  = Node[P].pRight;
	end

	if pType != st_noreturn then
		word pRet = Peek();
		Node[pRet].ID = iRETURN;
		Code(pRet);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word EmitFunctions(char @Buff)
	word Start = 0;

	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				when Dict[I].Sub == sMAIN:
					Start = Dict[I].Label;
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when Start == 0:
		StopInternalCodegen(__FILE__, __LINE__);

	return Start;
end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word Start = EmitFunctions(@Buff);

	return Start;

end

/*****************************************************************************/

