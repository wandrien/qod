
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */
word fEAX;  /* Маркер активного регистра. (Cуть этого хака более ясна его автору - Хохлову, нежели мне. VU) */

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		_Code(P,0,0,0);
		P = Node[P].pRight;
	end
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	Code_List(P);
	Code_EndBlock(@CB);
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word pPrimary)

	char Buff [nBUFF];
	Buff[0] = #0;

	word IncID=Node[pPrimary].ID;
	if IncID==iINC | IncID==iDEC then
		fEAX=RegA;
		pPrimary = Node[pPrimary].pLeft;
	end

	word nIndx;
	word pType;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(pPrimary, @pType, @nIndx, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do
		Buff[0] = #0;
		select
		case P1>=nNODE:
			select
			case IncID==iINC | IncID==iDEC:
				if IX==RegB then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:if

				if IncID==iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=SizeOfType(pType, 0);
				select
				case Size==1:
					strcat(@Buff,"byte  ");     // FASM
				case Size==4:
					strcat(@Buff,"dword ");     // FASM
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:select

				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));

			case ID!=iCALL:
				word Size = SizeOfType(pType, 0);

				select
				case Size==1:
					strcpy(@Buff,"mov     byte  ");     // FASM
				case Size==4:
					strcpy(@Buff,"mov     dword ");     // FASM
				default:
					strcpy(@Buff,"lea     EDI,  ");
				end:select

				CodeDataIX_offset(@Buff, ID, IX, Ofs);

				select
				case fEAX!=RegA:
					select
					case Size==1:
						Emit(@strcat(@Buff,", AL"));
					case Size==4:
						Emit(@strcat(@Buff,", EAX"));

					default:
						Emit("mov     ESI,  EAX");
						Emit(@Buff);
					end:select

				case IX==RegA:
					select
					case Size==1:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", BL"));
					case Size==4:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", EBX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select

				case IX==RegB:
					select
					case Size==1:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", AL"));
					case Size==4:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", EAX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select
				end:select

				if Size!=1 & Size!=4 then
					Emit("cld");
					Emit(@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
					Emit("rep     movsb");
				end:if
			end:select

			exit;

		case Node[P1].ID==iLOAD:
			word Size = SizeOfType(pType, 0);

			select
			case Size==1:
				strcpy3(@Buff, "mov     ", @CodeReg(NULL, fEAX, 1), ",   byte  ");

			case Size==4:
				strcpy3(@Buff, "mov     ", @CodeReg(NULL, fEAX, 4), ",   dword ");

			default:
				strcpy3(@Buff, "lea     ", @CodeReg(NULL, fEAX, 4), ",  ");
			end:select

			if IX==RegNone & ID==iCALL then
				null;
			else
				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));
			end:if

			return pType;

		case Node[P1].ID==iLPTR:
			if fEAX!=RegA | IX==RegB then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			end:if

			if IX!=RegNone then
				select
				case ID==iDATA:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  @@DATA+"),@str(Ofs)));
				case ID==iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX+"),@str(Ofs)),"]"));
				case ID==iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX-"),@str(Ofs)),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"add     EAX,  "), @s),@str(Ofs)));
				case ID==iREF & Ofs!=0:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcat(@strcpy(@Buff,"mov     EAX,  @@DATA+"),@str(Ofs)));
				case ID==iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+"),@str(Ofs)),"]"));
				case ID==iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP-"),@str(Ofs)),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"mov     EAX,  "), @s),@str(Ofs)));
				case ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			return nDICT;

		case Node[P1].ID==iCALL:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub==sSYS then
				Emit(@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Node[P1].Value].Label)),"]"));
			else
				EmitLine(0,
					@strcat(@strcpy(@Buff,"call    @"),@str(Dict[Node[P1].Value].Label)),
					@DictGetName(Node[P1].Value)
					);
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID==iCALL2:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit("call    EAX");

			pType=Dict[Node[P1].Value].pType;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID==iINDEX:

			word  C   = 0;
			word  N   = 0;
			word  IX1 = RegNone;
			word fIX  = 1;
			do
				if Node[Node[P1].pLeft].ID==iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					select
					case IX1==RegB:
						if fEAX!=RegA then
							if IX!=0 then
								StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
							end:if

							fEAX=RegA;
						else
							if IX!=RegA then
								StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
							end:if

							fIX=0;
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						_Code(Node[P1].pLeft,0,0,0);

						Emit("pop     EBX");
						Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						Emit("add     EAX,  EBX");

						IX1=RegA;

					case IX1==RegA:
						if fEAX!=RegA | IX!=RegNone then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							Emit("pop     EBX");
							Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						else
							Emit(@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(N*Node[P1].Value)));
						end:if

						Emit("add     EAX,  EBX");

						fEAX=RegA;

					case IX==RegB:
						if fEAX==RegA then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						fEAX=RegA;
						fIX =0;

						_Code(Node[P1].pLeft,0,0,0);

						IX1=RegA;

					case IX==RegA:
						if fEAX!=RegA then
							StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
						end:if

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							fIX=0;
							IX1=RegA;
						else
							IX1=RegB;
						end:if

						fEAX=RegA;

					default:
						_Code(Node[P1].pLeft,0,0,0);

						if fEAX==RegA then
							IX1=RegA;
						else
							IX1=RegB;
						end:if
					end:select

					C=C*Node[P1].Value;
					N=1;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType, 0);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

			if IX1!=RegNone then
				Size = Size * N;
				Emit_IMUL_Reg_Const(IX1, 4, Size);

				if IX!=RegNone then
					select
					case IX1==RegB:
						if IX!=RegNone | fIX==0 then
							StopInternalCodegen(__FILE__, __LINE__);
						end:if

						Emit("add     EAX,  EBX");

					case IX1==RegA:
						if fIX!=0 then
							StopInternalCodegen(__FILE__, __LINE__);
						end

						Emit("pop     EBX");
						Emit("add     EAX,  EBX");

						IX=RegA;

					default:
						StopInternalCodegen(__FILE__, __LINE__);
					end:select
				else
					IX=IX1;
				end:if
			end:if

		case Node[P1].ID==iADDR:
			if T_IsPtr(pType) == 0 then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			end:if

			pType = T_DerefPtr(pType);

			if Node[P1].pLeft<nNODE then
				word Size = SizeOfType(pType, 0);

				select
				case IX==RegB:
					if fEAX!=RegA then
						Emit("push    EAX");
					end:if

					Emit("xchg    EAX,  EBX");
					IX  =RegA;
					fEAX=RegB;

				case IX==RegA:
					fEAX=RegB;
				end:select

				_Code(Node[P1].pLeft,0,0,0);

				Emit_IMUL_Reg_Const(fEAX, 4, Size);
				if fEAX==RegA then
					if IX!=RegNone then
						Emit("pop     EBX");
						IX=RegB;
					end:if
					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX==RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=RegNone then
				char RX[4];
				if IX==RegA then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end:if

				select
				case ID==iDATA:
					Emit(@strcat5(@Buff,"[@@DATA+",@RX,"+",@str(Ofs),"]"));
				case ID==iPARM:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"-",@str(Ofs),"]"));
				case ID==iREF:
					Emit(@strcat5(@Buff,"[",@RX,"+",@str(Ofs),"]"));
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcat3(@Buff,"[@@DATA+",@str(Ofs),"]")); // FASM
				case ID==iPARM:
					Emit(@strcat3(@Buff,"[EBP+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat3(@Buff,"[EBP-",@str(Ofs),"]"));
				//TODO Пpовеpить!
				case ID==iCALL:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			if fEAX==RegA then
				IX=RegA;
			else
				if IX!=RegNone then
					fEAX=RegA;
				end:if

				IX=RegB;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID==iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);
			nIndx = T_ArrayGetSizeOr0(pType);
			when T_IsArray(pType) != 0:
				pType = T_ArrayDeref(pType);

		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

word NodeCanBeEncodedAsImm(word P)
	word ID=Node[P].ID;
	switch ID of
	case iCHAR, iWORD, iINT:
		return 1;
	default:
		return 0;
	end:switch
end

word IsOperationCommutative(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iEQ, iNE:
		return 1;
	default:
		return 0;
	end:switch
end

/*****************************************************************************/

word CodeBinOp(char @Buff; word P; word F; word T; word M)
	Buff[0] = #0;

	if iLT<=Node[P].ID & Node[P].ID<=iGT then
		fEAX=RegA;
	end

	if fEAX!=RegA then
		Emit("push    EAX");
		fEAX=RegA;
	end

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	if NodeCanBeEncodedAsImm(pLeft) != 0 & IsOperationCommutative(Node[P].ID) != 0 then
		word tmp = pLeft;
		pLeft = pRight;
		pRight = tmp;
	end:if

	word fSwap=0;
	word pType;
	select
	case NodeCanBeEncodedAsImm(pRight) != 0:
		pType=_Code(pLeft,0,0,0);
		fSwap=2;

	case NodeCanBeEncodedAsImm(pLeft) != 0:
		_Code(pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(pLeft,0,0,0);
		fSwap=1;

	case Node[Node[pLeft].pLeft].ID==iLOAD:
		_Code(pRight,0,0,0);
		fEAX =RegB;
		pType=_Code(pLeft,0,0,0);
		fSwap=1;

	default:
		pType=_Code(pLeft,0,0,0);
		fEAX =RegB;
		_Code(pRight,0,0,0);
		if fEAX==RegA then
			Emit("pop     EBX");
			fSwap=1;
		end
	end:select

	word ID=Node[P].ID;
	select
	case fSwap==1:
		switch ID of
		case iLT: ID=iGT;
		case iLE: ID=iGE;
		case iGE: ID=iLE;
		case iGT: ID=iLT;

		case iSUB, iDIV, iMOD:
              Emit("xchg    EAX,  EBX");
		end:switch

	case fSwap==2:
		switch ID of
		case iMUL, iDIV, iMOD:
			fEAX =RegB;
			_Code(pRight,0,0,0);
		end:switch
	end:select

	fEAX=RegA;

	word Size=4;
	if pType<nDICT then
		Size=SizeOfType(pType, 0);
	end

	/* Оптимизация случая, когда можно использовать inc/dec вместо add/sub */
	if fSwap == 2 & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = -Value;

		select
		case Value == 1 & Size == 4:
			Emit("inc     EAX");
			return pType;
		case Value == -1 & Size == 4:
			Emit("dec     EAX");
			return pType;
		case Value == 1 & Size == 1:
			Emit("inc     AL");
			return pType;
		case Value == -1 & Size == 1:
			Emit("dec     AL");
			return pType;
		end:select
	end:if

	select
	case iLT<=ID & ID<=iGT:

		select
		case fSwap==2:
			if (ID == iEQ | ID == iNE) & Node[pRight].Value == 0 then
				Emit(@CodeCmdRegReg(@Buff, "test", RegA, Size, RegA, Size));
			else
				Emit(@CodeCmdRegConst(@Buff, "cmp", RegA, Size, Node[pRight].Value));
			end:if
		default:
			Emit(@CodeCmdRegReg(@Buff, "cmp", RegA, Size, RegB, Size));
		end

		if T==0 then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
            end:switch

            T=F;
            F=0;
		end:if

		if T==0 | F!=0 then
			StopInternalCodegen(__FILE__, __LINE__);
		end

		char@ BranchCondition = "";
		select
		case pType==st_int:
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			default:
                  StopInternalCodegen(__FILE__, __LINE__);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
                  StopInternalCodegen(__FILE__, __LINE__);
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, T);

		return nDICT;

	case ID==iBIT_OR:
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		strcpy(@Buff,"and     ");

	case ID==iADD:
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case pType==st_byte:
			Emit("mul     BL");
		case pType==st_word:
			Emit("mul     EBX");
		case pType==st_int:
			Emit("imul    EBX");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		return pType;

	case ID==iDIV:
		select
		case pType==st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
		case pType==st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
		case pType==st_int:
			Emit("xor     EDX,  EDX");
			Emit("idiv    EBX");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		return pType;

	case ID==iMOD:
		select
		case pType==st_byte:
			Emit("xor     AH,   AH");
			Emit("div     BL");
			Emit("xchg    AL,   AH");
		case pType==st_word:
			Emit("xor     EDX,  EDX");
			Emit("div     EBX");
			Emit("xchg    EAX,  EDX");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		return pType;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	select
	case Size==1:
		select
		case fSwap==2:
			Emit(@strcat(@strcat(@Buff,"AL,   "),@str(Node[pRight].Value)));
		default:
			Emit(@strcat(@Buff,"AL,   BL"));
		end:select

	case Size==4:
		select
		case fSwap==2:
			Emit(@strcat(@strcat(@Buff,"EAX,  "),@str(Node[pRight].Value)));
		default:
			Emit(@strcat(@Buff,"EAX,  EBX"));
		end:select

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	return pType;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff[nBUFF];

	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when M != 0: /* M может быть установлено только когда F или T установлены */
		when T == 0 & F == 0:
			StopInternalCodegen(__FILE__, __LINE__);

	when T != 0 & F != 0: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	if T != 0 | F != 0 then
		when NodeTypeIs(P, st_bool) == 0: /* T и F имеют смысл только для булевых вычислений. */
			StopInternalCodegen(__FILE__, __LINE__);

		switch Node[P].ID of
		case iBOOL:
			select
			case Node[P].Value == 0 & F != 0:
				EmitJumpToLabel(F);
			case Node[P].Value != 0 & T != 0:
				EmitJumpToLabel(T);
			end:select
			return st_bool;

		case iLT, iLE, iEQ, iNE, iGE, iGT:
			return CodeBinOp(@Buff, P, F, T, M);

		case iNOT:
			return Code(Node[P].pLeft, T, F, M);
		case iOR:
			Code_OR(P, F, T, M, @Buff);
			return st_bool;
		case iXOR:
			Code_XOR(P, F, T, M, @Buff);
			return st_bool;
		case iEQV:
			Code_EQV(P, F, T, M, @Buff);
			return st_bool;
		case iAND:
			Code_AND(P, F, T, M, @Buff);
			return st_bool;

		case iDATA, iPARM, iLOCAL:
			Code(P, 0, 0, 0);
			Emit(@CodeCmdRegReg(@Buff, "test", fEAX, 4, fEAX, 4));
			select
			case F != 0:
				EmitBranchToLabel("z", F);
			case T != 0:
				EmitBranchToLabel("nz", T);
			end:select

		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	else
		switch Node[P].ID of
		case iNULL:
			Emit_Load_Constant(fEAX, 4, 0);
			return Node[P].pType;

		case iBOOL:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_bool;

		case iCHAR:
			Emit_Load_Constant(fEAX, 1, Node[P].Value);
			return st_char;

		case iWORD:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_word;

		case iINT:
			Emit_Load_Constant(fEAX, 4, Node[P].Value);
			return st_int;

		case iFUNC:
			CodeLoadLabel(@Buff, fEAX, Node[P].Value);
			Emit(@Buff);
			return nDICT;

		case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
			return Code1(P);

		case iCAST:
			word pTypeFrom = Code(Node[P].pLeft, 0, 0, 0);
			word pTypeTo = Node[P].pType;

			select
			case pTypeFrom == nDICT:
				null; /* FIXME: should trigger internal error */
				//StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeFrom == st_void:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeTo == st_void:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			case pTypeTo == pTypeFrom:
				null;
			case pTypeTo==st_char & pTypeFrom==st_byte:
				null;
			case pTypeTo==st_char & pTypeFrom==st_word:
				null;
			case pTypeTo==st_char & pTypeFrom==st_int:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_char:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_int:
				null;
			case pTypeTo==st_byte & pTypeFrom==st_word:
				null;
			case pTypeTo==st_word & pTypeFrom==st_char:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_word & pTypeFrom==st_byte:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_word & pTypeFrom==st_int:
				null;
			case pTypeTo==st_int & pTypeFrom==st_char:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_int & pTypeFrom==st_byte:
				Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
			case pTypeTo==st_int & pTypeFrom==st_word:
				null;
			case T_IsPtr(pTypeTo) == 1 & T_IsPtr(pTypeFrom) == 1:
				null;
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end
			return pTypeTo;

		case iBIT_NOT:
			word pType = Code(Node[P].pLeft, 0, 0, 0);
			word  Size = SizeOfType(pType, 0);
			Emit(@CodeCmdReg(@Buff, "not", fEAX, Size));

			return pType;

		case iNEG:
			if Node[Node[P].pLeft].ID==iWORD then
				Emit_Load_Constant(fEAX, 4, -Node[Node[P].pLeft].Value);
				return st_int;
			end

			Code(Node[P].pLeft,0,0,0);

			Emit(@CodeCmdReg(@Buff, "neg", fEAX, 4));

			return st_int;

		case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
			return CodeBinOp(@Buff, P, 0, 0, 0);

		case iDEF_LOCAL:
		  if nLocal>=nLOCAL then
			StopMemory();
		  end

		  word pType = Node[P].pType;
		  word Size  = SizeOfType(pType, Node[Node[P].pLeft].Value);

		  AllocatedFrameSize =
			  AllocatedFrameSize + DefaultInStackAlign(Size);

		  Local[nLocal].pType=pType;
		  Local[nLocal].Value=AllocatedFrameSize;
		  inc   nLocal;

		  Code(Node[P].pLeft,0,0,0);

		case iASSIGN:
			P    = Node[P].pLeft;
			fEAX = RegA;
			if Node[P].pRight < nNODE then
				Code(Node[P].pRight, 0, 0, 0);
				fEAX = RegB;
			end

			Code(Node[P].pLeft, 0, 0, 0);

		case iINLINE:
			Emit(@strcat(@strcpy(@Buff,"db      0x"),@str2(Node[P].Value,16)));

		case iPUSH:
			Code_PUSH(P, @Buff);
		case iRETURN:
			Code_RETURN(P, @Buff);
		case iSELECT:
			Code_SELECT(P, @Buff);
		case iSWITCH:
			Code_SWITCH(P, @Buff);
		case iWHILE:
			Code_WHILE(P, @Buff);
		case iREPEAT:
			Code_REPEAT(P, @Buff);
		case iCONTINUE:
			Code_CONTINUE(P, @Buff);
		case iEXIT:
			Code_EXIT(P, @Buff);
		case iEMPTY:
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:switch

	end:if

	return nDICT;
end

/*****************************************************************************/

/* Формирует листинг кода функций. */
word EmitFunctions(char @Buff)

	word S;

	word pRet = Peek();
	Node[pRet].ID = iRETURN;


	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				EmitStringNL("");
				strcpy(@Buff,"## ");
				if Dict[I].Sub != sMAIN then
					strcat(@Buff, @DictGetName(I));
				else
					strcat(@Buff, "<begin>");
					S = Dict[I].Label;
				end:if
				strcat(@Buff," ##");
				EmitLine(Dict[I].Label, "", @Buff);

				word S1 = 0;

				word pARGS = FindInNamespace("args", I);
				when pARGS >= nDICT:
					StopInternalCodegen(__FILE__, __LINE__);
				word pARG = Dict[pARGS].pFirst;
				while pARG < nDICT do
					Dict[pARG].Label = S1 + 8;
					S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType, T_ArrayGetSizeOr0(Dict[pARG].pType)));
					pARG = Dict[pARG].pNext;
				end:while

				PHO_InvalidateRegs();

				if EmitEnterInstruction != 0 & Dict[I].StackSize > 0 then
					Emit(@strcat(@strcat(@strcpy(@Buff,"enter   "),@str(Dict[I].StackSize)), ", 0"));
				else
					Emit("push    EBP");
					Emit("mov     EBP,  ESP");

					if Dict[I].StackSize > 0 then
						Emit(@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(Dict[I].StackSize)));
					end:if
				end:if

				if Dict[I].Sub == sMAIN then
					word  J = 0;
					while J < nDict do
						if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
							if Node[Dict[J].pNode].ID != iASSIGN then
								StopInternalCodegen(__FILE__, __LINE__);
							end:if
							if StaticDataIsZeroed == 0
							 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == 0 then
								Code(Dict[J].pNode, 0, 0, 0);
							end:if
						end:if

						inc J;
					end:while
				end:if

				pFunc = I;
				ParmFrameSize = S1;
				AllocatedFrameSize = 0;

				CODEBLOCK CB;
				Code_BeginBlock(@CB);

				word  P = Dict[I].pNode;
				word  ID;
				while P < nNODE do
					_Code(P, 0, 0, 0);
					ID = Node[P].ID;
					P  = Node[P].pRight;
				end

				if ID!=iRETURN then
					_Code(pRet, 0, 0, 0);
				end

				Code_EndBlock(@CB);

		end // of select

		inc I;
	end // of while

	return S;

end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word S = EmitFunctions(@Buff);

	return S;

end

/*****************************************************************************/

