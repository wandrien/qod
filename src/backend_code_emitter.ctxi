
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */

/*
Active register.

When entering a function for generating code for an operation:

 * If Reg_TARGET == RegA, the caller expects the result to be places in RegA.
   The code may use both RegA and RegB and should return the result in RegA.

 * If Reg_TARGET == RegB, the caller expects the result to be placed in RegB.
   RegA is used by the caller to store a value.
   The code either returns the result in RegB and keeps the value of RegA untouched.
   Or stores RegA on the stack, sets Reg_TARGET = RegA and return the result in RegA.
   In the latter case, the caller normally pops the value from the stack to RegB,
   and does the calculation with the swapped arguments.
*/

word Reg_TARGET;
word Reg_ALT_TARGET = RegA;
word RegAllocation[5];

void RegAllocate(word Reg)
	when RegAllocation[Reg] != 0:
		StopInternalCodegen(__FILE__, __LINE__);
	inc RegAllocation[Reg];
end

void RegFree(word Reg)
	when RegAllocation[Reg] != 1:
		StopInternalCodegen(__FILE__, __LINE__);
	dec RegAllocation[Reg];
end

/*****************************************************************************/

word ChooseEmptyReg()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;

	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;

	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;

	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;

	return RegNone;
end

word ChooseEmptyReg2()
	when Reg_ALT_TARGET != RegA & RegAllocation[RegA] == 0 & !PHO_RegContainsAConst(RegA):
		return RegA;

	when Reg_ALT_TARGET != RegB & RegAllocation[RegB] == 0 & !PHO_RegContainsAConst(RegB):
		return RegB;

	when Reg_ALT_TARGET != RegD & RegAllocation[RegD] == 0 & !PHO_RegContainsAConst(RegD):
		return RegD;

	when Reg_ALT_TARGET != RegC & RegAllocation[RegC] == 0 & !PHO_RegContainsAConst(RegC):
		return RegC;


	return RegNone;
end


/*****************************************************************************/

word Code(word P);
word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M);

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		word pType = Code(P);
		when pType == st_noreturn:
			return st_noreturn;
		P = Node[P].pRight;
	end
	return st_void;
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	word pType = Code_List(P);
	Code_EndBlock(@CB);
	return pType;
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

void Code_ADDR(word P1; ValueRef @Ref)
	char Buff [nBUFF];
	Buff[0] = #0;

	if !T_IsPtr(Ref.pType) then
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:if

	word pTypeDeref = T_DerefPtr(Ref.pType);
	word Size = T_SizeOf(pTypeDeref);

	word pIndex = P1;

	if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
		pIndex = nNODE;
	end:if

	if pIndex < nNODE then
		select
		case Ref.IX == RegNone:
			null;
		case Ref.IX == Reg_ALT_TARGET:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		case Reg_ALT_TARGET != RegNone:
			if Reg_TARGET != Reg_ALT_TARGET then
				EmitWithExprComment(@CodePushReg(@Buff, Reg_ALT_TARGET, 4),
					"saved in Code_ADDR");
			end:if
			Emit(@CodeXchgRegReg(@Buff, Ref.IX, Reg_ALT_TARGET, 4));
			Reg_TARGET = Ref.IX;
			Ref.IX = Reg_ALT_TARGET;
		default:
			Reg_TARGET = ChooseEmptyReg2();
			when Reg_TARGET == RegNone:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		Code(pIndex);
		Emit_IMUL_Reg_Const(Reg_TARGET, 4, Size);

		if Reg_TARGET == Reg_ALT_TARGET then
			if Ref.IX != RegNone then
				Ref.IX = RegB;
				EmitWithExprComment(@CodePopReg(@Buff, Ref.IX, 4), "restored in Code_ADDR");
			end:if
		end:if
	end:if

	char @TX = @CodeReg(NULL, Reg_TARGET, 4);

	switch Ref.ID of
	case iDATA, iPARM, iLOCAL, iREF:
		if pIndex < nNODE then
			strcpy3(@Buff,"add     ",@TX,",  ");
		else
			strcpy3(@Buff,"mov     ",@TX,",  ");
		end:if
		Emit(@ValueRef_Code(@Buff, @Ref));
	case iREG:
		if Ref.IX != RegNone then
			if Reg_TARGET != Ref.IX then
				char @RX = @CodeReg(NULL, Ref.IX, 4);
				if Ref.Offset != 0 then
					strcpy3(@Buff,"lea     ",@TX,",  dword ");
					strcat7(@Buff,"[",@TX,"+",@RX,"+",@str(Ref.Offset),"]");
					Emit(@Buff);
				else
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@RX));
				end:if
			end:if
		else
			//Reg_TARGET = Ref.IX;
			null;
		end:if
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
	end:switch

	if Reg_TARGET == Reg_ALT_TARGET | Reg_ALT_TARGET == RegNone then
		Ref.IX = Reg_TARGET;
	else
		word Reg_TARGET_tmp = Reg_TARGET;
		if Ref.IX != RegNone then
			when (Reg_ALT_TARGET == RegNone):
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			Reg_TARGET = Reg_ALT_TARGET;
		end:if

		Ref.IX = Reg_TARGET_tmp;
	end:if

	Ref.pType = pTypeDeref;
	Ref.ID = iREF;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_LPTR(word P1; ValueRef @Ref)
	char Buff [nBUFF];
	Buff[0] = #0;

	char @TX = @CodeReg(NULL, Reg_TARGET, 4);

	if Ref.IX != RegNone then
		if Reg_TARGET != Ref.IX then
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:if

		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"add     ",@TX,",  ");
			Emit(@ValueRef_Code_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			Emit(@ValueRef_Code_ForLEA(@Buff, @Ref));
		case iREF:
			when Ref.Offset != 0:
				Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@str(Ref.Offset)));
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	else
		switch Ref.ID of
		case iDATA, iSTRING:
			strcpy3(@Buff,"mov     ",@TX,",  ");
			Emit(@ValueRef_Code_StaticOffset(@Buff, @Ref));
		case iPARM, iLOCAL:
			strcpy3(@Buff,"lea     ",@TX,",  ");
			Emit(@ValueRef_Code_ForLEA(@Buff, @Ref));
		case iREF:
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:switch
	end:if

	Ref.pType = T_PtrTo(Ref.pType);
	Ref.ID = iREG;
	Ref.IX = Reg_TARGET;
	Ref.Offset = 0;
end

/*****************************************************************************/

void Code_CALL(word pPrimary; ValueRef @Ref)
	char Buff [nBUFF];
	Buff[0] = #0;

	if Reg_ALT_TARGET == RegA & Reg_TARGET != RegA then
		EmitWithExprComment("push    EAX", "saved in CodePrimary (iCALL)");
	end:if
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegA;

	switch Node[pPrimary].ID of
	case iCALL:
		when Node[pPrimary].pLeft != nNODE:
			Code(Node[pPrimary].pLeft);
		word pFunc = Node[pPrimary].Value;
		if Dict[pFunc].Sub==sSYS then
			Emit(@strcpy3(@Buff,"call   [@",@str(Dict[pFunc].Label),"]"));
		else
			EmitLine(NULL,
				@strcpy2(@Buff,"call    @",@str(Dict[pFunc].Label)),
				@DictGetName(pFunc)
				);
		end:if
	case iCALL2:
		when Node[pPrimary].pLeft != nNODE:
			Code(Node[pPrimary].pLeft);
		Code(Node[pPrimary].pRight);
		Emit("call    EAX");
	default:
		StopInternal(__FILE__, __LINE__);
	end:switch

	Ref.pType = Node[pPrimary].pType;
	Ref.ID = iREG;
	Ref.IX = RegA;
	Ref.Offset = 0;
end

/*****************************************************************************/

word CodePrimary(word pPrimary; ValueRef @Ref)

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iCALL, iCALL2:
		Code_CALL(pPrimary, @Ref);

	case iINDEX:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		word P1 = Node[pPrimary].pRight;

		Ref.pType = T_ArrayDeref(Ref.pType);
		word Size = T_SizeOf(Ref.pType);

		if NodeIsLiteralWord(P1) then
			word IndexingOffset = Size * Node[P1].Value;
			Ref.Offset = Ref.Offset + IndexingOffset;
		else
			Code(P1);
			Ref.IX = Reg_TARGET;
			Emit_IMUL_Reg_Const(Ref.IX, 4, Size);
			when Reg_ALT_TARGET == RegNone:
				Reg_ALT_TARGET = Ref.IX;
		end:if

	case iLPTR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_LPTR(Node[pPrimary].pRight, @Ref);

	case iADDR:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		Code_ADDR(Node[pPrimary].pRight, @Ref);

	case iFIELD:
		CodePrimary(Node[pPrimary].pLeft, @Ref);
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	default:
		StopInternal(__FILE__, __LINE__);
	end

	return Ref.pType;
end

/*****************************************************************************/

word Code_LOAD(word pPrimary; ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	if Ref.ID==iREG then
		//when Ref.IX != Reg_TARGET:
		//	StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		return Ref.pType;
	end:if

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy3(@Buff, "mov     ", @CodeReg(NULL, Reg_TARGET, Size), ",  ");
		ValueRef_Code(@Buff, @Ref);
	default:
		strcpy3(@Buff, "lea     ", @CodeReg(NULL, Reg_TARGET, 4), ",  ");
		ValueRef_Code_ForLEA(@Buff, @Ref);
	end:select

	Emit(@Buff);

	return Ref.pType;
end

/*****************************************************************************/

void Code_STORE(ValueRef @Ref)
	char Buff[nBUFF];
	Buff[0] = #0;

	word Size = T_SizeOf(Ref.pType);

	select
	case IsNativeOperandSize(Size):
		strcpy(@Buff,"mov     ");
		ValueRef_Code(@Buff, @Ref);

		/*when Ref.IX != Reg_TARGET & Ref.IX != RegNone:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);*/

		select
		case Reg_TARGET != Reg_ALT_TARGET:
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, Reg_ALT_TARGET, Size)));

		case Ref.IX==RegA:
			EmitWithExprComment("pop     EBX", "restored in CodePrimary (STORE)");
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegB, Size)));

		case Ref.IX==RegB:
			EmitWithExprComment("pop     EAX", "restored in CodePrimary (STORE)");
			Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegA, Size)));
		end:select
	default:
		strcpy(@Buff,"lea     EDI,  ");
		ValueRef_Code_ForLEA(@Buff, @Ref);
		Emit(@Buff);

		if Reg_TARGET != Reg_ALT_TARGET then
			Emit(@strcpy2(@Buff,"mov     ESI,  ",@CodeReg(NULL, Reg_ALT_TARGET, 4)));
		else
			EmitWithExprComment("pop     ESI", "restored in CodePrimary (STORE)");
		end:if

		Emit("cld");
		Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
		Emit("rep     movsb");
		PHO_RegLoadConst(RegC, 0);
	end:select
end

/*****************************************************************************/

word Code_CAST(char @Buff; word P; word pTypeTo; word pTypeFrom; word Reg; word @Complexity)
	Complexity = 0;

	select
	case pTypeFrom == nDICT:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeFrom == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == pTypeFrom:
		null;
	case T_Equal(pTypeTo, pTypeFrom):
		null;
	case (T_IsInteger(pTypeTo) | pTypeTo == st_char)&
	     (T_IsInteger(pTypeFrom) | pTypeFrom == st_char):
		word SizeTo = T_SizeOf(pTypeTo);
		word SizeFrom = T_SizeOf(pTypeFrom);
		if SizeTo > SizeFrom then
			Complexity = 1;
			word Mask;
			switch SizeFrom of
			case 1: Mask = 0xFF;
			case 2: Mask = 0xFFFF;
			default: StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
			if @Buff != NULL then
				Emit(@CodeCmdRegConst(@Buff, "and", Reg, SizeTo, Mask));
			end:if
		end:if
	case T_IsPtr(pTypeTo) & T_IsPtr(pTypeFrom):
		null;
	case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom):
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end

	return pTypeTo;
end

/*****************************************************************************/

/*
	Для оптимизации генерируемого кода, нам требуется уметь отвечать на два вопроса:
	* Может ли ветка кода быть закодирована как MemRef (и формирование данного MemRef).
	* Может ли ветка кода быть закодирована с использованием только одного регистра.

	Для веток Primary алгоритм ответа на эти вопросы содержит по большей части
	идентичный код и отличается только в деталях.
	Эта вспомогательная функция проводит анализ веток Primary для одного из указанных
	вариантов анализа в зависимости от значения параметра Query.
*/

define Query_MemoryOperand 0
define Query_SingleRegOperand 1

struct OperandQuery
	word Query;
	ValueRef Ref;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query);
bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q);

bool QueryOperandStatus_CAST(word pPrimary; OperandQuery @_Q)
	word pTypeFrom = Node[Node[pPrimary].pLeft].pType;
	word pTypeTo = Node[pPrimary].pType;
	when !QueryOperandStatus_(Node[pPrimary].pLeft, @_Q):
		return false;
	word Complexity = 0;
	DisableEmit();
	pTypeTo = Code_CAST(NULL, pPrimary, pTypeTo, pTypeFrom, RegA, @Complexity);
	EnableEmit();
	if Complexity == 0 then
		ValueRef @Ref = @_Q.Ref;
		Ref.pType = pTypeTo;
		return true;
	else
		return false;
	end:if
end

bool QueryOperandStatus_(word pPrimary; OperandQuery @_Q)
	ValueRef @Ref = @_Q.Ref;
	word Query = _Q.Query;

	switch Node[pPrimary].ID of
	case iDATA, iPARM, iLOCAL, iSTRING:
		ValueRef_ExtractDataInfo(@Ref, pPrimary);

	case iLPTR:
		if Query == Query_SingleRegOperand then
			return QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		else
			return false;
		end:if

	case iINDEX:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_ArrayDeref(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if NodeIsLiteralWord(pIndex) then
			word IndexingOffset = Size * Node[pIndex].Value;
			Ref.Offset = Ref.Offset + IndexingOffset;
		else
			if Query != Query_SingleRegOperand then
				return false;
			end:if

			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
			Ref.IX = RegA;
		end:if

	case iADDR:
		if Query != Query_SingleRegOperand then
			return false;
		end:if

		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;

		Ref.pType = T_DerefPtr(Ref.pType);
		word Size = SizeOfType(Ref.pType);
		word pIndex = Node[pPrimary].pRight;

		if pIndex < nNODE & NodeIsLiteralWord(pIndex) & Node[pIndex].Value == 0 then
			pIndex = nNODE;
		end:if

		if pIndex < nNODE then
			when Ref.IX != RegNone:
				return false;
			when !CodeRequiresSingleRegister_(pIndex):
				return false;
		end:if
		Ref.Offset = 0;
		Ref.IX = RegA;

	case iFIELD:
		bool RecursiveResult = QueryOperandStatus_(Node[pPrimary].pLeft, @_Q);
		when !RecursiveResult:
			return RecursiveResult;
		ValueRef_Apply_FIELD(@Ref, pPrimary);

	case iCAST:
		return QueryOperandStatus_CAST(pPrimary, @_Q);
	default:
		return false;
	end

	return true;
end

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query)
	when (Query == Query_SingleRegOperand) & (@pTypeFinal != NULL):
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);

	OperandQuery _Q;
	_Q.Query = Query;
	bool Result = QueryOperandStatus_(pPrimary, @_Q);

	if Result then
		switch Query of
		case Query_MemoryOperand:
			ValueRef @Ref = @_Q.Ref;
			word Size = SizeOfType(Ref.pType);
			select
			case IsNativeOperandSize(Size):
				if @Buff !=  NULL then
					Buff[0] = #0;
					ValueRef_Code(@Buff, @Ref);
				end
				when @pTypeFinal != NULL:
					pTypeFinal = Ref.pType;
				return true;
			default:
				return false;
			end:select
		case Query_SingleRegOperand:
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
		end:switch
	end:if

	return Result;
end

/*****************************************************************************/

/*
	Если узел pPrimary может быть закодирован как MemRef,
	выводит в буфер Buff этот MemRef, а в pTypeFinal записывает тип выражения.
	Возввращает true при этом.
	Если узел pPrimary не может быть закодирован как MemRef, возвращает false.
*/

bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal)
	return QueryOperandStatus(@Buff, pPrimary, @pTypeFinal, Query_MemoryOperand);
end

bool NodeCanBeEncodedAsMemoryOperand(word pPrimary)
	return QueryOperandStatus(NULL, pPrimary, NULL, Query_MemoryOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister_(word P)
	when NodeCanBeEncodedAsImm(P):
		return true;

	word ID = Node[P].ID;

	switch ID of
	case iADD, iBIT_OR, iBIT_XOR, iBIT_AND:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		if
			(CodeRequiresSingleRegister_(pRight)) &
			(
				NodeCanBeEncodedAsImm(pLeft) |
				NodeCanBeEncodedAsMemoryOperand(pLeft)
			)
		then
			return true;
		end:if
		return false;
	case iSUB:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(pLeft)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				NodeCanBeEncodedAsMemoryOperand(pRight)
			)
		then
			return true;
		end:if
		return false;
	case iMUL:
		if T_SizeOf(Node[P].pType) != 4 then
			return false;
		end:if
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			NodeCanBeEncodedAsImm(pRight) &
			CodeRequiresSingleRegister_(pLeft)
		then
			return true;
		end:if
		if
			NodeCanBeEncodedAsImm(pLeft) &
			CodeRequiresSingleRegister_(pRight)
		then
			return true;
		end:if
		return false;
	case iBIT_NOT, iNEG:
		return CodeRequiresSingleRegister_(Node[P].pLeft);
	case iCAST:
		word pTypeFrom = Node[Node[P].pLeft].pType;
		word pTypeTo = Node[P].pType;
		when !CodeRequiresSingleRegister_(Node[P].pLeft):
			return false;
		word Complexity = 0;
		pTypeTo = Code_CAST(NULL, P, pTypeTo, pTypeFrom, RegA, @Complexity);
		if Complexity < 2 then
			return true;
		else
			return false;
		end:if
	end:switch

	return QueryOperandStatus(NULL, P, NULL, Query_SingleRegOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister(word P)
	bool Result;
	DisableEmit();
	Result = CodeRequiresSingleRegister_(P);
	EnableEmit();
	return Result;
end

/*****************************************************************************/

/** Returns true if the operands can be swapped for no cost. */
bool IsOperationCommutative(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return true;
	default:
		return false;
	end:switch
end

/** Checks if the operands can be swapped for no cost, but we should change the operation ID as well.
    Returns the code of swapped operation, if the operation is swappable.
    Returns zero otherwise.
*/
word CheckOperationSwappable(word ID)
	switch ID of
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end

bool DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightRegD(word ID)
	switch ID of
	case
		iDIV,
		iMOD:
		return false;
	default:
		return true;
	end:switch
end

/** A heuristic to determine whether it might be advantageous to change the order in which operands are evaluated.
    Returns NULL, if the operand evaluation should not be reordered.
    Returns a string describing the reason of reordering (for debugging purposes),
    if the operand evaluation should be reordered.
*/
char @CheckOperandReordering(word pLeft; word pRight)
	when NodeCanBeEncodedAsImm(pRight):
		return NULL;

	when CodeRequiresSingleRegister(pRight):
		return NULL;

	when NodeCanBeEncodedAsImm(pLeft):
		return "Imm on the left";

	when CodeRequiresSingleRegister(pLeft):
		return "Single-register operand on the left";

	return NULL;
end

/*****************************************************************************/

word TryDropCastBeforeCmp(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	when ID < iLT | iGT < ID:
		return nNODE;

	when Node[pRight].Value > 255: /* TODO: this case should be optimized out on the semantic analysis phase */
		return nNODE;

	when Node[pLeft].ID != iCAST:
		return nNODE;

	word pTypeFrom = Node[Node[pLeft].pLeft].pType;
	word pTypeTo = Node[pLeft].pType;

	when pTypeFrom != st_char & pTypeFrom != st_byte:
		return nNODE;

	when pTypeTo != st_word:
		return nNODE;

	return Node[pLeft].pLeft;
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight):
		null;
	case NodeCanBeEncodedAsImm(pLeft):
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2=Code(pLeft);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	word done = Emit_MUL_Reg_Const(Reg_TARGET, Size, RightValue);
	when done == 0:
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

define operandNotReady 0
define operandReg      1
define operandImm      2
define operandMemRef   3

word CodeBinOp(char @Buff; word P; LABEL @F; LABEL @T; LABEL @M)
	Buff[0] = #0;

	word ID = Node[P].ID;

	if iLT <= ID & ID <= iGT then
		/* These operations don't return the result in any register,
		instead a conditional jump is the result. So we can reset Reg_TARGET freely. */
		Reg_TARGET=RegA;
	end

	do
		word pType = TryCodeFastMult(@Buff,P);
		when pType < nDICT:
			return pType;
		exit;
	end:do

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if Reg_TARGET!=RegA then
			EmitWithExprComment("push    EAX", "saved in CodeBinOp");
			Reg_TARGET=RegA;
		end
	end:switch

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	char BuffRightOperand[nBUFF];
	word leftOperand  = operandNotReady;
	word rightOperand = operandNotReady;

	do
		/*
			The usual calculation scheme is:
				Reg1  <- LeftOperand
				Reg2  <- RightOperand
				OP    Reg1,  Reg2

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) then

			/*
				## Immediate constant on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  ImmValue
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2,  ImmValue
					Op    Reg1,  Reg1
			*/
			if NodeCanBeEncodedAsImm(pRight) then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  ImmValue
				Instead of:
					mov   Reg1,  ImmValue
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if IsOperationCommutative(ID) & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				ID = swappedID;
				exit;
			end:if

		end:if

		if DoesOperationAllowRightMemRef(ID) then

			/*
				## Simple memory reference on the right.
				Do:
					Reg1  <- LeftOperand
					Op    Reg1,  [MemRef]
				Instead of:
					Reg1  <- LeftOperand
					mov   Reg2, [MemRef]
					Op    Reg1, Reg2
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL) then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					Reg1  <- RightOperand
					Op    Reg1,  [MemRef]
				Instead of:
					mov   Reg1,  [MemRef]
					Reg2  <- RightOperand
					Op    Reg1,  Reg2
			*/
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				exit;
			end:if

		end:if

		exit;
	end:do

	word rightReg = RegNone;
	word fSwap=0;
	word pType;

	if (rightOperand == operandImm) &
	   (T_SizeOf(Node[pRight].pType) == 4) &
	   (PHO_RegContainsConst(Reg_TARGET, Node[pRight].Value))
	then
		do
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitWithExprComment("", "Const reuse in CodeBinOp");
				exit;
			end:if

			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitWithExprComment("", "Const reuse in CodeBinOp");
				exit;
			end:if

			exit;
		end:do
	end:if

	switch rightOperand of
	case operandImm:
		word pLeft2 = TryDropCastBeforeCmp(P);
		when pLeft2 < nNODE:
			pLeft = pLeft2;

		if iLT <= ID & ID <= iGT then
			when CodeRequiresSingleRegister(pLeft):
				Reg_TARGET = ChooseEmptyReg();
		end:if

		pType=Code(pLeft);

	case operandMemRef:
		if leftOperand == operandNotReady then
			if iLT <= ID & ID <= iGT then
				when CodeRequiresSingleRegister(pLeft):
					Reg_TARGET = ChooseEmptyReg();
			end:if

			pType=Code(pLeft);
		end:if

	case operandReg:
		null;

	case operandNotReady:
		char @reorderingReason = @CheckOperandReordering(pLeft, pRight);
		if @reorderingReason != NULL then
			EmitWithExprComment("", "Reordering in CodeBinOp");
			EmitWithExprComment("", @reorderingReason);
			word tmp = pLeft; pLeft = pRight; pRight = tmp;
			inc fSwap;
		end:if

		rightOperand = operandReg;
		rightReg = RegB;
		if CodeRequiresSingleRegister(pRight) then
			if DoesOperationAllowRightRegD(ID) & !PHO_RegContainsAConst(RegD) then
				rightReg = RegD;
			else
				rightReg = RegC;
			end:if
		end:if

		if Reg_TARGET != RegA then
			EmitWithExprComment("push    EAX", "saved in CodeBinOp");
			Reg_TARGET = RegA;
		end
		pType = Code(pLeft);
		Reg_TARGET  = rightReg;
		Code(pRight);
		when Reg_TARGET != rightReg & fSwap != 0:
			StopInternalCodegen(__FILE__, __LINE__);

		if Reg_TARGET==RegA then
			EmitWithExprComment("pop     EBX", "restored in CodeBinOp");
			inc fSwap;
		end
		Reg_TARGET = RegA;
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		do
			/* We can handle it by changing the operation ID */
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 then
				ID = swappedID;
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit(@CodeCmdRegReg(@Buff, "xchg", Reg_TARGET, 4, rightReg, 4));
				exit;
			end:switch

			/* If the operation is commutative, we don't care about the order. */
			when IsOperationCommutative(ID):
				exit;

			/* In other cases, swapped operands shouldn't happen. */
			StopInternalCodegen(__FILE__, __LINE__);
		end:do
	end:if

	word Size=SizeOfType(pType);

	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = -Value;

		switch Value of
		case 1:
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-1):
			if PreferIncDec(Reg_TARGET, Size) > 0 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case 2:
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		case word(-2):
			if PreferIncDec(Reg_TARGET, Size) > 1 then
				Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
				Emit(@Buff);
				MeaningfulFlags = (Flag_Zero | Flag_Sign);
				return pType;
			end:if
		end:switch
	end:if

	word _MeaningfulFlags = 0;

	select
	case iLT<=ID & ID<=iGT:

		if @T == NULL then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch

			@T = @F;
			@F = NULL;
		end:if

		if @T == NULL | @F != NULL then
			StopInternalCodegen(__FILE__, __LINE__);
		end

		select
		case rightOperand == operandImm:
			word Value = Node[pRight].Value;
			word PHO_Load_Value = Value;
			bool SkipCmp = false;
			switch Value of
			case 0:
				select
				case (ID == iEQ) | (ID == iNE):
					if (MeaningfulFlags & Flag_Zero) != 0 then
						null;
						SkipCmp = true;
					else
						Emit(@CodeCmdRegReg(@Buff, "test", Reg_TARGET, Size, Reg_TARGET, Size));
						SkipCmp = true;
					end:if
				case (MeaningfulFlags & (Flag_Zero | Flag_Sign)) == (Flag_Zero | Flag_Sign):
					select
					case (ID == iGE) & T_IsSigned(pType):
						ID = iBRANCH_NSF;
						SkipCmp = true;
					case (ID == iLT) & T_IsSigned(pType):
						ID = iBRANCH_SF;
						SkipCmp = true;
					end:select
				end:select
			case 1:
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "dec", Reg_TARGET, Size));
					dec PHO_Load_Value;
					SkipCmp = true;
				end:if
			case word(-1):
				if (ID == iEQ | ID == iNE) & PreferIncDec(Reg_TARGET, Size) != 0 then
					Emit(@CodeCmdReg(@Buff, "inc", Reg_TARGET, Size));
					inc PHO_Load_Value;
					SkipCmp = true;
				end:if
			end:switch
			if !SkipCmp then
				BuffRightOperand[0] = #0;
				if PHO_EncodeRegContainingConst(@BuffRightOperand, Value, Size) != 0 then
					Emit(@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand));
				else
					Emit(@CodeCmdRegConst(@Buff, "cmp", Reg_TARGET, Size, Value));
				end:if
			end:if
			when (Size == 4) & (ID == iNE):
				PHO_RegLoadConst(Reg_TARGET, PHO_Load_Value);
		case rightOperand == operandMemRef:
			Emit(@CodeCmdRegFmt(@Buff, "cmp", Reg_TARGET, Size, @BuffRightOperand));
		case rightOperand == operandReg:
			Emit(@CodeCmdRegReg(@Buff, "cmp", Reg_TARGET, Size, rightReg, Size));
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end

		char@ BranchCondition = "";
		select
		case T_IsSigned(pType):
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			case iBRANCH_SF: @BranchCondition = "s ";
			case iBRANCH_NSF: @BranchCondition = "ns";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, @T);

		return nDICT;

	case ID==iBIT_OR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		_MeaningfulFlags = Flag_Zero;
		strcpy(@Buff,"and     ");

	case ID==iADD:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		_MeaningfulFlags = (Flag_Zero | Flag_Sign);
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pType):
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pType):
			strcpy(@Buff,"mul     ");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		switch rightOperand of
		case operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch

		Emit(@Buff);
		return pType;

	case ID==iDIV | ID==iMOD:
		select
		case Size==1:
			if T_IsSigned(pType) then
				Emit("movsx   AX,   AL");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     AH,   AH");
				strcpy(@Buff,"div     ");
			end:if
		case Size==2:
			if T_IsSigned(pType) then
				Emit("cwq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     DX,   DX");
				strcpy(@Buff,"div     ");
			end:if
		case Size==4:
			if T_IsSigned(pType) then
				Emit("cdq");
				strcpy(@Buff,"idiv    ");
			else
				Emit("xor     EDX,  EDX");
				strcpy(@Buff,"div     ");
			end:if
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		select
		case rightOperand == operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		Emit(@Buff);

		if ID==iMOD then
			/*
				XCHG is encoded as a single byte for native-length registers:
				0x92 - xchg AX, DX (16-bit mode), xchg EAX, EDX (32-bit mode)
				MOV takes 2 bytes.
				So we prefer XCHG when optimizing for size.
				See also notes on XCHG performance:
				https://stackoverflow.com/questions/45766444/why-is-xchg-reg-reg-a-3-micro-op-instruction-on-modern-intel-architectures
			*/
			select
			case Size==1:
				Emit("mov     AL,   AH");
			case Size==2:
				if EmitShortCode != 0 then
					Emit("xchg    AX,   DX");
				else
					Emit("mov     AX,   DX");
				end:if
			case Size==4:
				if EmitShortCode != 0 then
					Emit("xchg    EAX,  EDX");
				else
					Emit("mov     EAX,  EDX");
				end:if
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:select
		end:if

		return pType;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	select
	case IsNativeOperandSize(Size):
		select
		case rightOperand == operandImm:
			/*
				XXX: The commented out code is mostly useless in the current implementation
				I can't find any expression when that condition actually triggers.
				May be useful when a full-featured register allocation strategy will be implemented.
			*/
			/*if PHO_EncodeRegContainingConst(@BuffRightOperand, Node[pRight].Value, Size) != 0 then
				CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
			else*/
				CodeRegConst(@Buff, Reg_TARGET, Size, Node[pRight].Value);
			/*end:if*/
		case rightOperand == operandMemRef:
			CodeRegFmt(@Buff, Reg_TARGET, Size, @BuffRightOperand);
		case rightOperand == operandReg:
			CodeRegReg(@Buff, Reg_TARGET, Size, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
		Emit(@Buff);
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	MeaningfulFlags = _MeaningfulFlags;
	return pType;
end

/*****************************************************************************/

/*
	Генерация кода для условных переходов из булевых выражений.

	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word CodeBooleanExpr(word P; LABEL @F; LABEL @T; LABEL @M)
	char Buff[nBUFF];
	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when @T != NULL & @F != NULL: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	when Node[P].pType != st_bool:
		StopInternalCodegen(__FILE__, __LINE__);

	/* These operations don't return the result in any register,
	instead a conditional jump is the result. So we reset Reg_TARGET here. */
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;

	switch Node[P].ID of
	case iLITERAL:
		select
		case Node[P].Value == 0 & @F != NULL:
			EmitJumpToLabel(@F);
		case Node[P].Value != 0 & @T != NULL:
			EmitJumpToLabel(@T);
		end:select
		return st_bool;

	case iLT, iLE, iEQ, iNE, iGE, iGT:
		return CodeBinOp(@Buff, P, @F, @T, @M);

	case iNOT:
		return CodeBooleanExpr(Node[P].pLeft, @T, @F, @M);
	case iOR:
		Code_OR(P, @F, @T, @M, @Buff);
		return st_bool;
	case iXOR:
		Code_XOR(P, @F, @T, @M, @Buff);
		//return st_bool;
	case iEQV:
		Code_EQV(P, @F, @T, @M, @Buff);
		//return st_bool;
	case iAND:
		Code_AND(P, @F, @T, @M, @Buff);
		return st_bool;

	default:
		when CodeRequiresSingleRegister(P):
			Reg_TARGET = ChooseEmptyReg();
		Code(P);
		Emit(@CodeCmdRegReg(@Buff, "test", Reg_TARGET, 4, Reg_TARGET, 4));
		select
		case @F != NULL:
			EmitBranchToLabel("z", @F);
		case @T != NULL:
			EmitBranchToLabel("nz", @T);
		end:select
		return st_bool;

	end:switch
end

/*****************************************************************************/

word Code_INCDEC(word pPrimary)
	char Buff[nBUFF];
	Buff[0] = #0;

	ValueRef Ref;
	CodePrimary(Node[pPrimary].pLeft, @Ref);

	if Ref.IX > RegA then
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
	end:if

	if Node[pPrimary].ID==iINC then
		strcpy(@Buff,"inc     ");
	else
		strcpy(@Buff,"dec     ");
	end:if

	word Size = T_SizeOf(Ref.pType);
	select
	case IsNativeOperandSize(Size):
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
	end:select

	Emit(@ValueRef_Code(@Buff, @Ref));

	return st_void;
end

/*****************************************************************************/

word Code_ASSIGN(word P)
	word P1 = Node[P].pLeft;
	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegNone;

	if Node[P1].pRight < nNODE then
		Code(Node[P1].pRight);
		Reg_ALT_TARGET = Reg_TARGET;
		Reg_TARGET = RegB;
		ValueRef Ref;
		CodePrimary(Node[P1].pLeft, @Ref);
		Code_STORE(@Ref);
	else
		Code(Node[P1].pLeft);
	end

	Reg_TARGET = RegA;
	Reg_ALT_TARGET = RegA;
	return Node[P].pType;
end

/*****************************************************************************/

word CodePrimaryWrapped(word P)
	ValueRef Ref;
	CodePrimary(P, @Ref);
	Code_LOAD(P, @Ref);
	return Ref.pType;
end

/*****************************************************************************/

word Code(word P)
	char Buff[nBUFF];
	Buff[0] = #0;

	when P == nNODE:
		return st_void;
		//StopInternalCodegen(__FILE__, __LINE__);

	when P > nNode:
		StopInternalCodegen(__FILE__, __LINE__);

	EmitWithSourceNote(NULL, P);

	switch Node[P].ID of
	case iNULL:
		Emit_Load_Constant(Reg_TARGET, 4, 0);
		return Node[P].pType;

	case iLITERAL:
		Emit_Load_Constant(Reg_TARGET, T_SizeOf(Node[P].pType), Node[P].Value);
		return Node[P].pType;

	case iFUNC:
		CodeLoadLabel(@Buff, Reg_TARGET, Node[P].Value);
		Emit(@Buff);
		return Node[P].pType;

	case iINC, iDEC:
		return Code_INCDEC(P);

	case iDATA, iPARM, iLOCAL, iSTRING,
	     iCALL, iCALL2, iINDEX, iLPTR, iADDR, iFIELD:
		return CodePrimaryWrapped(P);

	case iCAST:
		word pTypeFrom = Code(Node[P].pLeft);
		word pTypeTo = Node[P].pType;
		word Complexity = 0;
		return Code_CAST(@Buff, P, pTypeTo, pTypeFrom, Reg_TARGET, @Complexity);

	case iBIT_NOT:
		word pType = Code(Node[P].pLeft);
		word  Size = SizeOfType(pType);
		Emit(@CodeCmdReg(@Buff, "not", Reg_TARGET, Size));

		return pType;

	case iNEG:
		if NodeIsLiteralWord(Node[P].pLeft) then
			Emit_Load_Constant(Reg_TARGET, 4, -Node[Node[P].pLeft].Value);
			return Node[P].pType;
		end

		Code(Node[P].pLeft);

		Emit(@CodeCmdReg(@Buff, "neg", Reg_TARGET, T_SizeOf(Node[P].pType)));

		return Node[P].pType;

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
		return CodeBinOp(@Buff, P, NULL, NULL, NULL);

	case iDEF_LOCAL:
		if nLocal>=nLOCAL then
			StopMemory();
		end

		word pType = Node[P].pType;
		word Size  = SizeOfType(pType);

		AllocatedFrameSize = AllocatedFrameSize + DefaultInStackAlign(Size);

		word i = nLocal;
		inc nLocal;
		Local[i].pType=pType;
		Local[i].Value=AllocatedFrameSize;
		when EmitDebugComments_LocalDefs:
			EmitLine(NULL, "", @strcpy4(@Buff, "iDEF_LOCAL: ",@Char[Node[P].Value]," ",@str(Local[i].Value)));

		Code(Node[P].pLeft);

	case iASSIGN:
		return Code_ASSIGN(P);

	case iINLINE:
		Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16)));

	case iPUSH:
		Code_PUSH(P, @Buff);
	case iRETURN:
		return Code_RETURN(P, @Buff);
	case iSELECT:
		return Code_SELECT(P, @Buff);
	case iSWITCH:
		return Code_SWITCH(P, @Buff);
	case iWHILE:
		return Code_WHILE(P, @Buff);
	case iREPEAT:
		return Code_REPEAT(P, @Buff);
	case iCONTINUE:
		return Code_CONTINUE(P, @Buff);
	case iEXIT:
		return Code_EXIT(P, @Buff);
	case iEMPTY, iVIRTUAL_JUMP:
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end:switch

	return nDICT;
end

/*****************************************************************************/

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	if Dict[I].Sub != sMAIN then
		strcat(@Buff, @DictGetName(I));
	else
		strcat(@Buff, "<begin>");
	end:if
	strcat(@Buff," ##");
	LABEL L; L.Value = Dict[I].Label;
	EmitLine(@L, "", @Buff);

	word S1 = 0;

	word pARGS = FindInNamespace("args", I);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = S1 + 8;
		S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while

	PHO_InvalidateRegs();

	if EmitEnterInstruction != 0 & Dict[I].StackSize > 0 then
		Emit(@strcpy3(@Buff,"enter   ",@str(Dict[I].StackSize), ", 0"));
	else
		Emit("push    EBP");
		Emit("mov     EBP,  ESP");

		if Dict[I].StackSize > 0 then
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(Dict[I].StackSize)));
		end:if
	end:if

	if Dict[I].Sub == sMAIN then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == false then
					Code(Dict[J].pNode);
				end:if
			end:if

			inc J;
		end:while
	end:if

	pFunc = I;
	ParmFrameSize = S1;
	AllocatedFrameSize = 0;

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  pType = st_void;
	while P < nNODE do
		pType = Code(P);
		when pType == st_noreturn:
			exit;
		P  = Node[P].pRight;
	end

	if pType != st_noreturn then
		word pRet = Peek();
		Node[pRet].ID = iRETURN;
		Code(pRet);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word EmitFunctions(char @Buff)
	word Start = 0;

	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				when Dict[I].Sub == sMAIN:
					Start = Dict[I].Label;
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when Start == 0:
		StopInternalCodegen(__FILE__, __LINE__);

	return Start;
end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word Start = EmitFunctions(@Buff);

	return Start;

end

/*****************************************************************************/

