
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */

/*
Active register.

When entering a function for generating code for an operation:

 * If fEAX == RegA, the caller expects the result to be places in RegA.
   The code may use both RegA and RegB and should return the result in RegA.

 * If fEAX == RegB, the caller expects the result to be placed in RegB.
   RegA is used by the caller to store a value.
   The code either returns the result in RegB and keeps the value of RegA untouched.
   Or stores RegA on the stack, sets fEAX = RegA and return the result in RegA.
   In the latter case, the caller normally pops the value from the stack to RegB,
   and does the calculation with the swapped arguments.
*/
word fEAX;

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		word pType = _Code(P,0,0,0);
		when pType == st_noreturn:
			return st_noreturn;
		P = Node[P].pRight;
	end
	return st_void;
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	word pType = Code_List(P);
	Code_EndBlock(@CB);
	return pType;
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word pPrimary)

	char Buff [nBUFF];
	Buff[0] = #0;

	word IncID=Node[pPrimary].ID;
	if IncID==iINC | IncID==iDEC then
		fEAX=RegA;
		pPrimary = Node[pPrimary].pLeft;
	end

	word pType;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(pPrimary, @pType, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do
		Buff[0] = #0;
		select
		case P1>=nNODE:
			select
			case IncID==iINC | IncID==iDEC:
				if IX > RegA then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:if

				if IncID==iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=SizeOfType(pType);
				select
				case Size==1 | Size==4:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);
				end:select

				Emit(@CodeDataIX_offset(@Buff, Size, ID, IX, Ofs));

				return st_void;

			case ID==iCALL:
				return pType;

			default:
				word Size = SizeOfType(pType);

				select
				case Size==1 | Size==4:
					strcpy(@Buff,"mov     ");
					CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);

					select
					case fEAX!=RegA:
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegA, Size)));

					case IX==RegA:
						Emit("pop     EBX");
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegB, Size)));

					case IX==RegB:
						Emit("pop     EAX");
						Emit(@strcat2(@Buff,", ",@CodeReg(NULL, RegA, Size)));
					end:select
				default:
					strcpy(@Buff,"lea     EDI,  ");
					CodeDataIX_offset(@Buff, 0, ID, IX, Ofs);
					Emit(@Buff);

					if fEAX!=RegA then
						Emit("mov     ESI,  EAX");
					else
						Emit("pop     ESI");
					end:if

					Emit("cld");
					Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
					Emit("rep     movsb");
				end:select

				return st_void;

			end:select

			StopAtNodeInternalCodegen(__FILE__, __LINE__, pPrimary);

		case Node[P1].ID==iLOAD:

			if IX==RegNone & ID==iCALL then
				return pType;
			end:if

			word Size = SizeOfType(pType);

			select
			case Size==1 | Size==4:
				strcpy3(@Buff, "mov     ", @CodeReg(NULL, fEAX, Size), ",  ");
				CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);
			default:
				strcpy3(@Buff, "lea     ", @CodeReg(NULL, fEAX, 4), ",  ");
				CodeDataIX_offset(@Buff, 0, ID, IX, Ofs);
			end:select

			Emit(@Buff);

			return pType;

		case Node[P1].ID==iLPTR:
			char @TX = @CodeReg(NULL, fEAX, 4);

			if IX!=RegNone then
				if fEAX!=IX then
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:if

				select
				case ID==iDATA:
					Emit(@strcpy4(@Buff,"add     ",@TX,",  @@DATA+",@str(Ofs)));
				case ID==iPARM:
					Emit(@strcpy7(@Buff,"lea     ",@TX,",  [EBP+",@TX,"+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcpy7(@Buff,"lea     ",@TX,",  [EBP+",@TX,"-",@str(Ofs),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy5(@Buff,"add     ",@TX,",  ", @s,@str(Ofs)));
				case ID==iREF & Ofs!=0:
					Emit(@strcpy4(@Buff,"add     ",@TX,",  ",@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcpy4(@Buff,"mov     ",@TX,",  @@DATA+",@str(Ofs)));
				case ID==iPARM:
					Emit(@strcpy5(@Buff,"lea     ",@TX,",  [EBP+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcpy5(@Buff,"lea     ",@TX,",  [EBP-",@str(Ofs),"]"));
				case ID==iSTRING:
					char @s = "@@ROLITERALS+";
					when RO == 0:
						@s = "@@RWLITERALS+";
					Emit(@strcpy5(@Buff,"mov     ",@TX,",  ",@s,@str(Ofs)));
				case ID!=iCALL:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			return T_PtrTo(pType);

		case Node[P1].ID==iCALL:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub==sSYS then
				Emit(@strcpy3(@Buff,"call   [@",@str(Dict[Node[P1].Value].Label),"]"));
			else
				EmitLine(0,
					@strcpy2(@Buff,"call    @",@str(Dict[Node[P1].Value].Label)),
					@DictGetName(Node[P1].Value)
					);
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID==iCALL2:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit("call    EAX");

			pType=Dict[Node[P1].Value].pType;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID==iINDEX:
			word Size = SizeOfType(pType);

			if NodeIsLiteralWord(Node[P1].pLeft) then
				word IndexingOffset = Size * Node[Node[P1].pLeft].Value;
				if ID != iLOCAL then
					Ofs = Ofs + IndexingOffset;
				else
					Ofs = Ofs - IndexingOffset;
				end
			else
				_Code(Node[P1].pLeft,0,0,0);
				IX=fEAX;
				Emit_IMUL_Reg_Const(IX, 4, Size);
			end:if

		case Node[P1].ID==iADDR:
			if !T_IsPtr(pType) then
				StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
			end:if

			pType = T_DerefPtr(pType);
			word Size = SizeOfType(pType);

			word pLeft = Node[P1].pLeft;

			if pLeft < nNODE & NodeIsLiteralWord(pLeft) & Node[pLeft].Value == 0 then
				pLeft = nNODE;
			end:if

			if pLeft < nNODE then
				select
				case IX==RegB:
					if fEAX!=RegA then
						Emit("push    EAX");
					end:if

					Emit("xchg    EAX,  EBX");
					IX  =RegA;
					fEAX=RegB;

				case IX==RegA:
					fEAX=RegB;
				end:select

				_Code(pLeft,0,0,0);

				Emit_IMUL_Reg_Const(fEAX, 4, Size);
				if fEAX==RegA then
					if IX!=RegNone then
						Emit("pop     EBX");
						IX=RegB;
					end:if
					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX==RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=RegNone then
				char @RX = @CodeReg(NULL, IX, 4);

				select
				case ID==iDATA:
					Emit(@strcat5(@Buff,"[@@DATA+",@RX,"+",@str(Ofs),"]"));
				case ID==iPARM:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat5(@Buff,"[EBP+",@RX,"-",@str(Ofs),"]"));
				case ID==iREF:
					Emit(@strcat5(@Buff,"[",@RX,"+",@str(Ofs),"]"));
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			else
				select
				case ID==iDATA:
					Emit(@strcat3(@Buff,"[@@DATA+",@str(Ofs),"]")); // FASM
				case ID==iPARM:
					Emit(@strcat3(@Buff,"[EBP+",@str(Ofs),"]"));
				case ID==iLOCAL:
					Emit(@strcat3(@Buff,"[EBP-",@str(Ofs),"]"));
				//TODO Пpовеpить!
				case ID==iCALL:
					null;
				default:
					StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
				end:select
			end:if

			if fEAX==RegA then
				IX=RegA;
			else
				if IX!=RegNone then
					fEAX=RegA;
				end:if

				IX=RegB;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID==iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);
			when T_IsArray(pType):
				pType = T_ArrayDeref(pType);

		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P1);
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

word Code_CAST(char @Buff; word P; word pTypeTo; word pTypeFrom; word Reg; word @Complexity)
	Complexity = 0;

	select
	case pTypeFrom == nDICT:
		null; /* FIXME: should trigger internal error */
		//StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeFrom == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == st_void:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	case pTypeTo == pTypeFrom:
		null;
	case T_Equal(pTypeTo, pTypeFrom):
		null;
	case pTypeTo==st_char & pTypeFrom==st_byte:
		null;
	case pTypeTo==st_char & pTypeFrom==st_word:
		null;
	case pTypeTo==st_char & pTypeFrom==st_int:
		null;
	case pTypeTo==st_byte & pTypeFrom==st_char:
		null;
	case pTypeTo==st_byte & pTypeFrom==st_int:
		null;
	case pTypeTo==st_byte & pTypeFrom==st_word:
		null;
	case pTypeTo==st_word & pTypeFrom==st_char:
		Complexity = 1;
		Emit(@CodeCmdRegConst(@Buff, "and", Reg, 4, 0xFF));
	case pTypeTo==st_word & pTypeFrom==st_byte:
		Complexity = 1;
		Emit(@CodeCmdRegConst(@Buff, "and", Reg, 4, 0xFF));
	case pTypeTo==st_word & pTypeFrom==st_int:
		null;
	case pTypeTo==st_int & pTypeFrom==st_char:
		Complexity = 1;
		Emit(@CodeCmdRegConst(@Buff, "and", Reg, 4, 0xFF));
	case pTypeTo==st_int & pTypeFrom==st_byte:
		Complexity = 1;
		Emit(@CodeCmdRegConst(@Buff, "and", Reg, 4, 0xFF));
	case pTypeTo==st_int & pTypeFrom==st_word:
		null;
	case T_IsPtr(pTypeTo) & T_IsPtr(pTypeFrom):
		null;
	case (pTypeTo == st_intptr | pTypeTo == st_uintptr) & T_IsPtr(pTypeFrom):
		null;
	default:
		StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
	end

	return pTypeTo;
end

/*****************************************************************************/

/*
	Для оптимизации генерируемого кода, нам требуется уметь отвечать на два вопроса:
	* Может ли ветка кода быть закодирована как MemRef (и формирование данного MemRef).
	* Может ли ветка кода быть закодирована с использованием только одного регистра.

	Для веток Primary алгоритм ответа на эти вопросы содержит по большей части
	идентичный код и отличается только в детялях.
	Эта вспомогательная функция проводит анализ веток Primary для одного из указанных
	вариантов анализа в зависимости от значения параметра Query.
*/

define Query_MemoryOperand 0
define Query_SingleRegOperand 1

bool QueryOperandStatus(char @Buff; word pPrimary; word @pTypeFinal; word Query)

	switch Node[pPrimary].ID of
	case iCAST:
		word pTypeFrom = nDICT;
		word pTypeTo = Node[pPrimary].pType;
		bool RecursiveResult = QueryOperandStatus(@Buff, Node[pPrimary].pLeft, @pTypeFrom, Query);
		when !RecursiveResult:
			return RecursiveResult;
		word Complexity = 0;
		char tmpBuff[nBUFF]; tmpBuff[0] = #0;
		DisableEmit();
		pTypeTo = Code_CAST(@tmpBuff, pPrimary, pTypeTo, pTypeFrom, RegA, @Complexity);
		EnableEmit();
		if Complexity == 0 then
			when @pTypeFinal != NULL:
				pTypeFinal = pTypeTo;
			return RecursiveResult;
		else
			return false;
		end:if
	case iDATA, iPARM, iLOCAL, iSTRING:
		null;
	default:
		return false;
	end:switch

	word pType;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(pPrimary, @pType, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[pPrimary].pLeft;
	do

		select
		case P1>=nNODE:
			return false;

		case Node[P1].ID==iLOAD:
			word Size = SizeOfType(pType);

			select
			case Size==1 | Size==4:
				Buff[0] = #0;
				CodeDataIX_offset(@Buff, Size, ID, IX, Ofs);
				when @pTypeFinal != NULL:
					pTypeFinal = pType;
				return true;

			default:
				return false;
			end:select

		case Node[P1].ID==iLPTR:
			if Query == Query_SingleRegOperand then
				return true;
			else
				return false;
			end:if

		case Node[P1].ID==iINDEX:
			word Size = SizeOfType(pType);

			if NodeIsLiteralWord(Node[P1].pLeft) then
				word IndexingOffset = Size * Node[Node[P1].pLeft].Value;
				if ID != iLOCAL then
					Ofs = Ofs + IndexingOffset;
				else
					Ofs = Ofs - IndexingOffset;
				end
			else
				if Query != Query_SingleRegOperand then
					return false;
				end:if

				when IX != RegNone:
					return false;
				when !_CodeRequiresSingleRegister_(@Buff, Node[P1].pLeft, @pTypeFinal):
					return false;
				IX = RegA;
			end:if

		case Node[P1].ID==iADDR:
			if Query != Query_SingleRegOperand then
				return false;
			end:if

			pType = T_DerefPtr(pType);
			word Size = SizeOfType(pType);

			word pLeft = Node[P1].pLeft;

			if pLeft < nNODE & NodeIsLiteralWord(pLeft) & Node[pLeft].Value == 0 then
				pLeft = nNODE;
			end:if

			if pLeft < nNODE then
				when IX != RegNone:
					return false;
				when !_CodeRequiresSingleRegister_(@Buff, pLeft, @pTypeFinal):
					return false;
			end:if
			Ofs = 0;
			IX = RegA;

		case Node[P1].ID==iFIELD:
			CodeData_FIELD(@P1, @pType, @ID, @Ofs);
			when T_IsArray(pType):
				pType = T_ArrayDeref(pType);

		default:
			return false;
		end:select

		P1=Node[P1].pRight;
	end:do

	return false;

end

/*****************************************************************************/

/*
	Если узел pPrimary может быть закодирован как MemRef,
	выводит в буфер Buff этот MemRef, а в pTypeFinal записывает тип выражения.
	Возввращает true при этом.
	Если узел pPrimary не может быть закодирован как MemRef, возвращает false.
*/

bool CodeAsMemoryOperand(char @Buff; word pPrimary; word @pTypeFinal)
	return QueryOperandStatus(@Buff, pPrimary, @pTypeFinal, Query_MemoryOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister_(char @tmpBuff; word P; word @pTypeFinal)
	when NodeCanBeEncodedAsImm(P):
		return true;

	word ID = Node[P].ID;

	switch ID of
	case iADD, iBIT_OR, iBIT_XOR, iBIT_AND:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				CodeAsMemoryOperand(@tmpBuff, pRight, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pRight, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pLeft) |
				CodeAsMemoryOperand(@tmpBuff, pLeft, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iSUB:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			(CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)) &
			(
				NodeCanBeEncodedAsImm(pRight) |
				CodeAsMemoryOperand(@tmpBuff, pRight, @pTypeFinal)
			)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iMUL:
		word pLeft = Node[P].pLeft;
		word pRight = Node[P].pRight;
		if
			NodeCanBeEncodedAsImm(pRight) &
			CodeRequiresSingleRegister_(@tmpBuff, pLeft, @pTypeFinal)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		if
			NodeCanBeEncodedAsImm(pLeft) &
			CodeRequiresSingleRegister_(@tmpBuff, pRight, @pTypeFinal)
		then
			pTypeFinal = Node[P].pType;
			return true;
		end:if
		return false;
	case iBIT_NOT, iNEG:
		return CodeRequiresSingleRegister_(@tmpBuff, Node[P].pLeft, @pTypeFinal);
	case iCAST:
		word pTypeFrom = nDICT;
		word pTypeTo = Node[P].pType;
		bool RecursiveResult = CodeRequiresSingleRegister_(@tmpBuff, Node[P].pLeft, @pTypeFrom);
		when !RecursiveResult:
			return RecursiveResult;
		word Complexity = 0;
		tmpBuff[0] = #0;
		pTypeTo = Code_CAST(@tmpBuff, P, pTypeTo, pTypeFrom, RegA, @Complexity);
		if Complexity < 2 then
			when @pTypeFinal != NULL:
				pTypeFinal = pTypeTo;
			return RecursiveResult;
		else
			return false;
		end:if
	end:switch

	return QueryOperandStatus(@tmpBuff, P, @pTypeFinal, Query_SingleRegOperand);
end

/*****************************************************************************/

bool CodeRequiresSingleRegister(word P)
	bool Result;
	word pTypeFinal;
	char tmpBuff[nBUFF];
	tmpBuff[0] = #0;
	DisableEmit();
	Result = CodeRequiresSingleRegister_(@tmpBuff, P, @pTypeFinal);
	EnableEmit();
	return Result;
end

/*****************************************************************************/

/** Returns true if the operands can be swapped for no cost. */
bool IsOperationCommutative(word ID)
	switch ID of
	case iBIT_OR, iBIT_XOR, iBIT_AND, iADD, iMUL, iEQ, iNE:
		return true;
	default:
		return false;
	end:switch
end

/** Checks if the operands can be swapped for no cost, but we should change the operation ID as well.
    Returns the code of swapped operation, if the operation is swappable.
    Returns zero otherwise.
*/
word CheckOperationSwappable(word ID)
	switch ID of
	case iLT: return iGT;
	case iLE: return iGE;
	case iGE: return iLE;
	case iGT: return iLT;
	end:switch
	return 0;
end

bool DoesOperationAllowRightMemRef(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

bool DoesOperationAllowRightImm(word ID)
	switch ID of
	case
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iADD,
		iSUB,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT:
		return true;
	default:
		return false;
	end:switch
end

/** A heuristic to determine whether it might be advantageous to change the order in which operands are evaluated.
    Returns NULL, if the operand evaluation should not be reordered.
    Returns a string describing the reason of reordering (for debugging purposes),
    if the operand evaluation should be reordered.
*/
char @CheckOperandReordering(word pLeft; word pRight)
	when NodeCanBeEncodedAsImm(pRight):
		return NULL;

	when CodeRequiresSingleRegister(pRight):
		return NULL;

	when NodeCanBeEncodedAsImm(pLeft):
		return "Imm on the left";

	when CodeRequiresSingleRegister(pLeft):
		return "Single-register operand on the left";

	return NULL;
end

/*****************************************************************************/

word TryDropCastBeforeCmp(word P)

	word ID = Node[P].ID;
	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	when ID < iLT | iGT < ID:
		return nNODE;

	when Node[pRight].Value > 255: /* TODO: this case should be optimized out on the semantic analysis phase */
		return nNODE;

	when Node[pLeft].ID != iCAST:
		return nNODE;

	word pTypeFrom = Node[Node[pLeft].pLeft].pType;
	word pTypeTo = Node[pLeft].pType;

	when pTypeFrom != st_char & pTypeFrom != st_byte:
		return nNODE;

	when pTypeTo != st_word:
		return nNODE;

	return Node[pLeft].pLeft;
end

/*****************************************************************************/

word TryCodeFastMult(char @Buff; word P)
	when Node[P].ID != iMUL:
		return nDICT;

	word pType = Node[P].pType;
	word Size = SizeOfType(pType);

	when Size != 4:
		return nDICT;

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	select
	case NodeCanBeEncodedAsImm(pRight):
		null;
	case NodeCanBeEncodedAsImm(pLeft):
		word tmp = pLeft; pLeft = pRight; pRight = tmp;
	default:
		return nDICT;
	end:select

	word RightValue = Node[pRight].Value;
	word nMulTrick = FindMulTrick(RightValue);
	when nMulTrick >= nMUL_TRICKS:
		return nDICT;

	word pType2=_Code(pLeft,0,0,0);

	when pType != pType2:
		StopInternalCodegen(__FILE__, __LINE__);

	word done = Emit_MUL_Reg_Const(fEAX, Size, RightValue);
	when done == 0:
		StopInternalCodegen(__FILE__, __LINE__);
	return pType;
end

/*****************************************************************************/

define operandNotReady 0
define operandReg      1
define operandImm      2
define operandMemRef   3

word CodeBinOp(char @Buff; word P; word F; word T; word M)
	Buff[0] = #0;

	word ID = Node[P].ID;

	if iLT <= ID & ID <= iGT then
		/* These operations don't return the result in any register,
		instead a conditional jump is the result. So we can reset fEAX freely. */
		fEAX=RegA;
	end

	do
		word pType = TryCodeFastMult(@Buff,P);
		when pType < nDICT:
			return pType;
		exit;
	end:do

	switch ID of
	case iMUL, iDIV, iMOD: /* For these operations we need EAX unconditionally.  */
		if fEAX!=RegA then
			EmitLine(0, "push    EAX", "saved in CodeBinOp");
			fEAX=RegA;
		end
	end:switch

	word pLeft = Node[P].pLeft;
	word pRight = Node[P].pRight;

	char BuffRightOperand[nBUFF];
	word leftOperand  = operandNotReady;
	word rightOperand = operandNotReady;

	do
		/*
			The usual calculation scheme is:
				RegA  <- LeftOperand
				RegB  <- RightOperand
				OP    RegA,  RegB

			We can handle some special cases in a more efficient way:
		*/

		if DoesOperationAllowRightImm(ID) then

			/*
				## Immediate constant on the right.
				Do:
					RegA  <- LeftOperand
					Op    RegA,  ImmValue
				Instead of:
					RegA  <- LeftOperand
					mov   RegB,  ImmValue
					Op    RegA,  RegB
			*/
			if NodeCanBeEncodedAsImm(pRight) then
				rightOperand = operandImm;
				exit;
			end:if

			/*
				## Immediate constant on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					RegA  <- RightOperand
					Op    RegA,  ImmValue
				Instead of:
					mov   RegA,  ImmValue
					RegB  <- RightOperand
					Op    RegA,  RegB
			*/
			if IsOperationCommutative(ID) & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 & NodeCanBeEncodedAsImm(pLeft) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandImm;
				ID = swappedID;
				exit;
			end:if

		end:if

		if DoesOperationAllowRightMemRef(ID) then

			/*
				## Simple memory reference on the right.
				Do:
					RegA  <- LeftOperand
					Op    RegA,  [MemRef]
				Instead of:
					RegA  <- LeftOperand
					mov   RegB, [MemRef]
					Op    RegA, RegB
			*/
			if CodeAsMemoryOperand(@BuffRightOperand, pRight, NULL) then
				rightOperand = operandMemRef;
				exit;
			end:if

			/*
				## Simple memory reference on the left
				   and the operation is commutative
				   or can be calculated in the reverse order.
				Do:
					RegA  <- RightOperand
					Op    RegA,  [MemRef]
				Instead of:
					mov   RegA,  [MemRef]
					RegB  <- RightOperand
					Op    RegA,  RegB
			*/
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				exit;
			end:if

			/* Operation isn't commutative. Check if the operands can be swapped by just changing the op ID.*/
			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				exit;
			end:if

		end:if

		exit;
	end:do

	word rightReg = RegNone;
	word fSwap=0;
	word pType;

	/* Try reusing a constant in the target register.
	   This optimisation may potentially affect CPU register aliasing,
	   so enabling it only when optimizing for size. */
	if (EmitShortCode != 0) &
	   (rightOperand == operandImm) &
	   (T_SizeOf(Node[pRight].pType) == 4) &
	   (PHO_RegContainsConst(fEAX, Node[pRight].Value))
	then
		do
			if IsOperationCommutative(ID) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitLine(0, "", "Const reuse in CodeBinOp");
				exit;
			end:if

			word swappedID = CheckOperationSwappable(ID);
			if (swappedID != 0) & CodeAsMemoryOperand(@BuffRightOperand, pLeft, NULL) then
				word tmp = pLeft; pLeft = pRight; pRight = tmp;
				rightOperand = operandMemRef;
				ID = swappedID;
				leftOperand = operandReg;
				pType = Node[pLeft].pType;
				EmitLine(0, "", "Const reuse in CodeBinOp");
				exit;
			end:if

			exit;
		end:do
	end:if

	switch rightOperand of
	case operandImm:
		word pLeft2 = TryDropCastBeforeCmp(P);
		when pLeft2 < nNODE:
			pLeft = pLeft2;

		pType=_Code(pLeft,0,0,0);

	case operandMemRef:
		when leftOperand == operandNotReady:
			pType=_Code(pLeft,0,0,0);

	case operandReg:
		null;

	case operandNotReady:
		char @reorderingReason = @CheckOperandReordering(pLeft, pRight);
		if @reorderingReason != NULL then
			EmitLine(0, "", "Reordering in CodeBinOp");
			EmitLine(0, "", @reorderingReason);
			if fEAX!=RegA then
				EmitLine(0, "push    EAX", "saved in CodeBinOp");
				fEAX=RegA;
			end

			_Code(pRight,0,0,0);
			fEAX =RegB;
			pType=_Code(pLeft,0,0,0);
			fSwap=1;
			when fEAX != RegB:
				StopInternalCodegen(__FILE__, __LINE__);

			fEAX = RegA;
			rightReg = RegB;
			rightOperand = operandReg;
		else
			if fEAX!=RegA then
				when CodeRequiresSingleRegister(pRight):
					EmitLine(0, "", "XXX1");
				EmitLine(0, "push    EAX", "saved in CodeBinOp");
				fEAX=RegA;
			end

			pType=_Code(pLeft,0,0,0);
			fEAX =RegB;
			_Code(pRight,0,0,0);
			if fEAX==RegA then
				EmitLine(0, "pop     EBX", "restored in CodeBinOp");
				fSwap=1;
			end

			fEAX = RegA;
			rightReg = RegB;
			rightOperand = operandReg;
		end:if

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	/* Check the cases for the operands arrived in swapped order: */
	if fSwap==1 then
		do
			/* We can handle it by changing the operation ID */
			word swappedID = CheckOperationSwappable(ID);
			if swappedID != 0 then
				ID = swappedID;
				exit;
			end:if

			/* We can handle it by swapping operands back. */
			switch ID of
			case iSUB, iDIV, iMOD:
				Emit(@CodeCmdRegReg(@Buff, "xchg", fEAX, 4, rightReg, 4));
				exit;
			end:switch

			/* If the operation is commutative, we don't care about the order. */
			when IsOperationCommutative(ID):
				exit;

			/* In other cases, swapped operands shouldn't happen. */
			StopInternalCodegen(__FILE__, __LINE__);
		end:do
	end:if


	word Size=4;
	if pType<nDICT then
		Size=SizeOfType(pType);
	end

	/* Check if we can replace add/sub with inc/dec */
	if rightOperand == operandImm & (ID == iADD | ID == iSUB) then

		word Value = Node[pRight].Value;
		when ID == iSUB:
			Value = -Value;

		select
		case Value == 1 & PreferIncDec(fEAX, Size) > 0:
			Emit(@CodeCmdReg(@Buff, "inc", fEAX, Size));
			return pType;
		case Value == -1 & PreferIncDec(fEAX, Size) > 0:
			Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			return pType;
		case Value == 2 & PreferIncDec(fEAX, Size) > 1:
			Emit(@CodeCmdReg(@Buff, "inc", fEAX, Size));
			Emit(@Buff);
			return pType;
		case Value == -2 & PreferIncDec(fEAX, Size) > 1:
			Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			Emit(@Buff);
			return pType;
		end:select
	end:if

	select
	case iLT<=ID & ID<=iGT:

		select
		case rightOperand == operandImm:
			word Value = Node[pRight].Value;
			select
			case Value == 0 & (ID == iEQ | ID == iNE):
				Emit(@CodeCmdRegReg(@Buff, "test", fEAX, Size, fEAX, Size));
			case Value == 1 & (ID == iEQ | ID == iNE) & PreferIncDec(fEAX, Size) != 0:
				Emit(@CodeCmdReg(@Buff, "dec", fEAX, Size));
			case Value == word(-1) & (ID == iEQ | ID == iNE) & PreferIncDec(fEAX, Size) != 0:
				Emit(@CodeCmdReg(@Buff, "inc", fEAX, Size));
			default:
				Emit(@CodeCmdRegConst(@Buff, "cmp", fEAX, Size, Node[pRight].Value));
			end:select
		case rightOperand == operandMemRef:
			Emit(@CodeCmdRegFmt(@Buff, "cmp", fEAX, Size, @BuffRightOperand));
		case rightOperand == operandReg:
			Emit(@CodeCmdRegReg(@Buff, "cmp", fEAX, Size, rightReg, Size));
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end

		if T==0 then
			switch ID of
			case iLT: ID=iGE;
			case iLE: ID=iGT;
			case iEQ: ID=iNE;
			case iNE: ID=iEQ;
			case iGE: ID=iLT;
			case iGT: ID=iLE;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
            end:switch

            T=F;
            F=0;
		end:if

		if T==0 | F!=0 then
			StopInternalCodegen(__FILE__, __LINE__);
		end

		char@ BranchCondition = "";
		select
		case pType==st_int:
			switch ID of
			case iLT: @BranchCondition = "l ";
			case iLE: @BranchCondition = "le";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ge";
			case iGT: @BranchCondition = "g ";
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch

		default:
			switch ID of
			case iLT: @BranchCondition = "b ";
			case iLE: @BranchCondition = "be";
			case iEQ: @BranchCondition = "e ";
			case iNE: @BranchCondition = "ne";
			case iGE: @BranchCondition = "ae";
			case iGT: @BranchCondition = "a ";
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch
		end:select
		EmitBranchToLabel(@BranchCondition, T);

		return nDICT;

	case ID==iBIT_OR:
		strcpy(@Buff,"or      ");

	case ID==iBIT_XOR:
		strcpy(@Buff,"xor     ");

	case ID==iBIT_AND:
		strcpy(@Buff,"and     ");

	case ID==iADD:
		strcpy(@Buff,"add     ");

	case ID==iSUB:
		strcpy(@Buff,"sub     ");

	case ID==iMUL:
		select
		case T_IsSigned(pType):
			strcpy(@Buff,"imul    ");
		case T_IsUnsigned(pType):
			strcpy(@Buff,"mul     ");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		select
		case rightOperand == operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		Emit(@Buff);
		return pType;

	case ID==iDIV | ID==iMOD:
		select
		case pType==st_byte:
			Emit("xor     AH,   AH");
			strcpy(@Buff,"div     ");
		case pType==st_word:
			Emit("xor     EDX,  EDX");
			strcpy(@Buff,"div     ");
		case pType==st_int:
			Emit("cdq");
			strcpy(@Buff,"idiv    ");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		select
		case rightOperand == operandImm:
			StopInternalCodegen(__FILE__, __LINE__);
		case rightOperand == operandMemRef:
			strcat(@Buff,@BuffRightOperand);
		case rightOperand == operandReg:
			CodeReg(@Buff, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select

		Emit(@Buff);

		if ID==iMOD then
			select
			case pType==st_byte:
				Emit("xchg    AL,   AH");
			case pType==st_word:
				Emit("xchg    EAX,  EDX");
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:select
		end:if

		return pType;

	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	select
	case Size==1 | Size==4:
		select
		case rightOperand == operandImm:
			/*
				XXX: The commented out code is mostly useless in the current implementation
				I can't find any expression when that condition actually triggers.
				May be useful when a full-featured register allocation strategy will be implemented.
			*/
			/*if PHO_EncodeRegContainingConst(@BuffRightOperand, Node[pRight].Value, Size) != 0 then
				CodeRegFmt(@Buff, fEAX, Size, @BuffRightOperand);
			else*/
				CodeRegConst(@Buff, fEAX, Size, Node[pRight].Value);
			/*end:if*/
		case rightOperand == operandMemRef:
			CodeRegFmt(@Buff, fEAX, Size, @BuffRightOperand);
		case rightOperand == operandReg:
			CodeRegReg(@Buff, fEAX, Size, rightReg, Size);
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
		Emit(@Buff);
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	return pType;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff[nBUFF];

	Buff[0] = #0;

	EmitWithSourceNote(NULL, P);

	when M != 0: /* M может быть установлено только когда F или T установлены */
		when T == 0 & F == 0:
			StopInternalCodegen(__FILE__, __LINE__);

	when T != 0 & F != 0: /* T и F не могут быть установлены в не 0 одновременно. */
		StopInternalCodegen(__FILE__, __LINE__);

	if T != 0 | F != 0 then
		when !NodeTypeIs(P, st_bool): /* T и F имеют смысл только для булевых вычислений. */
			StopInternalCodegen(__FILE__, __LINE__);

		switch Node[P].ID of
		case iLITERAL:
			select
			case Node[P].Value == 0 & F != 0:
				EmitJumpToLabel(F);
			case Node[P].Value != 0 & T != 0:
				EmitJumpToLabel(T);
			end:select
			return st_bool;

		case iLT, iLE, iEQ, iNE, iGE, iGT:
			return CodeBinOp(@Buff, P, F, T, M);

		case iNOT:
			return Code(Node[P].pLeft, T, F, M);
		case iOR:
			Code_OR(P, F, T, M, @Buff);
			return st_bool;
		case iXOR:
			Code_XOR(P, F, T, M, @Buff);
			return st_bool;
		case iEQV:
			Code_EQV(P, F, T, M, @Buff);
			return st_bool;
		case iAND:
			Code_AND(P, F, T, M, @Buff);
			return st_bool;

		case iDATA, iPARM, iLOCAL:
			Code(P, 0, 0, 0);
			Emit(@CodeCmdRegReg(@Buff, "test", fEAX, 4, fEAX, 4));
			select
			case F != 0:
				EmitBranchToLabel("z", F);
			case T != 0:
				EmitBranchToLabel("nz", T);
			end:select

		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	else
		switch Node[P].ID of
		case iNULL:
			Emit_Load_Constant(fEAX, 4, 0);
			return Node[P].pType;

		case iLITERAL:
			Emit_Load_Constant(fEAX, T_SizeOf(Node[P].pType), Node[P].Value);
			return Node[P].pType;

		case iFUNC:
			CodeLoadLabel(@Buff, fEAX, Node[P].Value);
			Emit(@Buff);
			return nDICT;

		case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
			return Code1(P);

		case iCAST:
			word pTypeFrom = Code(Node[P].pLeft, 0, 0, 0);
			word pTypeTo = Node[P].pType;
			word Complexity = 0;
			return Code_CAST(@Buff, P, pTypeTo, pTypeFrom, fEAX, @Complexity);

		case iBIT_NOT:
			word pType = Code(Node[P].pLeft, 0, 0, 0);
			word  Size = SizeOfType(pType);
			Emit(@CodeCmdReg(@Buff, "not", fEAX, Size));

			return pType;

		case iNEG:
			if NodeIsLiteralWord(Node[P].pLeft) then
				Emit_Load_Constant(fEAX, 4, -Node[Node[P].pLeft].Value);
				return st_int;
			end

			Code(Node[P].pLeft,0,0,0);

			Emit(@CodeCmdReg(@Buff, "neg", fEAX, 4));

			return st_int;

		case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:
			return CodeBinOp(@Buff, P, 0, 0, 0);

		case iDEF_LOCAL:
		  if nLocal>=nLOCAL then
			StopMemory();
		  end

		  word pType = Node[P].pType;
		  word Size  = SizeOfType(pType);

		  AllocatedFrameSize =
			  AllocatedFrameSize + DefaultInStackAlign(Size);

		  Local[nLocal].pType=pType;
		  Local[nLocal].Value=AllocatedFrameSize;
		  inc   nLocal;

		  Code(Node[P].pLeft,0,0,0);

		case iASSIGN:
			P    = Node[P].pLeft;
			fEAX = RegA;
			if Node[P].pRight < nNODE then
				Code(Node[P].pRight, 0, 0, 0);
				fEAX = RegB;
			end

			return Code(Node[P].pLeft, 0, 0, 0);

		case iINLINE:
			Emit(@strcpy2(@Buff,"db      0x",@str2(Node[P].Value,16)));

		case iPUSH:
			Code_PUSH(P, @Buff);
		case iRETURN:
			return Code_RETURN(P, @Buff);
		case iSELECT:
			return Code_SELECT(P, @Buff);
		case iSWITCH:
			return Code_SWITCH(P, @Buff);
		case iWHILE:
			Code_WHILE(P, @Buff);
		case iREPEAT:
			Code_REPEAT(P, @Buff);
		case iCONTINUE:
			return Code_CONTINUE(P, @Buff);
		case iEXIT:
			return Code_EXIT(P, @Buff);
		case iEMPTY:
			null;
		default:
			StopAtNodeInternalCodegen(__FILE__, __LINE__, P);
		end:switch

	end:if

	return nDICT;
end

/*****************************************************************************/

void EmitFunction(char @Buff; word I)
	EmitStringNL("");
	strcpy(@Buff,"## ");
	if Dict[I].Sub != sMAIN then
		strcat(@Buff, @DictGetName(I));
	else
		strcat(@Buff, "<begin>");
	end:if
	strcat(@Buff," ##");
	EmitLine(Dict[I].Label, "", @Buff);

	word S1 = 0;

	word pARGS = FindInNamespace("args", I);
	when pARGS >= nDICT:
		StopInternalCodegen(__FILE__, __LINE__);
	word pARG = Dict[pARGS].pFirst;
	while pARG < nDICT do
		Dict[pARG].Label = S1 + 8;
		S1 = S1 + DefaultInStackAlign(SizeOfType(Dict[pARG].pType));
		pARG = Dict[pARG].pNext;
	end:while

	PHO_InvalidateRegs();

	if EmitEnterInstruction != 0 & Dict[I].StackSize > 0 then
		Emit(@strcpy3(@Buff,"enter   ",@str(Dict[I].StackSize), ", 0"));
	else
		Emit("push    EBP");
		Emit("mov     EBP,  ESP");

		if Dict[I].StackSize > 0 then
			Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(Dict[I].StackSize)));
		end:if
	end:if

	if Dict[I].Sub == sMAIN then
		word  J = 0;
		while J < nDict do
			if Dict[J].Class == cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
				if Node[Dict[J].pNode].ID != iASSIGN then
					StopInternalCodegen(__FILE__, __LINE__);
				end:if
				if StaticDataIsZeroed == 0
				 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) == false then
					Code(Dict[J].pNode, 0, 0, 0);
				end:if
			end:if

			inc J;
		end:while
	end:if

	pFunc = I;
	ParmFrameSize = S1;
	AllocatedFrameSize = 0;

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word  P = Dict[I].pNode;
	word  pType = st_void;
	while P < nNODE do
		pType = _Code(P, 0, 0, 0);
		when pType == st_noreturn:
			exit;
		P  = Node[P].pRight;
	end

	if pType != st_noreturn then
		word pRet = Peek();
		Node[pRet].ID = iRETURN;
		_Code(pRet, 0, 0, 0);
	end

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word EmitFunctions(char @Buff)
	word Start = 0;

	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class == cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				when Dict[I].Sub == sMAIN:
					Start = Dict[I].Label;
				EmitFunction(@Buff, I);
		end:select
		inc I;
	end:while

	when Start == 0:
		StopInternalCodegen(__FILE__, __LINE__);

	return Start;
end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat == tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat == tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternalCodegen(__FILE__, __LINE__);
	end

	EmitROData();

	word Start = EmitFunctions(@Buff);

	return Start;

end

/*****************************************************************************/

