
namespace Backend of

/*****************************************************************************/

void CloseOutput();
void EmitComment(char @Comment);
void EmitPhoSkip(char @Inst);
char @EncodeLoadConstant(char @Buff; word Reg; word RegMode; word Value);
void NodeMarkUsed(word P);

define Flag_Zero 1
define Flag_Sign 2
word MeaningfulFlags = 0;

word pExitProcess = nDICT;

word EntryLabel = 0;

namespace Mach of
	word AllowedRegSize = 4;
	word NativeRegSize = 4;
	word PointerSize = 4;
	word Mode = 4;
end:namespace

include "backend_msg.qdi";
include "backend_pho.qdi";
include "backend_pho_node_links.qdi";
include "backend_lib.qdi";
include "backend_labels.qdi";
include "backend_emit.qdi";
include "asm_driver.qdi";
include "asm_driver_fasm.qdi";
include "asm_driver_nasm.qdi";
include "backend_asmcode.qdi";
include "backend_asmcode_mul.qdi";
include "backend_data_emitter.qdi";
include "backend_code_emitter.qdi";
include "backend_misc.qdi";

/*****************************************************************************/

void InitAsmDriver()
	switch TargetAssembler of
	case ASM_MODE.aFASM:
		EnableFasmDriver();
	case ASM_MODE.aNASM:
		EnableNasmDriver();
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:switch
end

/*****************************************************************************/

word Compile(
	word pStartFunc;
	char@ OutputFile;
	char@ OutputTreeFile;
	char@ OutputIncludeListFile
) of
	UpdateEmitChar();

	/* Промежуточные операции *********************/

	if pStartFunc != nDICT then
		DictMarkUsed(pStartFunc);
		Dict[pStartFunc].Sub = SUBCLASS.sSTART_FUNC;
	else
		Error(@L10n.eNOSTART);
	end:if

	/* Отметка используемых объектов. */
	select
		case TargetFileFormat == TARGET_FORMAT.tPE:
			pExitProcess = ResolveInNamespace("ExitProcess", pGlobalNamespace);
			when pExitProcess != nDICT:
				Dict[pExitProcess].Used = true;
	end:select

	/* Назначаем метки и смещения. */
	word D = AssignLabels_Data();
	AssignLabels_Func();
	AssignLabels_FuncExternal();
	AssignStringOffsets();

	/* Вывод информации по анализу кода ***********/

	when WarnUnusedGlobals:
		DoWarnUnusedGlobals();

	word OutputTreeFile_Done = 0;

	if OutputTreeFile_Done == 0
	 & @OutputTreeFile != NULL
	 & strlen(@OutputTreeFile) != 0
	 & str_ne(@OutputFile, @OutputTreeFile) then
		OutputTreeFile_Done = 1;
		OpenOutput(@OutputTreeFile);
		EmitContentForTreeFile();
		CloseOutput();
	end:if

	if @OutputIncludeListFile != NULL & strlen(@OutputIncludeListFile) != 0 then
		OpenOutput(@OutputIncludeListFile);
		EmitIncludeList();
		CloseOutput();
	end:if

	/* Остановка при отложенных ошибках *****************************/
	when HasErrors:
		return 1;

	/* Генерация кода *****************************/

	PrepareMulTricks();

	OpenOutput(@OutputFile);

	if OutputTreeFile_Done == 0
	 & @OutputTreeFile != NULL
	 & strlen(@OutputTreeFile) != 0
	 & str_eq(@OutputFile, @OutputTreeFile) then
		OutputTreeFile_Done = 1;
		EmitContentForTreeFile();
	end:if

	when EmitCompilerFlags:
		CompilerOptions.PrintOptionValues(@EmitString, "; ");

	char Buff[nBUFF];

	InitAsmDriver();
	EmitFileHeader(@Buff);
	EmitSection_ROData(@Buff);
	EmitSection_Code(@Buff);
	EmitSection_Data(@Buff, D);
	EmitSection_Bss(@Buff, D);

	select
	case TargetFileFormat == TARGET_FORMAT.tPE:
		EmitPEImport(@Buff);
	end:select

	EmitNL();
	EmitFileFooter(@Buff);

	CloseOutput();

	return 0;
end

/*****************************************************************************/

end:namespace

alias Compile = Backend.Compile;
