
/*****************************************************************************/

LABEL @CodeExtractJump(word P)
	switch Node[P].ID of
	case iCONTINUE:
		return @LabelResolve(Node[P].Value, lCONTINUE);
	case iEXIT:
		return @LabelResolve(Node[P].Value, lEXIT);
	default:
		return NULL;
	end:switch
end

LABEL @CodeExtractExitLabel(word P)
	LABEL @L_Exit = NULL;
	when Node[P].pRight != nNODE:
		@L_Exit = @CodeExtractJump(Node[P].pRight);
	when @L_Exit == NULL:
		@L_Exit = @LabelResolve(P, lEXIT);
	return @L_Exit;
end

/*****************************************************************************/

word Code_OR(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	LABEL @L = @LabelResolve(P, lBRANCH);
	if @T == NULL then
		Code(Node[P].pLeft , NULL, @M, @L);
		EmitLabelIfUsed(@L);
		Code(Node[P].pRight, @F, NULL, @M);
	else
		Code(Node[P].pLeft , NULL, @T, @L);
		EmitLabelIfUsed(@L);
		Code(Node[P].pRight, NULL, @T, @M);
	end
	return Node[P].pType;
end

/*****************************************************************************/

word Code_XOR(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	Stop(@eXORNOTIMPL);
end

/*****************************************************************************/

word Code_EQV(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	Stop(@eEQVNOTIMPL);
end

/*****************************************************************************/

word Code_AND(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	LABEL @L = @LabelResolve(P, lBRANCH);
	if @T == NULL then
		Code(Node[P].pLeft , @F, NULL, @L);
		EmitLabelIfUsed(@L);
		Code(Node[P].pRight, @F, NULL, @M);
	else
		Code(Node[P].pLeft , @M, NULL, @L);
		EmitLabelIfUsed(@L);
		Code(Node[P].pRight, NULL, @T, @M);
	end
	return Node[P].pType;
end

/*****************************************************************************/

word Code_PUSH(word P; char @Buff)

	if Node[P].pRight<nNODE then
		Code(Node[P].pRight,NULL,NULL,NULL);
	end

	word P1 = Node[P].pLeft;


	/* Оптимизация прямой загрузки значения из переменной. */
	char BuffOperand[nBUFF];
	word pOperandType;
	if CodeAsMemoryOperand(@BuffOperand, P1, @pOperandType) & (T_SizeOf(pOperandType) ==  4) then
		Emit(@strcpy2(@Buff, "push    ", @BuffOperand));
		return nDICT;
	end

	/* Оптимизация прямой загрузки указателя на строку. */
	if Node[P1].ID==iSTRING then

		if Node[P1].pLeft != nNODE
		 & Node[Node[P1].pLeft].ID==iLPTR then

			word pType;
			word  Ofs;
			word  RO;
			word ID=ExtractDataInfo(P1, @pType, @Ofs, @RO);

			char @s = "dword @@ROLITERALS+";
			when RO == 0:
				@s = "dword @@RWLITERALS+";

			Emit(@strcpy3(@Buff, "push    ",@s,@str(Ofs)));

			return nDICT;
		end:if
	end:if

	/* Оптимизация прямой загрузки числа. */
	if NodeCanBeEncodedAsImm(P1) & (T_SizeOf(Node[P1].pType) == 4) then
		word Value = Node[P1].Value;

		/* Если какой-либо регистр уже содержит нужную константу... */
		word Reg = PHO_FindRegWithConst(Value);
		if Reg != PHO_REG_INVALID then
			Emit(@strcpy2(@Buff, "push    ", @PHO_EncodeReg(Reg, 0xFFFF_FFFF)));
			return nDICT;
		end:if

		/* Прямая загрузка числа. Кроме значения 0. Для 0 используем общий алгоритм,
		   который позволяет оптимизировать до xor.
		*/
		if Value != 0 then
			Emit(@strcpy2(@Buff, "push    dword ", @str(Value)));
			return nDICT;
		end:if
	end:if

	/* Все остальные варианты... */

	fEAX=RegA;
	word pType = Code(Node[P].pLeft,NULL,NULL,NULL);

	word Size = target_size_of_pointer;
	if pType<nDICT then
		Size=SizeOfType(pType);
	end

	select
	case Size==1:
		Emit("push    EAX");
	case Size==4:
		Emit("push    EAX");
	default:
		Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(DefaultInStackAlign(Size))));
		Emit("mov     ESI,  EAX");
		Emit("mov     EDI,  ESP");
		Emit("cld");
		Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
		Emit("rep     movsb");
	end:select

	return nDICT;
end

/*****************************************************************************/

word Code_RETURN(word P; char @Buff)

	if Node[P].pLeft<nNODE then
		fEAX=RegA;
		word pType=Code(Node[P].pLeft,NULL,NULL,NULL);
		word  Size=4;
		if pType<nDICT then
			Size=SizeOfType(pType);
		end:if

		if Size!=1 & Size!=4 then
			StopInternalCodegen(__FILE__, __LINE__);
		end:if
	end:if

	if Dict[pFunc].Sub == sMAIN then
		select
		case TargetFileFormat == tPE:
			Emit("xor     EAX,  EAX");
			Emit("push    EAX");
			Emit(@strcpy3(@Buff,"call   [@",@str(Dict[Find("ExitProcess")].Label),"]"));
		case TargetFileFormat == tELF:
			Emit("mov     EAX,  1");
			Emit("xor     EBX,  EBX");
			Emit("int     80H");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
	else
		if EmitLeaveInstruction != 0 then
			Emit("leave");
		else
			Emit("mov     ESP,  EBP");
			Emit("pop     EBP");
		end:if

		if ParmFrameSize > 0 then
			Emit(@strcpy2(@Buff,"ret     ",@str(ParmFrameSize)));
		else
			Emit("ret");
		end:if
	end:if

	return st_noreturn;
end

/*****************************************************************************/

word Code_SELECT(word P; char @Buff)

	/*
	                 iSELECT
	                /       \
	              iCASE      [next statement]
	             /     \
	            iCOND   [next case]
	           /     \
	[condition]     iBODY
	               /    \
	         [body]     NULL
	*/

	LABEL @L_Exit = @CodeExtractExitLabel(P);

	word pTypeFinal = st_noreturn;
	bool DefaultBranchPresent = false;
	word CASE = Node[P].pLeft;
	while CASE < nNODE do
		when Node[CASE].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word COND = Node[CASE].pLeft;
		word BODY = Node[COND].pRight;

		when Node[BODY].ID != iBODY
		|    Node[COND].ID != iCOND:
			StopInternalCodegen(__FILE__, __LINE__);

		LABEL @L_CASEBODYEND = NULL;
		if Node[CASE].pRight == nNODE then
			@L_CASEBODYEND = @L_Exit;
		else
			@L_CASEBODYEND = @LabelResolve(CASE, lCASEBODYEND);
		end:if

		LABEL @L_Jump = NULL;

		if Node[COND].pLeft < nNODE then
			@L_Jump = @CodeExtractJump(Node[BODY].pLeft);
			if @L_Jump == NULL then
				Code(Node[COND].pLeft,@L_CASEBODYEND,NULL,@LabelResolve(CASE, lCASEBODY));
			else
				Code(Node[COND].pLeft,NULL,@L_Jump,@L_CASEBODYEND);
			end:if
			EmitLabelIfUsed(@LabelResolve(CASE, lCASEBODY));
		else
			DefaultBranchPresent = true;
		end

		word pTypeBody = st_noreturn;
		when @L_Jump == NULL:
			pTypeBody = Code_Block(Node[BODY].pLeft);

		if pTypeBody != st_noreturn then
			pTypeFinal = pTypeBody;
			if Node[CASE].pRight < nNODE then
				EmitJumpToLabel(@L_Exit);
			end
		end

		EmitLabelIfUsed(@LabelResolve(CASE, lCASEBODYEND));

		CASE = Node[CASE].pRight;
	end:while

	when !DefaultBranchPresent:
		pTypeFinal = st_void;

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	return pTypeFinal;
end

/*****************************************************************************/

word Code_SWITCH(word P; char @Buff)

	/*
	                 iSWITCH
	                /       \
	              iCOND      [next statement]
	             /     \
	 [expression]     iCASE
	                 /     \
	            iVALUE      [next case]
	           /      \
	    [value]       iVALUE
                    /      \
	         [value]       iBODY
	                      /     \
	                [body]       NULL


                      iCASE
	                 /     \
	          iDEFAULT      [next case]
	         /        \
	     NULL        iBODY
	                /     \
	          [body]       NULL


	*/

	word pTypeFinal = st_noreturn;
	bool DefaultBranchPresent = false;

	word COND = Node[P].pLeft;
	when Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	fEAX = RegA;
	word pType = Code(Node[COND].pLeft,NULL,NULL,NULL);
	if pType == st_byte then
		Emit("and     EAX,  0FFH");
	end:if

	LABEL @L_Default = @LabelResolve(P, lEXIT);
	word offset = 0;

	word  CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		when Node[CASE_I].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word  VALUE_I = Node[CASE_I].pLeft;
		while VALUE_I < nNode do
			switch Node[VALUE_I].ID of
			case iVALUE:
				word value = Node[Node[VALUE_I].pLeft].Value - offset;

				word Reg = RegA;
				word Size = SizeOfType(pType);
				switch Size of
				case 1:
					value = value & 0xFF;
				case 2:
					value = value & 0xFFFF;
				case 4:
					null;
				default:
					StopInternalCodegen(__FILE__, __LINE__);
				end:switch

				Buff[0] = #0;
				select
				case value == 1 & PreferIncDec(Reg, Size) > 0:
					Emit(@CodeCmdReg(@Buff, "dec", Reg, Size));
				case value == 2 & PreferIncDec(Reg, Size) > 1:
					Emit(@CodeCmdReg(@Buff, "dec", Reg, Size));
					Emit(@Buff);
				case value == -1 & PreferIncDec(Reg, Size) > 0:
					Emit(@CodeCmdReg(@Buff, "inc", Reg, Size));
				case value == -2 & PreferIncDec(Reg, Size) > 1:
					Emit(@CodeCmdReg(@Buff, "inc", Reg, Size));
					Emit(@Buff);
				default:
					Emit(@CodeCmdRegFmt(@Buff, "sub", Reg, Size, @str(value)));
				end:select

				offset = offset + value;

				EmitBranchToLabel("e", @LabelResolve(CASE_I, lCASEBODY));
			case iDEFAULT:
				@L_Default = @LabelResolve(CASE_I, lCASEBODY);
				DefaultBranchPresent = true;
			case iBODY:
				null;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch
			VALUE_I = Node[VALUE_I].pRight;
		end:while

		CASE_I = Node[CASE_I].pRight;
	end:while

	EmitJumpToLabel(@L_Default);

	CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		when Node[CASE_I].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word  VALUE_I = Node[CASE_I].pLeft;
		while VALUE_I < nNode do
			switch Node[VALUE_I].ID of
			case iVALUE, iDEFAULT:
				null;
			case iBODY:
				EmitLabel(@LabelResolve(CASE_I, lCASEBODY));
				word pTypeBody = Code_Block(Node[VALUE_I].pLeft);
				if pTypeBody != st_noreturn then
					pTypeFinal = st_void;
					EmitJumpToLabel(@LabelResolve(P, lEXIT));
				end:if
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch
			VALUE_I = Node[VALUE_I].pRight;
		end:while

		CASE_I = Node[CASE_I].pRight;
	end:while

	when !DefaultBranchPresent:
		pTypeFinal = st_void;

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	return pTypeFinal;
end

/*****************************************************************************/

word Code_WHILE(word P; char @Buff)

	/*
	                 iWHILE
	                /     \
	              iBODY    [next statement]
	             /    \
	  [loop body]    iCOND
	                /    \
	[loop condition]      NULL
	*/

	LABEL @L_Exit = @CodeExtractExitLabel(P);

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	EmitLabel(@LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		Code(Node[COND].pLeft, @L_Exit, NULL, @LabelResolve(P, lLOOPBODY));
		EmitLabelIfUsed(@LabelResolve(P, lLOOPBODY));
	end

	word pTypeBody = Code_List(Node[BODY].pLeft);
	when pTypeBody != st_noreturn:
		EmitJumpToLabel(@LabelResolve(P, lCONTINUE));

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);

	return Node[P].pType;
end

/*****************************************************************************/

word Code_REPEAT(word P; char @Buff)

	/*
	                 iREPEAT
	                /      \
	              iBODY     [next statement]
	             /    \
	  [loop body]    iCOND
	                /    \
	[loop condition]      NULL
	*/

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	/* Check the case when loop can be replaced with simple code block */
	if NodeIsTrue(Node[COND].pLeft) &
	   !CTE_LoopHasExits(P, Node[BODY].pLeft) &
	   !CTE_LoopHasContinues(P, Node[BODY].pLeft)
	then
		Code_List(Node[BODY].pLeft);
		return st_void;
	end

	EmitLabel(@LabelResolve(P, lLOOPBODY));

	Code_List(Node[BODY].pLeft);

	EmitLabelIfUsed(@LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		Code(Node[COND].pLeft, @LabelResolve(P, lLOOPBODY), NULL, @LabelResolve(P, lEXIT));
	end

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);

	return Node[P].pType;
end

/*****************************************************************************/

word Code_CONTINUE(word P; char @Buff)
	EmitJumpToLabel(@CodeExtractJump(P));
	return st_noreturn;
end

/*****************************************************************************/

word Code_EXIT(word P; char @Buff)
	EmitJumpToLabel(@CodeExtractJump(P));
	return st_noreturn;
end

/*****************************************************************************/
