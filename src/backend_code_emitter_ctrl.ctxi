
/*****************************************************************************/

LABEL @CodeExtractExitLabel(word P);

LABEL @CodeExtractJump(word P)
	switch Node[P].ID of
	case iVIRTUAL_JUMP:
		return @LabelResolve(Node[P].Value, Node[P].pType);
	case iCONTINUE:
		return @LabelResolve(Node[P].Value, lCONTINUE);
	case iEXIT:
		return @CodeExtractExitLabel(Node[P].Value);
	default:
		return NULL;
	end:switch
end

LABEL @CodeExtractExitLabel(word P)
	LABEL @L_Exit = NULL;
	when Node[P].pRight != nNODE:
		@L_Exit = @CodeExtractJump(Node[P].pRight);
	when @L_Exit == NULL:
		@L_Exit = @LabelResolve(P, lEXIT);
	return @L_Exit;
end

void CodeList_InsertVirtualJump(word P; word pTarget; word LabelId)
	word pJump = Peek();
	Node[pJump].ID = iVIRTUAL_JUMP;
	Node[pJump].Value = pTarget;
	Node[pJump].pType = LabelId;
	Node[pJump].SourceLocation.Line = -1;

	while Node[P].pRight != nNODE do
		P = Node[P].pRight;
	end
	Node[P].pRight = pJump;
end

/*****************************************************************************/

word Code_OR(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	LABEL @L = @LabelResolve(P, lBRANCH);
	if @T == NULL then
		CodeBooleanExpr(Node[P].pLeft , NULL, @M, @L);
		EmitLabelIfUsed(@L);
		CodeBooleanExpr(Node[P].pRight, @F, NULL, @M);
	else
		CodeBooleanExpr(Node[P].pLeft , NULL, @T, @L);
		EmitLabelIfUsed(@L);
		CodeBooleanExpr(Node[P].pRight, NULL, @T, @M);
	end
	return Node[P].pType;
end

/*****************************************************************************/

word Code_XOR(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	Stop(@eXORNOTIMPL);
end

/*****************************************************************************/

word Code_EQV(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	Stop(@eEQVNOTIMPL);
end

/*****************************************************************************/

word Code_AND(word P; LABEL @F; LABEL @T; LABEL @M; char @Buff)
	LABEL @L = @LabelResolve(P, lBRANCH);
	if @T == NULL then
		CodeBooleanExpr(Node[P].pLeft , @F, NULL, @L);
		EmitLabelIfUsed(@L);
		CodeBooleanExpr(Node[P].pRight, @F, NULL, @M);
	else
		CodeBooleanExpr(Node[P].pLeft , @M, NULL, @L);
		EmitLabelIfUsed(@L);
		CodeBooleanExpr(Node[P].pRight, NULL, @T, @M);
	end
	return Node[P].pType;
end

/*****************************************************************************/

word Code_PUSH(word P; char @Buff)

	if Node[P].pRight<nNODE then
		Code(Node[P].pRight);
	end

	word P1 = Node[P].pLeft;

	/* Оптимизация прямой загрузки значения из переменной. */
	char BuffOperand[nBUFF];
	word pOperandType;
	if CodeAsMemoryOperand(@BuffOperand, P1, @pOperandType) & (T_SizeOf(pOperandType) ==  4) then
		Emit(@strcpy2(@Buff, "push    ", @BuffOperand));
		return nDICT;
	end

	/* Оптимизация прямой загрузки указателя на строку. */
	if
		(Node[P1].ID == iLPTR) &
		(Node[P1].pLeft != nNODE) &
		(Node[Node[P1].pLeft].ID == iSTRING)
	then
		ValueRef Ref;
		ValueRef_ExtractDataInfo(@Ref, Node[P1].pLeft);
		char @s = "dword @@ROLITERALS+";
		when Ref.RO == 0:
			@s = "dword @@RWLITERALS+";
		Emit(@strcpy3(@Buff, "push    ",@s,@str(Ref.Offset)));
		return nDICT;
	end:if

	/* Оптимизация прямой загрузки числа. */
	if NodeCanBeEncodedAsImm(P1) & (T_SizeOf(Node[P1].pType) == 4) then
		word Value = Node[P1].Value;
		word Size = T_SizeOf(Node[P1].pType);

		if Size == 4 | Size == 2 | Size == 1 then
			/* Если какой-либо регистр уже содержит нужную константу... */
			/* FIXME: проверять только часть регистра при необходимости */
			word Reg = PHO_FindRegWithConst(Value);
			if Reg != PHO_REG_INVALID then
				Emit(@strcpy2(@Buff, "push    ", @PHO_EncodeReg(Reg, 0xFFFF_FFFF)));
				return nDICT;
			end:if
		end:if

		if Size == 4 then
			/* Прямая загрузка числа. Кроме значения 0. Для 0 используем общий алгоритм,
			   который позволяет оптимизировать до xor.
			*/
			if Value != 0 then
				Emit(@strcpy2(@Buff, "push    dword ", @str(Value)));
				return nDICT;
			end:if
		end:if
	end:if

	/* Все остальные варианты... */

	/* Вариант с выбором регистра компилирует успешно, но особого толку нет. */
	/*if !NodeCanBeEncodedAsImm(P1) & CodeRequiresSingleRegister(P1) then
		Reg_TARGET = ChooseEmptyReg();
	else*/
		Reg_TARGET = RegA;
	/*end:if*/
	word pType = Code(P1);

	word Size = target_size_of_pointer;
	if pType<nDICT then
		Size=SizeOfType(pType);
	end

	select
	case Size==1 | Size==2 | Size==4:
		Buff[0] = #0;
		Emit(@CodePushReg(@Buff, Reg_TARGET, 4));
	default:
		char @TX = @CodeReg(NULL, Reg_TARGET, 4);
		Emit(@strcpy2(@Buff,"sub     ESP,  ",@str(DefaultInStackAlign(Size))));
		Emit(@strcpy2(@Buff,"mov     ESI,  ",@TX));
		Emit("mov     EDI,  ESP");
		Emit("cld");
		Emit(@strcpy2(@Buff,"mov     ECX,  ",@str(Size)));
		Emit("rep     movsb");
	end:select

	return nDICT;
end

/*****************************************************************************/

word Code_RETURN(word P; char @Buff)

	if Node[P].pLeft<nNODE then
		Reg_TARGET = RegA;
		word pType=Code(Node[P].pLeft);
		word  Size=4;
		if pType<nDICT then
			Size=SizeOfType(pType);
		end:if

		if Size!=1 & Size!=4 then
			StopInternalCodegen(__FILE__, __LINE__);
		end:if
	end:if

	if Dict[pFunc].Sub == sMAIN then
		select
		case TargetFileFormat == tPE:
			Emit("xor     EAX,  EAX");
			Emit("push    EAX");
			Emit(@strcpy3(@Buff,"call   [@",@str(Dict[Find("ExitProcess")].Label),"]"));
		case TargetFileFormat == tELF:
			Emit("mov     EAX,  1");
			Emit("xor     EBX,  EBX");
			Emit("int     80H");
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:select
	else
		if EmitLeaveInstruction != 0 then
			Emit("leave");
		else
			Emit("mov     ESP,  EBP");
			Emit("pop     EBP");
		end:if

		if ParmFrameSize > 0 then
			Emit(@strcpy2(@Buff,"ret     ",@str(ParmFrameSize)));
		else
			Emit("ret");
		end:if
	end:if

	return st_noreturn;
end

/*****************************************************************************/

word Code_SELECT(word P; char @Buff)

	/*
	                 iSELECT
	                /       \
	              iCASE      [next statement]
	             /     \
	            iCOND   [next case]
	           /     \
	[condition]     iBODY
	               /    \
	         [body]     NULL
	*/

	LABEL @L_Exit = @CodeExtractExitLabel(P);

	word pTypeFinal = st_noreturn;
	word pTypeBody = st_void;
	bool DefaultBranchPresent = false;
	word CASE = Node[P].pLeft;
	word LAST_CASE = CASE;
	LABEL @L_Jump = NULL;
	while CASE < nNODE do
		when Node[CASE].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word COND = Node[CASE].pLeft;
		word BODY = Node[COND].pRight;

		when Node[BODY].ID != iBODY
		|    Node[COND].ID != iCOND:
			StopInternalCodegen(__FILE__, __LINE__);

		LABEL @L_CASEBODYEND = NULL;
		if Node[CASE].pRight == nNODE then
			@L_CASEBODYEND = @L_Exit;
		else
			@L_CASEBODYEND = @LabelResolve(CASE, lCASEBODYEND);
		end:if

		@L_Jump = NULL;

		if Node[COND].pLeft < nNODE then
			@L_Jump = @CodeExtractJump(Node[BODY].pLeft);
			if @L_Jump == NULL then
				CodeBooleanExpr(Node[COND].pLeft,@L_CASEBODYEND,NULL,@LabelResolve(CASE, lCASEBODY));
			else
				CodeBooleanExpr(Node[COND].pLeft,NULL,@L_Jump,@L_CASEBODYEND);
			end:if
			EmitLabelIfUsed(@LabelResolve(CASE, lCASEBODY));
		else
			DefaultBranchPresent = true;
		end

		if @L_Jump == NULL then
			pTypeBody = Code_Block(Node[BODY].pLeft);
		else
			pTypeBody = st_noreturn;
		end:if

		if pTypeBody != st_noreturn then
			pTypeFinal = pTypeBody;
			if Node[CASE].pRight < nNODE then
				EmitJumpToLabel(@L_Exit);
			end
		end

		EmitLabelIfUsed(@LabelResolve(CASE, lCASEBODYEND));

		LAST_CASE = CASE;
		CASE = Node[CASE].pRight;
	end:while

	when !DefaultBranchPresent:
		pTypeFinal = st_void;

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	if
		(pTypeBody == st_noreturn) &
		(@L_Jump == NULL) &
		!LabelIsUsed(@LabelResolve(P, lEXIT)) &
		!LabelIsUsed(@LabelResolve(LAST_CASE, lCASEBODYEND))
	then
		pTypeFinal = st_noreturn;
	end:if

	return pTypeFinal;
end

/*****************************************************************************/

word Code_SWITCH_CASE_GetBody(word CASE_I)
	word  VALUE_I = Node[CASE_I].pLeft;
	while VALUE_I < nNode do
		switch Node[VALUE_I].ID of
		case iVALUE, iDEFAULT:
			null;
		case iBODY:
			return VALUE_I;
		default:
			StopInternalCodegen(__FILE__, __LINE__);
		end:switch
		VALUE_I = Node[VALUE_I].pRight;
	end:while
	StopInternalCodegen(__FILE__, __LINE__);
end

word Code_SWITCH(word P; char @Buff)

	/*
	                 iSWITCH
	                /       \
	              iCOND      [next statement]
	             /     \
	 [expression]     iCASE
	                 /     \
	            iVALUE      [next case]
	           /      \
	    [value]       iVALUE
                    /      \
	         [value]       iBODY
	                      /     \
	                [body]       NULL


                      iCASE
	                 /     \
	          iDEFAULT      [next case]
	         /        \
	     NULL        iBODY
	                /     \
	          [body]       NULL


	*/

	LABEL @L_Exit = @CodeExtractExitLabel(P);

	word pTypeFinal = st_noreturn;
	bool DefaultBranchPresent = false;

	word COND = Node[P].pLeft;
	when Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	Reg_TARGET = RegA;
	word pType = Code(Node[COND].pLeft);
	if pType == st_byte then
		Emit("and     EAX,  0FFH");
	end:if

	LABEL @L_Default = @L_Exit;
	word offset = 0;

	word  CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		when Node[CASE_I].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word BODY_I = Code_SWITCH_CASE_GetBody(CASE_I);
		LABEL @L_Jump = @CodeExtractJump(Node[BODY_I].pLeft);
		when @L_Jump == NULL:
			@L_Jump = @LabelResolve(CASE_I, lCASEBODY);

		word  VALUE_I = Node[CASE_I].pLeft;
		while VALUE_I < nNode do
			switch Node[VALUE_I].ID of
			case iVALUE:
				word value = Node[Node[VALUE_I].pLeft].Value - offset;

				word Reg = RegA;
				word Size = SizeOfType(pType);
				switch Size of
				case 1:
					value = value & 0xFF;
				case 2:
					value = value & 0xFFFF;
				case 4:
					null;
				default:
					StopInternalCodegen(__FILE__, __LINE__);
				end:switch

				Buff[0] = #0;
				select
				case value == 1 & PreferIncDec(Reg, Size) > 0:
					Emit(@CodeCmdReg(@Buff, "dec", Reg, Size));
				case value == 2 & PreferIncDec(Reg, Size) > 1:
					Emit(@CodeCmdReg(@Buff, "dec", Reg, Size));
					Emit(@Buff);
				case value == word(-1) & PreferIncDec(Reg, Size) > 0:
					Emit(@CodeCmdReg(@Buff, "inc", Reg, Size));
				case value == word(-2) & PreferIncDec(Reg, Size) > 1:
					Emit(@CodeCmdReg(@Buff, "inc", Reg, Size));
					Emit(@Buff);
				default:
					Emit(@CodeCmdRegFmt(@Buff, "sub", Reg, Size, @str(value)));
				end:select

				offset = offset + value;

				EmitBranchToLabel("e", @L_Jump);
			case iDEFAULT:
				@L_Default = @LabelResolve(CASE_I, lCASEBODY);
				DefaultBranchPresent = true;
			case iBODY:
				null;
			default:
				StopInternalCodegen(__FILE__, __LINE__);
			end:switch
			VALUE_I = Node[VALUE_I].pRight;
		end:while

		CASE_I = Node[CASE_I].pRight;
	end:while

	EmitJumpToLabel(@L_Default);

	word pTypeBody = st_void;

	CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		word NEXT_CASE_I = Node[CASE_I].pRight;

		when Node[CASE_I].ID != iCASE:
			StopInternalCodegen(__FILE__, __LINE__);

		word BODY_I = Code_SWITCH_CASE_GetBody(CASE_I);
		LABEL @L_Jump = @CodeExtractJump(Node[BODY_I].pLeft);

		if @L_Jump == NULL then
			EmitLabel(@LabelResolve(CASE_I, lCASEBODY));
			pTypeBody = Code_Block(Node[BODY_I].pLeft);
		else
			pTypeBody = st_noreturn;
		end:if

		if pTypeBody != st_noreturn then
			pTypeFinal = st_void;
			when NEXT_CASE_I < nNODE:
				EmitJumpToLabel(@L_Exit);
		end:if

		CASE_I = NEXT_CASE_I;
	end:while

	when !DefaultBranchPresent:
		pTypeFinal = st_void;

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	when (pTypeBody == st_noreturn) & !LabelIsUsed(@LabelResolve(P, lEXIT)):
		pTypeFinal = st_noreturn;

	return pTypeFinal;
end

/*****************************************************************************/

word Code_WHILE(word P; char @Buff)

	/*
	                 iWHILE
	                /     \
	              iBODY    [next statement]
	             /    \
	  [loop body]    iCOND
	                /    \
	[loop condition]      NULL
	*/

	LABEL @L_Exit = @CodeExtractExitLabel(P);

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	EmitLabel(@LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		CodeBooleanExpr(Node[COND].pLeft, @L_Exit, NULL, @LabelResolve(P, lLOOPBODY));
		EmitLabelIfUsed(@LabelResolve(P, lLOOPBODY));
	end

	CodeList_InsertVirtualJump(Node[BODY].pLeft, P, lCONTINUE);
	word pTypeBody = Code_List(Node[BODY].pLeft);
	when pTypeBody != st_noreturn:
		EmitJumpToLabelWithComment(@LabelResolve(P, lCONTINUE), "while");

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);

	when !LabelIsUsed(@LabelResolve(P, lEXIT)):
		return st_noreturn;

	return Node[P].pType;
end

/*****************************************************************************/

word Code_REPEAT(word P; char @Buff)

	/*
	                 iREPEAT
	                /      \
	              iBODY     [next statement]
	             /    \
	  [loop body]    iCOND
	                /    \
	[loop condition]      NULL
	*/

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternalCodegen(__FILE__, __LINE__);

	/* Check the case when loop can be replaced with simple code block */
	if NodeIsTrue(Node[COND].pLeft) &
	   !CTE_LoopHasExits(P, Node[BODY].pLeft) &
	   !CTE_LoopHasContinues(P, Node[BODY].pLeft)
	then
		Code_List(Node[BODY].pLeft);
		return st_void;
	end

	EmitLabel(@LabelResolve(P, lLOOPBODY));

	Code_List(Node[BODY].pLeft);

	EmitLabelIfUsed(@LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		CodeBooleanExpr(Node[COND].pLeft, @LabelResolve(P, lLOOPBODY), NULL, @LabelResolve(P, lEXIT));
	end

	EmitLabelIfUsed(@LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);

	return Node[P].pType;
end

/*****************************************************************************/

word Code_CONTINUE(word P; char @Buff)
	EmitJumpToLabelWithComment(@CodeExtractJump(P), "continue");
	return st_noreturn;
end

/*****************************************************************************/

word Code_EXIT(word P; char @Buff)
	EmitJumpToLabelWithComment(@CodeExtractJump(P), "exit");
	return st_noreturn;
end

/*****************************************************************************/
