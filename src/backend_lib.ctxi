
/*
	Вспомогательные и интерфейсные функции, не подходящие в другие файлы.
*/

/*****************************************************************************/

word AlignTo(word v; word align)
	while v % align !=0 do
		inc v;
	end
	return v;
end

/*****************************************************************************/

word DefaultStaticAlign(word v)
	return AlignTo(v, target_default_static_alignment);
end

/*****************************************************************************/

word DefaultInStackAlign(word v)
	return AlignTo(v, target_default_stack_alignment);
end

/*****************************************************************************/

word SizeOfType(word pType)
	when Dict[pType].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);
	return T_SizeOf(pType);
end

/*****************************************************************************/

/*
	Распаковывает из узлов iDATA, iPARM, iLOCAL и iSTRING информацию об объекте.
	(Ofs - смещение относительно специфичного источника (напр., для iDATA - смещение от начала секции данных и т.п.))
*/
word ExtractDataInfo(word P, @pType, @nIndx, @Ofs, @RO)

	word ID = Node[P].ID;

	select
		case ID == iDATA:
			pType = Dict[Node[P].Value].pType;
			//nIndx = T_ArrayGetSizeOr0(Dict[Node[P].Value].pType);
			Ofs   = Dict[Node[P].Value].Label;
			RO    = 0;

		case ID == iPARM:
			when Dict[Node[P].Value].Class != cARG:
				StopInternal(__FILE__, __LINE__);
			pType = Dict[Node[P].Value].pType;
			//nIndx = T_ArrayGetSizeOr0(Dict[Node[P].Value].pType);
			Ofs   = Dict[Node[P].Value].Label;
			RO    = 0;

		case ID == iLOCAL:
			pType = Local[Node[P].Value].pType;
			//nIndx = T_ArrayGetSizeOr0(Local[Node[P].Value].pType);
			Ofs   = Local[Node[P].Value].Value;
			RO    = 0;

		case ID == iSTRING:
			nIndx = 0;
			pType = Dict[Node[P].Value].pType;
			Ofs   = Dict[Node[P].Value].Label;
			RO    = Dict[Node[P].Value].RO;

		default:
			StopInternal(__FILE__, __LINE__);
      end

	nIndx = 0;
	if pType < nDICT then
		nIndx = T_ArrayGetSizeOr0(pType);
		when T_IsArray(pType) != 0:
			pType = T_ArrayDeref(pType);
	end:if

	return ID;
end

/*****************************************************************************/

word NodeHasConst(word P; word Data)
	if (Node[P].ID == iNULL & Data == 0)
	 | (Node[P].ID == iLITERAL & Node[P].Value == Data) then
		return 1;
	end:if
	return 0;
end

/*****************************************************************************/

/*

ID             Value Location                  LValue    Indirect
iSTRING, RO=0: [@@RWLITERALS + XI + Offset]    Yes       Yes
iSTRING, RO=1: [@@ROLITERALS + XI + Offset]    No        Yes
iDATA:         [@@DATA       + XI + Offset]    Yes       Yes
iPARM:         [EBP          + XI + Offset]    Yes       Yes
iLOCAL:        [EBP          + XI - Offset]    Yes       Yes
iREF:          [               XI + Offset]    Yes       Yes
iREG                           XI + Offset     No        No
iCONST                              Offset     No        No
*/

struct ValueRef
	word ID;
	word RO;
	word pType;
	word Size;
	word Offset;
	word XI;
end

bool ValueRef_IsLValue(ValueRef@ vref)
	switch vref.ID of
	case iSTRING:
		when vref.RO == 0:
			return true;
		return false;
	case iDATA, iPARM, iLOCAL, iREF:
		return true;
	case iREG, iCONST:
		return false;
	end:switch
end

bool ValueRef_IsIndirect(ValueRef@ vref)
	switch vref.ID of
	case iSTRING, iDATA, iPARM, iLOCAL, iREF:
		return true;
	case iREG, iCONST:
		return false;
	end:switch
end

/*****************************************************************************/

