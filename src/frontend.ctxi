
/*****************************************************************************/

include "frontend_charid.ctxi"
include "frontend_node.ctxi"
include "frontend_lex.ctxi"

/*****************************************************************************/

char@ ResolveFileName(char@ Buff)
	char FileName[MAX_FPATH];
	
	strn_cpy(@FileName, @CurrentFileInfo.FileName, MAX_FPATH);
	FileName[fpath_last_part(@FileName)] = #0;
	
	char @S = @Buff;
	do
		word Pos = str_find_chars(@S, "/\");
		if Pos != 0 then
			char Fragment[MAX_FPATH];
			strn_cpy(@Fragment, @S, MAX_FPATH);
			Fragment[Pos] = #0;
			fpathn_cat(@FileName, @Fragment, MAX_FPATH);
			if S[Pos] == #0 then
				exit;
			end:if
		end:if
		@S = @S[Pos + 1];
	end:do
	
	return @Char[SaveString0(@FileName)];
end

/*****************************************************************************/

word function __Statements(char @Buff; char @End1; char @End2; char @End3)
__Statements @_Statements;

/*****************************************************************************/

word function __Ctrl(char @Buff)
__Ctrl @_Ctrl;

/*****************************************************************************/

word function __Expr(word Prty; char @Buff)
__Expr @_Expr;

/*****************************************************************************/

void function  __CTE(word P)
__CTE @_CTE;

/*****************************************************************************/

word pFunc;
word pLoop;

/*****************************************************************************/

include "frontend_local.ctxi"
include "frontend_syn_operators.ctxi"
include "frontend_syn_expr.ctxi"
include "frontend_syn_statements.ctxi"
include "frontend_syn_up.ctxi"

/*****************************************************************************/

void InitFrontEnd()

	init_charid();
	InitLex();
	InitCharData();
	InitOperator();

	nDict = 0;
	nLocal = 0;
	nNode = 0;

	nFile = 0;
	pFile = 0;

	@_Statements = @Statements;
	@_Ctrl       = @Ctrl;
	@_Expr       = @Expr;
	@_CTE        = @CTE;

	RegisterDigraph("!=");
	RegisterDigraph("<=");
	RegisterDigraph(">=");
	RegisterDigraph(":=");
	RegisterDigraph("==");

	RegisterDigraph("/*");
	RegisterDigraph("//");
	RegisterComment("/*", "*/");
	RegisterComment("//", "~n");
	RegisterHereCommentPrefix("$comment");

	Word("include");
	Word("define");
	Word("struct");
	Word("synonym");
	Word("function");
	Word("external");
	Word("begin");
	Word("select");
	Word("case");
	Word("default");
	Word("if");
	Word("then");
	Word("else");
	Word("while");
	Word("do");
	Word("repeat");
	Word("until");
	Word("continue");
	Word("exit");
	Word("inc");
	Word("dec");
	Word("inline");
	Word("return");
	Word("null");
	Word("NULL");
	Word("end");
	Word("switch");
	Word("of");
	Word("when");
	Word("false");
	Word("true");
	Word("sizeof");
	Word("__FILE__");
	Word("__LINE__");

	st_void    = BaseType("void", sBASE_VOID, 0);
	st_bool    = BaseType("bool", sBASE_BOOL, target_size_of_bool);

	st_char    = BaseType("char", sBASE_CHAR, 1);
	st_byte    = BaseType("byte", sBASE_UINT, 1);

	st_int8    = BaseType("int8", sBASE_SINT, 1);
	st_int16   = BaseType("int16", sBASE_SINT, 2);
	st_int32   = BaseType("int32", sBASE_SINT, 4);
	st_int64   = BaseType("int64", sBASE_SINT, 8);
	st_int128  = BaseType("int128", sBASE_SINT, 16);

	st_uint8   = BaseType("uint8", sBASE_UINT, 1);
	st_uint16  = BaseType("uint16", sBASE_UINT, 2);
	st_uint32  = BaseType("uint32", sBASE_UINT, 4);
	st_uint64  = BaseType("uint64", sBASE_UINT, 8);
	st_uint128 = BaseType("uint128", sBASE_UINT, 16);

	st_intptr  = BaseType("intptr", sBASE_SINT, target_size_of_pointer);
	st_uintptr = BaseType("uintptr", sBASE_UINT, target_size_of_pointer);

	st_short   = BaseType("short" , sBASE_SINT, target_size_of_short);
	st_ushort  = BaseType("ushort", sBASE_UINT, target_size_of_short);
	st_int     = BaseType("int" , sBASE_SINT, target_size_of_int);
	st_uint    = BaseType("uint", sBASE_UINT, target_size_of_int);
	st_long    = BaseType("long" , sBASE_SINT, target_size_of_long);
	st_ulong   = BaseType("ulong", sBASE_UINT, target_size_of_long);
	st_word    = BaseType("word", sBASE_UINT, target_size_of_word);

	st_float   = BaseType("float", sBASE_FLOAT, target_size_of_float);
	st_double  = BaseType("double", sBASE_FLOAT, target_size_of_double);
	st_long_double = BaseType("long_double", sBASE_FLOAT, target_size_of_long_double);

	RegisterOperators();

	strcpy(@Text,"");

	DefineInteger("__CONTEXT2_VERSION_MAJOR__ ", st_word, 0);
	DefineInteger("__CONTEXT2_VERSION_MINOR__ ", st_word, 1);
	DefineString("__CONTEXT2_VERSION_STR__", "0.1");
	DefineString("__TRANSLATOR__", @msgPRODUCT);
	DefineString("__TRANSLATOR_VERSION__", @msgVERSION);
	DefineString("__TRANSLATOR_HOST__", @__TRANSLATOR_TARGET__);

	select
	case TargetFileFormat == tPE:
		DefineString("__TRANSLATOR_TARGET__", "i386-win32-pe");
		strcat(@Text,"void ExitProcess(word uExitCode) external KERNEL32;");
	case TargetFileFormat == tELF:
		DefineString("__TRANSLATOR_TARGET__", "i386-linux-elf");
	default:
		StopInternal(__FILE__, __LINE__);
	end:select

	strcat(@Text,"  ");


	nText = strlen(@Text);
	pText = 0;
	CurrentFileInfo.Line = 1;
	CurrentFileInfo.Column = 1;
	@CurrentFileInfo.FileName = NULL;
	BeforeFirstFile = 1;

	pLoop = nNODE;

end

/*****************************************************************************/

