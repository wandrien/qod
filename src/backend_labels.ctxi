
/*****************************************************************************/

LABEL    Label [nLABEL]; // Таблица ссылок
word    nLabel = 1;

/*****************************************************************************/

word NextLabelValue = 10000;

word NewLabel()
	word l = NextLabelValue;
	inc NextLabelValue;
	return l;
end

/*****************************************************************************/

void LabelAllocate(word N; word Name)
	when nLabel >= nLABEL:
		StopMemory();
	Label[nLabel].Name = Name;
	Label[nLabel].Value = NewLabel();
	Label[nLabel].pNext = Node[N].pLabel;
	Node[N].pLabel = nLabel;
	inc nLabel;
end

word LabelResolve(word N; word Name)
	word L = Node[N].pLabel;
	do
		when L = 0 | L >= nLabel:
			StopInternal();
		when Label[L].Name = Name:
			exit;
		L = Label[L].pNext;
	end:do
	return Label[L].Value;
end

/*****************************************************************************/

void function __NodeMarkUsed(word P)
__NodeMarkUsed @_NodeMarkUsed;

void DictMarkUsed(word D)
	when D >= nDICT:
		return;

	when Dict[D].Used != 0:
		return;

	Dict[D].Used = 1;
	DictMarkUsed(Dict[D].pType);
	_NodeMarkUsed(Dict[D].pNode);
end

void NodeMarkUsed(word P)
	when P >= nNODE:
		return;

	when Node[P].Used != 0:
		return;

	Node[P].Used = 1;
	DictMarkUsed(Node[P].pType);

	switch Node[P].ID of
	case iCALL, iFUNC, iDATA, iSTRING:
		DictMarkUsed(NodeGetDict(P));
	end:switch

	NodeMarkUsed(Node[P].pLeft );
	NodeMarkUsed(Node[P].pRight);
end

void DoWarnUnusedGlobals()
	char Buff[1024];
	word  P = 0;
	while P < nDict do
		if Dict[P].Used = 0 then
			select
			case Dict[P].Class = cDATA:
				strcpy(@Buff, @DictGetName(P));
				strcat(@Buff, @wGLOBALVARUNUSED);
				Warn(@Buff);
			case Dict[P].Class = cFUNC:
				strcpy(@Buff, @DictGetName(P));
				strcat(@Buff, @wFUNCUNUSED);
				Warn(@Buff);
			case Dict[P].Class = cTYPE & Dict[P].Sub != sBASE:
				strcpy(@Buff, @DictGetName(P));
				strcat(@Buff, @wTYPEUNUSED);
				Warn(@Buff);
			end:select
		end:if
		inc P;
	end
end

/*****************************************************************************/


// Pасстановка меток

word     Enum(word P; word Flag)
  if P>=nNODE then
    return 0;
  end

  select
    case Flag!=0:
      word  S=0;
      word  M=0;
      while P<nNODE do
        select
          case Node[P].ID=iSELECT:
            LabelAllocate(P, lEXIT);
            word  CASE = Node[P].pLeft;
            while CASE < nNODE do
                when Node[CASE].ID != iCASE:
                    StopInternal();

                LabelAllocate(CASE, lCASEBODY);
                LabelAllocate(CASE, lCASEBODYEND);

                word COND = Node[CASE].pLeft;
                word BODY = Node[COND].pRight;

                when Node[BODY].ID != iBODY
                |    Node[COND].ID != iCOND:
                    StopInternal();

                Enum(Node[COND].pLeft,0);

                word V=Enum(Node[BODY].pLeft,1);
                if M<S+V then
                  M=S+V;
                end

                CASE = Node[CASE].pRight;
            end

          case Node[P].ID=iSWITCH :

			LabelAllocate(P, lEXIT);

			word COND = Node[P].pLeft;
			when Node[COND].ID != iCOND:
				StopInternal();

			Enum(Node[COND].pLeft,0);

			word  CASE_I = Node[COND].pRight;
			while CASE_I < nNODE do
				when Node[CASE_I].ID != iCASE:
					StopInternal();

				LabelAllocate(CASE_I, lCASEBODY);

				word  VALUE_I = Node[CASE_I].pLeft;
				while VALUE_I < nNode do
					when Node[VALUE_I].ID != iVALUE
					&    Node[VALUE_I].ID != iDEFAULT
					&    Node[VALUE_I].ID != iBODY:
						StopInternal();
					if Node[VALUE_I].ID = iBODY then
						word V=Enum(Node[VALUE_I].pLeft,1);
						if M<S+V then
							M=S+V;
						end
					end
					VALUE_I = Node[VALUE_I].pRight;
				end:while

				CASE_I = Node[CASE_I].pRight;
			end:while

          case Node[P].ID=iWHILE | Node[P].ID=iREPEAT:
            word BODY = Node[P].pLeft;
            word COND = Node[BODY].pRight;
            when Node[BODY].ID != iBODY
            |    Node[COND].ID != iCOND:
                StopInternal();

            LabelAllocate(P, lLOOPBODY);
            LabelAllocate(P, lCONTINUE);
            LabelAllocate(P, lEXIT);

            Enum(Node[COND].pLeft,0);

            word V=Enum(Node[BODY].pLeft,1);
            if M<S+V then
              M=S+V;
            end

          case Node[P].ID=iDEF_LOCAL:
            /*word Size=4;
            if Node[Node[P].pLeft].Value=0 then
              Size=Dict[Node[P].Value].Value;
            end

            S=S+DefaultInStackAlign(Node[Node[Node[P].pLeft].pLeft].Value*Size);
*/
			word Size = SizeOfType(Node[P].pType, Node[Node[Node[P].pLeft].pLeft].Value);
			S=S+DefaultInStackAlign(Size);

            if M<S then
              M=S;
            end
        end

        P=Node[P].pRight;
      end

      return M;

    case Node[P].ID!=iASSIGN & Node[P].ID!=iINC & Node[P].ID!=iDEC:
      Enum(Node[P].pLeft, 0);

      if Node[P].ID = iOR | Node[P].ID = iAND then
        LabelAllocate(P, lBRANCH);
      end

      Enum(Node[P].pRight,0);
  end

  return 0;
end


/*****************************************************************************/


word AssignLabels_Data()

	word D = 0;

	word I = 0;
	while I < nDict do
		select
		case Dict[I].Class = cDATA & Dict[I].Used != 0:
			Dict[I].Value = D;
			word Size = SizeOfType(Dict[I].pType, Dict[I].nIndx);
			D = D + DefaultStaticAlign(Size);
		end:select

		inc I;
	end


	return D;
end


/*****************************************************************************/


void AssignLabels_Struct()

	word I=0;
	while I < nDict do
		select
		case Dict[I].Class = cTYPE & Dict[I].Sub = sSTRUCT:
			word D1 = 0;
			word P = Dict[I].pFirst;
			while P < nDICT do
				when Dict[P].Class != cFIELD:
					StopInternal();
				Dict[P].Value = D1;
				D1 = D1 + SizeOfType(Dict[P].pType, Dict[P].nIndx);

				P = Dict[P].pNext;
			end:while

			Dict[I].Value = D1;
		end:select
		inc I;
	end:while
end


void AssignLabels_Func()

  word I=0;
  while I<nDict do
    select
      case Dict[I].Class=cFUNC & Dict[I].Sub!=sSYS & Dict[I].Used!=0:
        Dict [I].Value = NewLabel();

        Dict [I].Stack=Enum(Dict[I].pNode,1);
    end

    inc I;
  end

end


void AssignLabels_FuncExternal()

  word I=0;
  while I<nDict do
    if Dict[I].Class=cLIB then
      word  J=0;
      while J<nDict do
        if Dict[J].Class=cFUNC & Dict[J].Sub=sSYS & Dict[J].pNode=I & Dict[J].Used!=0 then
          word Label = NewLabel();
          if Dict[I].Used=0 then
            Dict[I].Value = Label;
            Dict[I].Used =1;
          end

          Dict [J].Value = Label;
        end

        inc J;
      end
    end

    inc I;
  end
end