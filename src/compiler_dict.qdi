
/*****************************************************************************/

DICT     Dict [nDICT]; // Таблица имен
word    nDict;
word    tArrayTypes;

/*****************************************************************************/

/* Индексы встроенных типов данных. */

word st_type;
word st_void;
word st_noreturn;
word st_nulltype;
word st_bool8;
word st_bool16;
word st_bool32;
word st_bool;
word st_char;
word st_byte;
word st_int8;
word st_int16;
word st_int32;
word st_int64;
word st_int128;
word st_intptr;
word st_uint8;
word st_uint16;
word st_uint32;
word st_uint64;
word st_uint128;
word st_uintptr;
word st_word;
word st_short;
word st_ushort;
word st_int;
word st_uint;
word st_long;
word st_ulong;
word st_float;
word st_double;
word st_long_double;

/* Вспомогательные типы, которые не видны наружу: */
word st_cond_branch;

/*****************************************************************************/

/*
	Проверяет достаточность памяти таблице Dict для выделения одного элемента.
	TODO: при нехватке памяти, перераспределять динамически.
*/
void DictMemCheck()
	when nDict >= nDICT:
		StopMemory();
end

/*****************************************************************************/

void DictSetName(word D; char@ Name)

	when D >= nDict:
		StopInternal(__FILE__, __LINE__);

	Dict[D].Name2    = SaveString0(@Name);
	Dict[D].NameHash = str_hash(@Name);
end

/*****************************************************************************/

char @DictGetName(word D)
	when D >= nDict:
		StopInternal(__FILE__, __LINE__);

	return @Char[Dict[D].Name2];
end

/*****************************************************************************/

void Dict_MakeFullyQualifiedName(strbuf @Buff; word D)
	when D == nDICT:
		return;
	when Dict[D].pNamespace != D:
		Dict_MakeFullyQualifiedName(@Buff, Dict[D].pNamespace);
	when strbuf_get_virtual_len(@Buff) > 0:
		strbuf_append_cstr(@Buff, ".");
	strbuf_append_cstr(@Buff, @DictGetName(D));
end

char @DictGetFullyQualifiedName(word D)
	when D >= nDict:
		StopInternal(__FILE__, __LINE__);

	word Index = Dict[D].FullyQualifiedName;
	when Index != 0:
		return @Char[Index];

	char Buff[nBUFF];
	strbuf buf;
	strbuf_init(@buf, @Buff, nBUFF);
	Dict_MakeFullyQualifiedName(@buf, D);

	Index = SaveString0(@Buff);
	Dict[D].FullyQualifiedName = Index;
	return @Char[Index];
end

/*****************************************************************************/

/* Выделить запись в таблице глобальных имён и вернуть её индекс.  */
word DictAlloc()

	DictMemCheck();

	word r = nDict;
	inc nDict;

	DICT @d = @Dict[r];

	d.Name2 = 0;
	d.Used = 0;
	d.FullyQualifiedName = 0;
	d.pType = nDICT;
	d.tCachedPtrToMe = nDICT;
	d.tCachedFuncTypeOfMe = nDICT;
	d.tCachedIntegerPair = nDICT;
	d.pNamespace = nDICT;
	d.pNext = nDICT;
	d.pFirst = nDICT;
	d.pLast = nDICT;
	DictSetName(r, "<None>");

	return r;
end

void DictFree(word @D)
	Dict[D].Used = 0;
	Dict[D].Class = cNONE;
	Dict[D].Sub = sNONE;
	DictSetName(D, "<None>");
	@D = NULL;
end

/*****************************************************************************/

word DictResolveAlias(word P)
	while Dict[P].Class == cNAME do
		P = Dict[P].pType;
		when P >= nDict:
			StopInternal(__FILE__, __LINE__);
	end
	return P;
end

/*****************************************************************************/

/*
	Поиск объекта в заданном пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word FindInNamespace(char @Name; word pNamespace)
	when pNamespace >= nDict:
		StopInternal(__FILE__, __LINE__);

	word hash = str_hash(@Name);
	word P = Dict[pNamespace].pFirst;
	while P < nDict do
		when Dict[P].pNamespace != pNamespace:
			StopInternal(__FILE__, __LINE__);
		if Dict[P].NameHash == hash
		&  strcmp(@DictGetName(P), @Name) == 0
		&  Dict[P].Class != cFILE then
			return DictResolveAlias(P);
		end
		P = Dict[P].pNext;
	end

	return nDICT;
end

/*****************************************************************************/

/*
	Поиск объекта в корневом пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word Find(char @Name)
	word hash = str_hash(@Name);
	word P = 0;
	while P < nDict do
		DICT @d = @Dict[P];
		if d.NameHash == hash
		&  strcmp(@DictGetName(P), @Name) == 0
		&  d.Class != cFILE
		&  d.pNamespace == nDICT then
			return DictResolveAlias(P);
		end
		inc P;
	end
	return nDICT;
end

/*****************************************************************************/

/*
	Поиск объекта с классом cFILE в корневом пространстве имён по имени.
*/
word Find_cFILE(char @Name)
	word hash = str_hash(@Name);
	word  P = 0;
	while P < nDict do
		if Dict[P].NameHash == hash
		&  strcmp(@DictGetName(P), @Name) == 0
		&  Dict[P].Class == cFILE
		&  Dict[P].pNamespace == nDICT then
			return P;
		end
		inc P;
	end

	return nDICT;
end

/*****************************************************************************/

word DictMakeNamespace(char @Name)
	word pNamespace = DictAlloc();
	when @Name != NULL:
		DictSetName(pNamespace, @Name);
	Dict[pNamespace].Class = cTYPE;
	Dict[pNamespace].Sub = sNAMESPACE;
	return pNamespace;
end

void DictAddToNamespace(word P; word pNamespace)
	when P >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[P].pNamespace != nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[P].pNext != nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[pNamespace].pFirst != nDICT & Dict[pNamespace].pLast == nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[pNamespace].pFirst == nDICT & Dict[pNamespace].pLast != nDICT:
		StopInternal(__FILE__, __LINE__);
	when pNamespace >= nDict:
		StopInternal(__FILE__, __LINE__);

	Dict[P].pNamespace = pNamespace;
	if Dict[pNamespace].pLast < nDICT then
		Dict[Dict[pNamespace].pLast].pNext = P;
		Dict[pNamespace].pLast = P;
	else
		Dict[pNamespace].pFirst = P;
		Dict[pNamespace].pLast = P;
	end:if
end

/*****************************************************************************/

/* Регистрирует ключевое слово. */
word DictMakeWord(char @Name)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cWORD;
	return p;
end

/*****************************************************************************/

/* Регистрирует базовый тип. */
word DictMakeBaseType(char @Name; byte TypeDomain; word Size)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class    = cTYPE;
	Dict[p].Sub      = TypeDomain;
	Dict[p].TypeSize = Size;
	return p;
end

/*****************************************************************************/

word DictDupLiteral(word D1)
	when D1 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[D1].Class != cLITERAL:
		StopInternal(__FILE__, __LINE__);

	word D2 = DictAlloc();
	DictSetName(D2, "");

	DICT @d1 = @Dict[D1];
	DICT @d2 = @Dict[D2];
	d2.Class = d1.Class;
	d2.Sub   = d1.Sub;
	d2.RO    = d1.RO;
	d2.pType = d1.pType;
	d2.nLiteralSize = d1.nLiteralSize;
	d2.LiteralValue = d1.LiteralValue;

	return D2;
end

/*****************************************************************************/

bool Dict_IsFunction(word D)
	when D >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[D].Class == cFUNC;
end

bool Dict_IsType(word D)
	when D >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[D].Class == cTYPE;
end

/*****************************************************************************/

bool T_Equal(word T1, T2)
	when T1 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[T1].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	when T2 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[T2].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	when T1 == T2:
		return true;

	if Dict[T1].Sub == Dict[T2].Sub then
		switch Dict[T1].Sub of
		case sBASE_UINT, sBASE_SINT, sBASE_CHAR, sBASE_BOOL, sBASE_FLOAT:
			when Dict[T1].TypeSize == Dict[T2].TypeSize:
				return true;
		end:switch
	end:if

	return false;
end

/*****************************************************************************/

bool T_IsType(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_TYPE;
end

bool T_IsNulltype(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_NULL;
end

bool T_IsChar(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_CHAR;
end

bool T_IsBool(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_BOOL;
end

bool T_IsUnsigned(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_UINT;
end

bool T_IsSigned(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sBASE_SINT;
end

bool T_IsInteger(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return T_IsUnsigned(T) | T_IsSigned(T);
end

/*****************************************************************************/

word T_SizeOf(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[T].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	when Dict[T].Sub == sARRAY:
		return Dict[T].TypeSize * T_SizeOf(Dict[T].pType);

	return Dict[T].TypeSize;
end

/*****************************************************************************/

word T_GetIntegerPair_(word T)
	select
	case T == st_int8: return st_uint8;
	case T == st_int16: return st_uint16;
	case T == st_int32: return st_uint32;
	case T == st_int64: return st_uint64;
	case T == st_int128: return st_uint128;

	case T == st_uint8: return st_int8;
	case T == st_uint16: return st_int16;
	case T == st_uint32: return st_int32;
	case T == st_uint64: return st_int64;
	case T == st_uint128: return st_int128;

	case T == st_short: return st_ushort;
	case T == st_int: return st_uint;
	case T == st_long: return st_ulong;
	case T == st_intptr: return st_uintptr;

	case T == st_ushort: return st_short;
	case T == st_uint: return st_int;
	case T == st_ulong: return st_long;
	case T == st_uintptr: return st_intptr;

	case T == st_byte: return st_int8;
	case T == st_word: return st_int;

	case T_IsSigned(T):
		word Size = T_SizeOf(T);
		char Buff[nBUFF];
		strcpy3(@Buff, "unsigned(", @str(Size),")");
		return DictMakeBaseType(@Buff, sBASE_UINT, Size);

	case T_IsUnsigned(T):
		word Size = T_SizeOf(T);
		char Buff[nBUFF];
		strcpy3(@Buff, "signed(", @str(Size),")");
		return DictMakeBaseType(@Buff, sBASE_SINT, Size);

	default:
		StopInternal(__FILE__, __LINE__);

	end:select
end

word T_GetIntegerPair(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	if Dict[T].tCachedIntegerPair == nDICT then
		word tPair = T_GetIntegerPair_(T);
		Dict[T].tCachedIntegerPair = tPair;
		Dict[tPair].tCachedIntegerPair = T;
	end

	return Dict[T].tCachedIntegerPair;
end

/*****************************************************************************/

define MinMaxIsUnsigned 0
define MinMaxIsSigned 1

word T_GetMinMaxOf(word T; word @_Min; word @_Max)
	word Min = 0;
	word Max = 0;

	select
	case T_IsUnsigned(T):
		switch T_SizeOf(T) of
		case 1: Max = 0xFF;
		case 2: Max = 0xFFFF;
		case 4: Max = 0xFFFF_FFFF;
		default:
			Stop(@eNOTAVAIL);
		end:switch
		when @_Min != NULL:
			_Min = Min;
		when @_Max != NULL:
			_Max = Max;
		return MinMaxIsUnsigned;
	case T_IsSigned(T):
		switch T_SizeOf(T) of
		case 1: Min = 0x80; Max = 0x7F;
		case 2: Min = 0x8000; Max = 0x7FFF;
		case 4: Min = 0x8000_0000; Max = 0x7FFF_FFFF;
		default:
			Stop(@eNOTAVAIL);
		end:switch
		when @_Min != NULL:
			_Min = Min;
		when @_Max != NULL:
			_Max = Max;
		return MinMaxIsSigned;
	default:
		StopInternal(__FILE__, __LINE__);
	end
end

/*****************************************************************************/

bool T_IsArray(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sARRAY;
end

word T_ArrayDeref(word T)
	when !T_IsArray(T):
		StopInternal(__FILE__, __LINE__);
	return Dict[T].pType;
end

word T_ArrayGetLen(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class != cTYPE | Dict[T].Sub != sARRAY:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].TypeSize;
end

word T_ArrayGetLenOr0(word T)
	when !T_IsArray(T):
		return 0;
	return T_ArrayGetLen(T);
end

word T_Array(word T; word S)
	word P = tArrayTypes;
	while P < nDict do
		DICT @d = @Dict[P];
		when d.Class != cTYPE | d.Sub != sARRAY:
			StopInternal(__FILE__, __LINE__);
		if d.pType == T
		 & d.TypeSize == S then
			return P;
		end:if
		P = d.tLink;
	end:while

	P = DictAlloc();
	DICT @d = @Dict[P];
	d.Class    = cTYPE;
	d.Sub      = sARRAY;
	d.pType    = T;
	d.TypeSize = S;
	d.tLink    = tArrayTypes;
	tArrayTypes = P;
	return P;
end

/*****************************************************************************/

bool T_IsPtr(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sPTR;
end

bool T_IsPtrTo(word T; word T2)
	return T_IsPtr(T) & (Dict[T].pType == T2);
end

word T_DerefPtr(word T)
	when !T_IsPtr(T):
		StopInternal(__FILE__, __LINE__);
	return Dict[T].pType;
end

word T_PtrTo(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	if T_IsArray(T) then
		T = T_ArrayDeref(T);
	end

	if Dict[T].tCachedPtrToMe >= nDICT then
		word PTR = DictAlloc();
		DICT @dPtr = @Dict[PTR];
		dPtr.Class    = cTYPE;
		dPtr.Sub      = sPTR;
		dPtr.TypeSize = target_size_of_pointer;
		dPtr.pType    = T;
		Dict[T].tCachedPtrToMe = PTR;
	end

	return Dict[T].tCachedPtrToMe;
end

word T_nPtrTo(word nPtr; word T)
	while nPtr > 0 do
		T = T_PtrTo(T);
		dec nPtr;
	end:while
	return T;
end

/*****************************************************************************/

bool T_IsFunc(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].Class == cTYPE & Dict[T].Sub == sFUNCTYPE;
end

word T_FuncGetRetType(word T)
	when !T_IsFunc(T):
		StopInternal(__FILE__, __LINE__);
	return Dict[T].pType;
end

/*
	Функция проверяет идентичность функциональных типов.
	Аргументами могут выступать функциональные типы, либо функции.
*/
bool T_IsFuctTypesIdentical(word T1; word T2)
	when T1 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T2 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T1 == T2:
		return true;

	when !((Dict[T1].Class == cTYPE & Dict[T1].Sub == sFUNCTYPE) | (Dict[T1].Class == cFUNC)):
		return false;

	when !((Dict[T2].Class == cTYPE & Dict[T2].Sub == sFUNCTYPE) | (Dict[T2].Class == cFUNC)):
		return false;

	when Dict[T1].pType != Dict[T2].pType:
		return false;

	word pARGS1 = FindInNamespace("args", T1);
	word pARGS2 = FindInNamespace("args", T2);
	when pARGS1 >= nDICT | pARGS2 >= nDICT:
		StopInternal(__FILE__, __LINE__);

	word P1 = Dict[pARGS1].pFirst;
	word P2 = Dict[pARGS2].pFirst;
	forever do
		when P1 == nDICT & P2 == nDICT:
			return true;

		when P1 == nDICT:
			return false;
		when P2 == nDICT:
			return false;
		when !T_Equal(Dict[P1].pType, Dict[P2].pType):
			return false;

		P1 = Dict[P1].pNext;
		P2 = Dict[P2].pNext;
	end:forever
end

word T_FuncTypeForFunction(word F)

	when F >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[F].Class != cFUNC:
		StopInternal(__FILE__, __LINE__);

	when Dict[F].tCachedFuncTypeOfMe < nDict:
		return Dict[F].tCachedFuncTypeOfMe;

	word P = 0;
	while P < nDict do
		if Dict[P].pNamespace == nDICT
		 & Dict[P].Class == cTYPE
		 & Dict[P].Sub == sFUNCTYPE
		 & strcmp(@DictGetName(P), "") == 0
		 & T_IsFuctTypesIdentical(F, P) == true
		 then
			return P;
		end:if
		inc P;
	end:while

	P = DictAlloc();
	Dict[P].Class = cTYPE;
	Dict[P].Sub   = sFUNCTYPE;
	Dict[P].pType = Dict[F].pType;

	word F_ARGS = FindInNamespace("args", F);

	word P_ARGS = DictAlloc();
	DictSetName(P_ARGS, "args");
	Dict[P_ARGS].Class = cARGS;
	DictAddToNamespace(P_ARGS, P);

	word F_ARG = Dict[F_ARGS].pFirst;
	forever do
		when F_ARG == nDICT:
			exit;

		word P_ARG = DictAlloc();
		DictSetName(P_ARG, "");
		Dict[P_ARG].Class = cARG;
		Dict[P_ARG].pType = Dict[F_ARG].pType;
		DictAddToNamespace(P_ARG, P_ARGS);

		F_ARG = Dict[F_ARG].pNext;
	end:forever

	Dict[F].tCachedFuncTypeOfMe = P;

	return P;
end

/*****************************************************************************/

void T_GetName_(word T; strbuf @Buff)
	when !Dict_IsType(T):
		StopInternal(__FILE__, __LINE__);

	select
	case Dict[T].Sub == sSTRUCT:
		/* TODO: not implemented */
		strbuf_append_cstr(@Buff, @DictGetFullyQualifiedName(T));
	case Dict[T].Sub == sFUNCTYPE:
		/* TODO: not implemented */
		strbuf_append_cstr(@Buff, @DictGetFullyQualifiedName(T));
	case Dict[T].Sub == sPTR:
		strbuf_append_cstr(@Buff, "@");
		T_GetName_(Dict[T].pType, @Buff);
	case Dict[T].Sub == sARRAY:
		strbuf_append_cstr(@Buff, "[");
		strbuf_append_cstr(@Buff, @str_saved(T_ArrayGetLen(T)));
		strbuf_append_cstr(@Buff, "]");
		T_GetName_(Dict[T].pType, @Buff);
	default:
		strbuf_append_cstr(@Buff, @DictGetFullyQualifiedName(T));
	end:select
end

char @T_GetName(word T)
	when Dict_IsFunction(T):
		T = T_FuncTypeForFunction(T);

	char Buff[nBUFF];
	strbuf buf;
	strbuf_init(@buf, @Buff, nBUFF);
	T_GetName_(T, @buf);

	word Index = SaveString0(@Buff);
	return @Char[Index];
end

/*****************************************************************************/

void function DumpDictEntryCallback(char @S)

void DumpDictEntry(word I; DumpDictEntryCallback@ cb)

	char B[1024];
	char @dump_prefix = "; ";

	strcpy(@B, "");

	strcat(@B, @dump_prefix);
	strcat(@B, @str(I));
	strcat(@B, ": ");
	strcat(@B, @DictGetName(I));
	strcat(@B, "~n");

	strcat(@B, @dump_prefix);
	strcat(@B, "  ");

	char @s_CLASS;
	switch Dict[I].Class of
	case cWORD: @s_CLASS = "cWORD";
	case cNAME: @s_CLASS = "cNAME";
	case cLITERAL: @s_CLASS = "cLITERAL";
	case cTYPE: @s_CLASS = "cTYPE";
	case cDATA: @s_CLASS = "cDATA";
	case cFUNC: @s_CLASS = "cFUNC";
	case cLIB: @s_CLASS = "cLIB";
	case cFILE: @s_CLASS = "cFILE";
	case cFIELD: @s_CLASS = "cFIELD";
	case cARGS: @s_CLASS = "cARGS";
	case cARG: @s_CLASS = "cARG";
	default: @s_CLASS = "<UNK>";
	end:switch

	char @s_SUB;
	switch Dict[I].Sub of
	case sNONE: @s_SUB = "sNONE";
	case sBASE_VOID: @s_SUB = "sBASE_VOID";
	case sBASE_BOOL: @s_SUB = "sBASE_BOOL";
	case sBASE_CHAR: @s_SUB = "sBASE_CHAR";
	case sBASE_SINT: @s_SUB = "sBASE_SINT";
	case sBASE_UINT: @s_SUB = "sBASE_UINT";
	case sBASE_FLOAT: @s_SUB = "sBASE_FLOAT";
	case sSTRUCT: @s_SUB = "sSTRUCT";
	case sFUNCTYPE: @s_SUB = "sFUNCTYPE";
	case sPTR: @s_SUB = "sPTR";
	case sARRAY: @s_SUB = "sARRAY";
	case sSYS: @s_SUB = "sSYS";
	case sFUNC: @s_SUB = "sFUNC";
	case sMAIN: @s_SUB = "sMAIN";
	default: @s_SUB = "<UNK>";
	end:switch

	strcat(@B, @s_CLASS);
	strcat(@B, " ");
	strcat(@B, @s_SUB);
/*	strcat(@B, ", Value = ");
	strcat(@B, @str(Dict[I].Value));*/
	strcat(@B, ", pType = ");
	strcat(@B, @str(Dict[I].pType));

	//strcat(@B, "~n");

	if @cb != NULL then
		cb(@B);
	else
		puts(@B);
		puts("~n");
	end
end

void DumpDictEntries(DumpDictEntryCallback@ cb)
	word I = 0;
	while I < nDict do
		DumpDictEntry(I, @cb);
		inc I;
	end:do
end

/*****************************************************************************/
