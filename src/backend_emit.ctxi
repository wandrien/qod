
/*
	Базовые функции для генерирования выходного файла.

*/

/*****************************************************************************/

char @strcpy2(char @Dst, @Src1, @Src2)
	str_push(@str_push(@Dst, @Src1), @Src2);
	return @Dst;
end

char @strcpy3(char @Dst, @Src1, @Src2, @Src3)
	str_push(@str_push(@str_push(@Dst, @Src1), @Src2), @Src3);
	return @Dst;
end

char @strcpy4(char @Dst, @Src1, @Src2, @Src3, @Src4)
	str_push(@str_push(@str_push(@str_push(@Dst, @Src1), @Src2), @Src3), @Src4);
	return @Dst;
end

char @strcat2(char @Dst, @Src1, @Src2)
	str_push(@str_push(@Dst[strlen(@Dst)], @Src1), @Src2);
	return @Dst;
end

char @strcat3(char @Dst, @Src1, @Src2, @Src3)
	str_push(@str_push(@str_push(@Dst[strlen(@Dst)], @Src1), @Src2), @Src3);
	return @Dst;
end

char @strcat4(char @Dst, @Src1, @Src2, @Src3, @Src4)
	str_push(@str_push(@str_push(@str_push(@Dst[strlen(@Dst)], @Src1), @Src2), @Src3), @Src4);
	return @Dst;
end

char @strcat5(char @Dst, @Src1, @Src2, @Src3, @Src4, @Src5)
	str_push(@str_push(@str_push(@str_push(@str_push(@Dst[strlen(@Dst)], @Src1), @Src2), @Src3), @Src4), @Src5);
	return @Dst;
end

char @strcat6(char @Dst, @Src1, @Src2, @Src3, @Src4, @Src5, @Src6)
	str_push(@str_push(@str_push(@str_push(@str_push(@str_push(@Dst[strlen(@Dst)], @Src1), @Src2), @Src3), @Src4), @Src5), @Src6);
	return @Dst;
end

/*****************************************************************************/

void FlushOutput()
	if write(hText, @Text, nText) != nText then
		Stop(@eWRITEERR);
	end:if

	nText=0;
end

/*****************************************************************************/

void OpenOutput(char@ FileName)
	hText = create(@FileName);
	nText = 0;
end

/*****************************************************************************/

void CloseOutput()
	if nText > 0 then
		FlushOutput();
	end:if

	close(hText);
end

/*****************************************************************************/

void StopAtNodeInternalCodegen(char @File; word Line; word P)
	CloseOutput();

	char Buff[nBUFF];
	strcpy(@Buff, @eINTERNAL_CODEGEN);
	strcat(@Buff, @File);
	strcat(@Buff, ":");
	strcat(@Buff, @str(Line));

	if P < nNODE then
		StopAt(@Node[P].SourceLocation, @Buff);
	else
		StopAt(NULL, @Buff);
	end
end

void StopInternalCodegen(char @File; word Line)
	StopAtNodeInternalCodegen(@File, Line, nNODE);
end

/*****************************************************************************/

/* Вывести в листинг символ. */
void EmitChar(char C)

	if nText > nTEXT then
		StopInternal(__FILE__, __LINE__);
	end

	if nText == nTEXT then
		FlushOutput();
	end

	Text[nText] = C;
	inc  nText;
end

/*****************************************************************************/

/* Вывести в листинг строку. */
void EmitString(char @S)
	word I = 0;
	while S[I] != #0 do
		EmitChar(S[I]);
		inc I;
	end
end

/*****************************************************************************/

/* Вывести в листинг переход на новую линию. */
void EmitNL()
	EmitString("~r~n");
end

/*****************************************************************************/

/* Вывести в листинг строку и следом переход на новую линию. */
void EmitStringNL(char @Inst)
	EmitString(@Inst);
	EmitNL();
end

/*****************************************************************************/

//word eax_is_zero = 0;

/*****************************************************************************/

/* Если Label не равно 0, выводит метку Label. Следом выводит строку Inst и опциональный комментарий Comment. */
void EmitLine(word Label; char @Inst; char @Comment)

	when @Inst == NULL:
		@Inst = "";
	when @Comment == NULL:
		@Comment = "";

	if Label != 0 then
		PHO_InvalidateRegs();
	else
		@Inst = @PHO_Optimize(@Inst);
	end:if

	when Label == 0 & Inst[0] == #0 & Comment[0] == #0:
		return;

	word C = 0;

	if Label != 0 then
		EmitChar('@'); inc C;

		char @P = @str(Label);
		word I = 0;
		while P[I] != #0 do
			EmitChar(P[I]); inc C;
			inc I;
		end:while

		EmitChar(':'); inc C;
		EmitChar(' '); inc C;
	end:if

	if Inst[0] != #0 then
		while C < 8 do
			EmitChar(' '); inc C;
		end:while
		EmitString(@Inst);
		C = C + strlen(@Inst);
	end:if

	if Comment[0] != #0 then
		while C < 40 do
			EmitChar(' '); inc C;
		end:while
		EmitString(" ; ");
		EmitString(@Comment);
	end:if

	EmitNL();
end

/*****************************************************************************/

void EmitLabel(word Label)
	when Label == 0: StopInternal(__FILE__, __LINE__);
	EmitLine(Label, "", NULL);
end

/*****************************************************************************/

void Emit(char @Inst)
	EmitLine(0, @Inst, NULL);
end

/*****************************************************************************/

SOURCELOCATION PrevSourceLocation;

void EmitWithSourceNote(char @Inst; word P)
	if P < nNODE & P > 0 & EmitSourceLineNotes != 0 then
		char Buff[nBUFF];
		SOURCELOCATION @SourceLocation = @Node[P].SourceLocation;
		if @PrevSourceLocation.FileName != @SourceLocation.FileName |
			PrevSourceLocation.Line != SourceLocation.Line then
			strcpy4(@Buff, "#line ", @SourceLocation.FileName, ":", @str(SourceLocation.Line));
			EmitLine(0, NULL, @Buff);
			PrevSourceLocation = SourceLocation;
		end:if
	end:if
	EmitLine(0, @Inst, NULL);
end

/*****************************************************************************/

char EmitTmpBuff[1024];

void EmitJumpToLabel(word Label)
	Emit(@strcpy2(@EmitTmpBuff, "jmp     @", @str(Label)));
end

void EmitBranchToLabel(char @Condition; word Label)
	Emit(@strcpy4(@EmitTmpBuff, "j", @Condition, "     @", @str(Label)));
end

/*****************************************************************************/

