
/*
	Вспомогательные функции для генерирования в листинг названий регистров, меток и т.п.
*/

/*****************************************************************************/

define RegNone 0
define RegA    1
define RegB    2
define RegC    3
define RegD    4

/*****************************************************************************/

word NativeRegSize = 4;

bool IsNativeOperandSize(word Size)
	word S = NativeRegSize;
	when Size > NativeRegSize:
		return false;
	do
		when S == 0:
			return false;
		when S == Size:
			return true;
		S = S / 2;
	end:do
end

/*****************************************************************************/

/*
	Помещает в Buff обозначение регистра Reg в режиме RegMode
	RegMode:
		1 - 8 бит
		2 - 16 бит
		4 - 32 бита

	Если @Buff == NULL,
		возвращает указатель на статическую строку с именем регистра.
*/
char @CodeReg(char @Buff; word Reg; word RegMode)

	char @R = NULL;

	switch Reg of
	case RegA:
		switch RegMode of
			case 1: @R = " AL";
			case 2: @R = " AX";
			case 4: @R = "EAX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegB:
		switch RegMode of
			case 1: @R = " BL";
			case 2: @R = " BX";
			case 4: @R = "EBX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegC:
		switch RegMode of
			case 1: @R = " CL";
			case 2: @R = " CX";
			case 4: @R = "ECX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	case RegD:
		switch RegMode of
			case 1: @R = " DL";
			case 2: @R = " DX";
			case 4: @R = "EDX";
			default: StopInternalCodegen(__FILE__, __LINE__);
		end:switch
	default: StopInternalCodegen(__FILE__, __LINE__);
	end:switch

	if @Buff != NULL then
		strcat(@Buff, @R);
		return @Buff;
	end:if

	return @R;

end

/*****************************************************************************/

/* Помещает в Buff обозначение указанной метки. */
char @CodeLabel(char @Buff; word Label)

	strcat(@Buff, " @");
	strcat(@Buff, @str(Dict[Label].Label));
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff обозначения регистра и преформатированного операнда. */
char @CodeRegFmt(char @Buff; word Reg1; word RegMode1; char @Fmt2)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	strcat(@Buff, @Fmt2);
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff обозначения 2-х регистров. */
char @CodeRegReg(char @Buff; word Reg1; word RegMode1; word Reg2; word RegMode2)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	CodeReg(@Buff, Reg2, RegMode2);
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff обозначения регистра и константного значения. */
char @CodeRegConst(char @Buff; word Reg1; word RegMode1; word Value)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	strcat(@Buff, @str(Value));
	return @Buff;

end

/*****************************************************************************/
/* Помещает в Buff код для операции и добавляет отступ. */
char @CodeCmd(char @Buff; char @Cmd)

	word prefix_len = strlen(@Buff);
	word cmd_len = strlen(@Cmd);

	memcpy(@Buff[prefix_len], @Cmd, cmd_len);

	while cmd_len < 8 do
		Buff[prefix_len + cmd_len] = ' ';
		inc cmd_len;
	end

	Buff[prefix_len + cmd_len] = #0;

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и преворматированного правого операнда. */
char @CodeCmdRegFmt(char @Buff; char @Cmd; word Reg1; word RegMode1; char @Fmt2)
	CodeCmd(@Buff, @Cmd);
	CodeRegFmt(@Buff, Reg1, RegMode1, @Fmt2);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и и регистра. */
char @CodeCmdRegReg(char @Buff; char @Cmd; word Reg1; word RegMode1; word Reg2; word RegMode2)
	CodeCmd(@Buff, @Cmd);
	CodeRegReg(@Buff, Reg1, RegMode1, Reg2, RegMode2);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и константы. */
char @CodeCmdRegConst(char @Buff; char @Cmd; word Reg; word RegMode; word Value)
	CodeCmd(@Buff, @Cmd);
	CodeRegConst(@Buff, Reg, RegMode, Value);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции с регистром. */
char @CodeCmdReg(char @Buff; char @Cmd; word Reg; word RegMode)
	CodeCmd(@Buff, @Cmd);
	CodeReg(@Buff, Reg, RegMode);
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код загрузки константы в регистр. */
char @CodeLoadConstant(char @Buff; word Reg; word RegMode; word Value)
	select
	case Value == 0:
		CodeCmdRegReg(@Buff, "xor", Reg, RegMode, Reg, RegMode);
	default:
		CodeCmdRegConst(@Buff, "mov", Reg, RegMode, Value);
	end
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код загрузки метки в регистр. */
char @CodeLoadLabel(char @Buff; word Reg; word Label)

	strcat(@Buff, "mov     ");
	CodeReg(@Buff, Reg, 4);
	strcat(@Buff, ",");
	CodeLabel(@Buff, Label);

	return @Buff;
end

/*****************************************************************************/

void CodeData_FIELD(word @P1, @pType, @ID, @Ofs)

	word F = Node[P1].Value;

	when Dict[F].Class != cFIELD:
		StopInternalCodegen(__FILE__, __LINE__);

	pType = Dict[F].pType;
	if ID != iLOCAL then
		Ofs = Ofs + Dict[F].Label;
	else
		Ofs = Ofs - Dict[F].Label;
	end
end

/*****************************************************************************/

/*

iDATA:    [@@DATA + IX + offset]
iPARM:    [EBP    + IX + offset]
iLOCAL:   [EBP    + IX - offset]
iREF:     [         IX + offset]

*/

char @CodeDataIX_offset(char @Buff; word Size; word ID; word IX; word offset)

	char@ SizeMarker = "";
	char@ Prefix = "";

	char@ Plus_RX = "";
	char@ RX = "";

	char@ PlusOffset = "+";

	select
	case Size == 0:
		@SizeMarker = "";
	case Size == 1:
		@SizeMarker = "byte  ";
	case Size == 2:
		@SizeMarker = "word  ";
	case Size == 4:
		@SizeMarker = "dword ";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	if IX != RegNone then
		@Plus_RX = "+";
		@RX = @CodeReg(NULL, IX, 4);
	end

	select
	case ID==iDATA:
		@Prefix = "[@@DATA";
	case ID==iPARM:
		@Prefix = "[EBP";
	case ID==iLOCAL:
		@Prefix = "[EBP";
		@PlusOffset = "-";
	case ID==iREF:
		when IX == RegNone:
			StopInternalCodegen(__FILE__, __LINE__);
		@Prefix = "[";
		@Plus_RX = "";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	strcat7(@Buff, @SizeMarker, @Prefix, @Plus_RX, @RX, @PlusOffset, @str(offset), "]");

	return @Buff;
end

/*****************************************************************************/

char @CodeMemRef_Reg_Mult_Reg_Offset(char @Buff; word Size; word Reg1; word Reg2; word RegMode; word Mult; int Offset)

	char@ SizeMarker = "";
	select
	case Size == 0:
		@SizeMarker = "";
	case Size == 1:
		@SizeMarker = "byte  ";
	case Size == 2:
		@SizeMarker = "word  ";
	case Size == 4:
		@SizeMarker = "dword ";
	default:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	strcat3(@Buff, @SizeMarker, "[", @CodeReg(NULL, Reg1, RegMode));

	if Mult > 1 then
		strcat2(@Buff, "*", @str(Mult));
	end:if

	if Reg2 != RegNone then
		strcat2(@Buff, "+", @CodeReg(NULL, Reg2, RegMode));
	end:if

	select
	case Offset > 0:
		strcat2(@Buff, "+", @str(Offset));
	case Offset < 0:
		strcat2(@Buff, "-", @str(-Offset));
	end:select

	strcat(@Buff, "]");

	return @Buff;
end

/*****************************************************************************/

void Emit_IMUL_Reg_Const(word Reg; word RegMode; word Value)
	char Buff[nBUFF];
	Buff[0] = #0;

	select
	case Value==2:
		CodeCmdRegReg(@Buff, "add", Reg, RegMode, Reg, RegMode);
	case Value==4:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 2);
	case Value==8:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 3);
	case Value==16:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 4);
	case Value==32:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 5);
	case Value==64:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 6);
	case Value==128:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 7);
	case Value==256:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 8);
	case Value==512:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 9);
	case Value>1:
		CodeCmdRegConst(@Buff, "imul", Reg, RegMode, Value);
	case Value<1:
		StopInternalCodegen(__FILE__, __LINE__);
	end:select

	Emit(@Buff);
end


/*****************************************************************************/

void Emit_Load_Constant(word Reg; word RegMode; word Value)
	char Buff[nBUFF];
	Buff[0] = #0;
	Emit(@CodeLoadConstant(@Buff, Reg, RegMode, Value));
end

/*****************************************************************************/

/** Returns nonzero if INC/DEC is preferred over ADD/SUB for the given register and the compilation options.
  Returns 1 if a single INC/DEC is preferred over <ADD/SUB reg, 1>.
  Returns 2 if a couple of INC/DEC is preferred over <ADD/SUB reg, 2>.
*/
word PreferIncDec(word Reg; word RegMode)
	/* <INC AL> and <ADD AL, 1> have the same size */
	when Reg == RegA & RegMode == 1:
		return 0;

	if EmitShortCode != 0 then /* We don't care about the speed */
		word x86CodeMode = 4; /* FIXME: 4 for 32-bit code and 2 for 16-bit code */
		when RegMode == x86CodeMode:
			/* <ADD EAX, 1> takes 3 bytes and <INC EAX> takes just 1. So 2 INCs are okay, */
			return 2;
		return 1;
	end:if

	when SlowIncDec != 0: /* P4 not happy about INC/DEC. */
		/* Details: https://github.com/dotnet/runtime/issues/7697 */
		return 0;

	/* INC/DEC seems to be ok, so use it, but we aren't crazy enoght about the code size to use double INC/DEC. */
	return 1;
end

/*****************************************************************************/

