
/*
	Анализатор выражений.
*/

/*****************************************************************************/

/* Парсинг строки в целое число по указанному основанию. */
word val2(char @Str; word Base)
	if Str[0] = #0 then
		Stop(@eMALFORMEDINT);
	end

	if Base < 2 |  Base > 16 then
		Stop(@eINVALIDBASE);
	end

	word i = 0;

	word Value = 0;
	while Str[i] != #0 do

		while Str[i] = '_' do
			inc i;
		end

		word Digit;
		word ch = word(Str[i]);

		select
		case ch >= word('0') & ch <= word('9'):
			Digit = ch - word('0');
		case ch >= word('A') & ch <= word('F'):
			Digit = ch - word('A') + 10;
		case ch >= word('a') & ch <= word('f'):
			Digit = ch - word('a') + 10;
		default:
			Stop(@eWRONGCHAR);
		end:select

		/* TODO: детектить переполнение. */

		Value = Value * Base + Digit;

		inc i;
	end:while

	return Value;
end

/*****************************************************************************/

/* Парсинг строки в число. */
word val(char @Buff)
	word  Base;
	word  P;

	word k = str_find_chars(@Buff, "$");
	select
	/* Префиксы 0x - шестнадцатиричное. */
	case str_has_prefix(@Buff, "0x"):
		Base = 16;
		P    = 2;
	/* Символ $ не найден - десятичное. */
	case Buff[k] = #0:
		Base = 10;
		P    = 0;
	/* Символ $ в начале строки - шестнадцатиричное. */
	case k = 0:
		Warn(@wDEPRECATED);
		Base = 16;
		P    = 1;
	/* Символ $ в середине строки - слева от него основание в десятичном виде, справа - само число. */
	default:
		Buff[k] = #0;
		Base = val2(@Buff, 10);
		P    = k + 1;
		Buff[k] = '$';
	end:select

	return val2(@Buff[P], Base);
end

/*****************************************************************************/

word Tabl(char @Buff)
	word nIndx = 0;
	if strcmp(@Buff,"[")=0 then
		word P = _Expr(PRIO_ZERO, @Scan(@Buff));

		when Node[P].ID!=iWORD:
			Stop(@eTYPE);

		nIndx = NodeGetImmediateValue(P);

		when strcmp(@Buff,"]")!=0:
			Stop(@eBRACKETEXP);
	    Scan(@Buff);
	end:if

	return nIndx;
end

word Tabl_(char @Buff; word T)
	word S = Tabl(@Buff);
	if S > 0 then
		return T_Array(T, S);
	end:if
	return T;
end

/*****************************************************************************/

/* Читает строковой литерал и создаёт синтаксический узел для него. */

word StringNode()
	word D = DictAlloc();
	Dict[D].Class = cLITERAL;
	Dict[D].RO = ROStrings;
	DictSetName(D, "");
	ScanString(D);

	word P = Peek();
	Node[P].ID    = iSTRING;
	NodeSetDict(P, D);

	return P;
end

/*****************************************************************************/

/* Парсит последовательность операций разыменования указателя, возвращает количество операций. */

word ReadPtrs(char @Buff)
	word nPtr=0;
	while strcmp(@Buff,"@")=0 do
		inc nPtr;
		Scan(@Buff);
	end
	return nPtr;
end

/*****************************************************************************/

void FuncArgs(char @Buff; word pFunc)
	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, pFunc);

	Scan(@Buff);
	while strcmp(@Buff,")")!=0 do
		word pType = Find(@Buff);
		when pType >= nDICT | Dict[pType].Class != cTYPE:
			Stop(@eTYPEEXP);

		do
			Scan(@Buff);
			word  nPtr=ReadPtrs(@Buff);

			when pType=st_void & nPtr<1:
				Stop(@eNOVOID);
			when Dict[pType].Sub=sFUNCTYPE & nPtr<1:
				Stop(@eNOVAL);

			word pARG = FindInNamespace(@Buff, pARGS);
			when pARG < nDICT:
				Stop(@eDUPLICATE);

			pARG = DictAlloc();
			DictSetName(pARG, @Buff);
			Dict[pARG].Class = cARG;
			Dict[pARG].pType = T_nPtrTo(nPtr, pType);
			DictAddToNamespace(pARG, pARGS);

			when strcmp(@Scan(@Buff),",")!=0:
				exit;
		end

		if strcmp(@Buff,")")!=0 then
			when strcmp(@Buff,";")!=0:
				Stop(@eSEMICOLONEXP);
			when strcmp(@Scan(@Buff),")")=0:
				Stop(@eTYPEEXP);
		end

	end:while

end

/*****************************************************************************/

include "frontend_syn_cte.ctxi"
include "frontend_syn_cast.ctxi"

/*****************************************************************************/

/*
	Вычисление логического НЕ преобразованием исходной форумулы.

	FIXME: Эта функция должна быть частью подсистемы CTE.
*/

word Not(word P)
	switch Node[P].ID of
	case iOR:   Node[P].ID = iAND; Not(Node[P].pLeft); Not(Node[P].pRight);
	case iAND:  Node[P].ID = iOR;  Not(Node[P].pLeft); Not(Node[P].pRight);
	case iXOR:  Node[P].ID = iEQV;
	case iEQV:  Node[P].ID = iXOR;
	case iLT:   Node[P].ID = iGE;
	case iLE:   Node[P].ID = iGT;
	case iEQ:   Node[P].ID = iNE;
	case iNE:   Node[P].ID = iEQ;
	case iGE:   Node[P].ID = iLT;
	case iGT:   Node[P].ID = iLE;
	default:
		word P2 = Peek();
		Node[P2].ID    = iNOT;
		Node[P2].pLeft = P;
		return P2;
	end:switch

	return P;
end

/*****************************************************************************/

void ParseCallArgs(word pFunc; word @P7; char @Buff)
	word pARGS = FindInNamespace("args", pFunc);
	when pARGS >= nDICT:
		StopInternal();
	word pARG = Dict[pARGS].pFirst;

	while pARG < nDICT do
		word P8=Peek();
		Node[P8].ID   =iPUSH;
		Node[P8].pLeft=_Expr(PRIO_ZERO, @Buff);

		ImplicitCast(Dict[pARG].pType, @Node[P8].pLeft);

		P7 = P8;
		@P7=@Node[P8].pRight;

		pARG = Dict[pARG].pNext;

		if  pARG < nDICT then
			when strcmp(@Buff,",")!=0:
				Stop(@eCOMMAEXP);
			Scan(@Buff);
		end:if

	end:while

	when strcmp(@Buff,")")!=0:
		Stop(@eBRACKETEXP);

end

/*****************************************************************************/

word Primary(word Prty; char @Buff)

	if isdigit(Buff)!=0 then /* Число. */
		word P1 = Peek();
		Node[P1].ID    = iWORD;
		Node[P1].Value = val (@Buff);
		Node[P1].pType = st_word;
		Scan(@Buff);
		return P1;
	end

	word pType;
	word nPtr;

	word Flag=0;
	word Call=0;
	word P1;

	nPtr = ReadPtrs(@Buff);

	if Flag=0 then /* Это строка? */
		if strcmp(@Buff,"~"")=0 then
			if nPtr>0 then
				Stop(@eSTRING);
			end

			P1    = StringNode();
			nPtr  = 1;
			pType = st_char;
			Flag  = 1;
		end:if
	end:if

	if Flag=0 then /* Это локальная переменная? */
		word I = ResolveLocal(@Buff);
		if I < nLOCAL then
			P1=Peek();
			Node[P1].ID    =iLOCAL;
			Node[P1].Value = I;
			pType          = Local[I].pType;
			Flag           = 1;
		end:if
	end:if

	if Flag=0 then /* Это параметр функции? */
		word I = ResolveParm(@Buff);
		if I < nDICT then
			P1=Peek();
			Node[P1].ID    =iPARM;
			Node[P1].Value = I;
			pType          = Dict[I].pType;
			Flag           = 1;
		end:if
	end:if

	if Flag=0 then /* Значит это глобальное имя. */
		word I=Find(@Buff);
		if I>=nDict then
			Stop(@eUNDECLARED);
		end:if

		select
		case Dict[I].Class=cLITERAL: /* Именованный литерал? */
			P1=Peek();
			select
			case Dict[I].pType=st_word:
				Node[P1].ID    =iWORD;
				Node[P1].Value = Dict[I].Value;
				pType          = Dict[I].pType;

			case Dict[I].pType=st_int:
				Node[P1].ID    =iINT;
				Node[P1].Value = Dict[I].Value;
				pType          = Dict[I].pType;

			case Dict[I].pType=st_char:
				Node[P1].ID    =iCHAR;
				Node[P1].Value = Dict[I].Value;
				pType          = Dict[I].pType;

			case Dict[I].pType=T_PtrTo(st_char):
				Node[P1].ID    =iSTRING;
				if ROStrings != 0 then
					Node[P1].Value = I;
				else
					word NewLiteral = DictDupLiteral(I);
					Dict[NewLiteral].RO = 0;
					Node[P1].Value = NewLiteral;
				end
				pType          = st_char;
			default:
				StopInternal();
			end:select

			//pType          = Dict[I].pType;

		case Dict[I].Class=cDATA | Dict[I].Class=cFUNC: /* Глобальная переменная/функция? */
			P1=Peek();
			Node[P1].ID    =iDATA;
			Node[P1].Value = I;
			pType          = Dict[I].pType;

			if Dict[I].Class=cFUNC then
				if strcmp(@Scan(@Buff),"(")=0 then
					word P2=Peek();
					Node[P1].pLeft = P2;
					Node[P2].ID    =iCALL;
					Node[P2].Value = I;
					Call           = 1;

					Scan(@Buff);

					ParseCallArgs(I, @Node[P2].pLeft, @Buff);
				else
					if Prty >= PRIO_INC | nPtr!=1 then
						Stop(@eNOADDR);
					end

					Node[P1].ID    =iFUNC;
					Node[P1].Value = I;
					Node[P1].pType = T_PtrTo(T_FuncTypeForFunction(I));

					return P1;
				end:if
			end:if

		case Dict[I].Class=cTYPE: /* Тип данных? */
			if Prty < PRIO_LVALUE then
				if strcmp(@Scan(@Buff),"(")!=0 then
					Stop(@eBRACKETEXP);
				end:if

				P1 = _Expr(PRIO_ZERO, @Scan(@Buff));

				if strcmp(@Buff,")")!=0 then
					Stop(@eBRACKETEXP);
				end:if

				if CanExplicitCast(I, Node[P1].pType) = 0 then
					Stop(@eTYPE);
				end:if

				AddCast(I, @P1);
				pType = Node[P1].pType;
			else
				if nPtr>0 then
					Stop(@eUNDECLARED);
				end:if

				return nNODE;
			end:if
		default:
			Stop(@eUNDECLARED);
		end:select
	end:if


	/*
		В этом месте имеем следующие поля:
		P1 - (логически) дочерний узел
		pType, nPtr1 - тип дочернего узла: собственно тип, количество уровней @-косвенности
		nPtr - количество операций @ перед узлом.
	*/

	word @P2=@Node[P1].pLeft;
	if Node[P1].pLeft<nNODE then
		@P2=@Node[Node[P1].pLeft].pRight;
	end:if

	do
		Scan(@Buff);
		if strcmp(@Buff,"[")==0 & T_IsArray(pType) != 0 then /* Индексация массива. */
			word P3=Peek();
			Node[P3].ID   =iINDEX;
			Node[P3].Value= T_ArrayGetSize(pType);
			Node[P3].pLeft= _Expr(PRIO_ZERO, @Scan(@Buff));
			pType = T_ArrayDeref(pType);

			if strcmp(@Buff,"]")!=0 then
				Stop(@eBRACKETEXP);
			end:if

			ImplicitCast(st_word, @Node[P3].pLeft);

			P2 = P3;
			@P2=@Node[P3].pRight;

			Scan(@Buff);
		end:if

		while strcmp(@Buff,"[")=0 do /* Индексация указателя. */
			if T_IsPtr(pType) = 0 then
				Stop(@eNOADDR);
			end:if

			word P3=Peek();
			Node[P3].ID   =iADDR;
			Node[P3].pLeft= _Expr(PRIO_ZERO, @Scan(@Buff));

			if strcmp(@Buff,"]")!=0 then
				Stop(@eBRACKETEXP);
			end:if

			ImplicitCast(st_word, @Node[P3].pLeft);

			P2 = P3;
			@P2=@Node[P3].pRight;

			pType = T_DerefPtr(pType);
			Call=   0;

			Scan(@Buff);
		end:while

		select
		case strcmp(@Buff,"(")=0: /* Вызов функтора. */

			while T_IsPtr(pType) = 1 do
				word P3=Peek();
				Node[P3].ID   =iADDR;

				P2 = P3;
				@P2=@Node[P3].pRight;

				pType = T_DerefPtr(pType);
				Call=   0;
			end:while

			if Dict[pType].Sub!=sFUNCTYPE then
				Stop(@eHEADEREXP);
			end

			word  P3        = Peek();
			Node [P3].ID    =iLPTR;
			P2              = P3;

			word  P4        = Peek();
			Node [P4].ID    =iDATA;

			word  P5        = Peek();
			Node [P5].ID    =iCALL2;
			Node [P5].Value =pType;

			Node [P4].pLeft = P5;

			word  P6        = Peek();
			Node [P6].ID    =iEMPTY;
			Node [P6].pLeft = P1;

			Node [P5].pLeft = P6;

			Scan(@Buff);

			ParseCallArgs(pType, @Node[P6].pRight, @Buff);

			word pType0     =pType;
			pType           = Dict[pType0].pType;
			Call            = 1;

			P1 = P4;
			@P2=@Node[P5].pRight;

		case strcmp(@Buff,".")=0: /* Обращение к полю структуры. */

			while T_IsPtr(pType) = 1 do
				word P3=Peek();
				Node[P3].ID   =iADDR;

				P2 = P3;
				@P2=@Node[P3].pRight;

				pType = T_DerefPtr(pType);
				Call=   0;
			end:while

			if Dict[pType].Sub!=sSTRUCT then
				Stop(@eSTRUCTEXP);
			end:if

			if Call!=0 then
				Stop(@eNOTAVAIL);
			end:if

			Scan(@Buff);

			word F = FindInNamespace(@Buff, pType);
			when F >= nDICT:
				Stop(@eUNDECLARED);
			when Dict[F].Class != cFIELD:
				StopInternal();

			word P3=Peek();
			Node[P3].ID   =iFIELD;
			Node[P3].Value= F;
			pType         = Dict[F].pType;
			Call          = 0;

			P2 = P3;
			@P2=@Node[P3].pRight;

		default:
			exit;
		end:select
	end:do

	if Prty >= PRIO_LVALUE & strcmp(@Buff,"=")!=0 & strcmp(@Buff,":=")!=0 then
		if Call=0 | nPtr>0 then
			Stop(@eASSIGNEXP);
		end:if

		while T_IsPtr(pType) = 1 do
			pType = T_DerefPtr(pType);
		end:while
	end:if

	word pTypeDeref = pType;
	word nPtr1 = 0;
	while T_IsPtr(pTypeDeref) = 1 do
		inc nPtr1;
		pTypeDeref = T_DerefPtr(pTypeDeref);
	end:while

	word P4=nNODE;
	if Prty < PRIO_INC then
		if nPtr>nPtr1+1 then
			Stop(@eNOADDR);
		end:if

		P4=Peek();
		if nPtr>nPtr1 then
			Node[P4].ID=iLPTR;
		else
			Node[P4].ID=iLOAD;
		end:if
	else
		if (nPtr>nPtr1)
		 | (Node[P1].ID=iCHAR)
		 | (Node[P1].ID=iWORD)
		 | (Node[P1].ID=iSTRING)
		 | (nPtr>=nPtr1 & Call!=0 & (strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0)) then
			Stop(@eNOADDR);
		end:if
	end:if

	while nPtr1>nPtr do
		word P3=Peek();
		Node[P3].ID   =iADDR;

		P2 = P3;
		@P2=@Node[P3].pRight;

		dec nPtr1;
	end:while

	P2  =P4;

	Node[P1].pType = T_nPtrTo(nPtr, pTypeDeref);

	return P1;

end

/*****************************************************************************/

void Cast2(word @P1, @pType; word @P2, @pType2; word @ID; char @Buff)

	if T_IsPtr(pType) = 0 & T_IsPtr(pType2) = 0 then /* Преобразование целочисленных типов к одному типу. */
		select

		case pType = pType2:
			null;

		case pType=st_byte & pType2=st_word:
			AddCast(pType2, @Node[P2].pLeft);
			pType=pType2;

		case pType=st_byte & pType2=st_int:
			AddCast(pType2, @Node[P2].pLeft);
			pType=pType2;

		case pType=st_word & pType2=st_byte:
			AddCast(pType, @Node[P2].pRight);

		case pType=st_word & pType2=st_int:
			AddCast(pType2, @Node[P2].pLeft);
			pType=pType2;

		case pType=st_int & pType2=st_byte:
			AddCast(pType, @Node[P2].pRight);

		case pType=st_int & pType2=st_word:
			AddCast(pType, @Node[P2].pRight);

		default:
			Stop(@eTYPE);
		end:select
	end:if

	when T_IsPtr(pType) != T_IsPtr(pType2): /* Типы должны быть либо оба указатели, либо оба не указатели. */
		Stop(@eTYPE);

	select
	case T_IsPtr(pType) = 1: /* Между указателями возможны только операции сравнения на равенство и неравенство. */
		if ID!=iEQ & ID!=iNE then
			Stop(@eTYPE);
		end
		pType = st_bool;

	case ID=iOR: /* операция ИЛИ возможна либо между беззнаковыми целыми, либо между булевыми значениями. */
		select
		case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_OR;
		case pType != st_bool:
			Stop(@eTYPE);
		end

	case ID=iXOR: /* Аналогично предыдущему. */
		select
		case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_XOR;
		case pType = st_bool:
			Stop(@eXORNOTIMPL);
		default:
			Stop(@eTYPE);
		end

	case ID=iAND: /* Аналогично предыдущему. */
		select
			case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_AND;
		case pType != st_bool:
			Stop(@eTYPE);
		end

	case iLT<=ID & ID<=iGT: /* Сравнения возможны только между целыми и символами (case с указателями был выше) */
		if pType!=st_char & pType!=st_byte & pType!=st_word & pType!=st_int then
			Stop(@eTYPE);
		end
		pType = st_bool;

	case iADD<=ID & ID<=iDIV:
		if pType!=st_byte & pType!=st_word & pType!=st_int then /* Арифметические операции только с целыми. */
			Stop(@eTYPE);
		end
		CTE1(@P1, @pType, @P2, @pType2, @ID);

	case ID=iMOD:
		if pType!=st_byte & pType!=st_word then
			Stop(@eTYPE);
		end
		CTE2(@P1, @pType, @P2, @pType2, @ID);

	default:
		StopInternal();
	end:select

end

/*****************************************************************************/

word Expr(word Prio; char @Buff)

	word P1;
	word O;

	O = FindOperator(@Buff, Prio, OPERATOR_UPRE);
	if O = OPERATOR_INVALID then
		P1 = Primary(Prio, @Buff);
	else
		P1 = Operator[O].Handler(nNODE, O, @Buff);
	end:if

	do
		O = FindOperator(@Buff, Prio, OPERATOR_BLEFT);
		if O = OPERATOR_INVALID then
			exit;
		end

		P1 = Operator[O].Handler(P1, O, @Buff);
	end:do

	return P1;
end

/*****************************************************************************/

word ExprBinOp(word P1; word O; char @Buff)

	if str_eq(@Buff, "=") then
		Warn(@wDEPRECATED);
	end:if

	word P2 = Peek();
	word ID = Operator[O].ID;
	Node[P2].ID = ID;

	word pType;

	if P1 >= nNODE then
		StopInternal();
	else
		pType = Node[P1].pType;
		Node[P2].pLeft  = P1;
		Node[P2].pRight = _Expr(Operator[O].Prio, @Scan(@Buff));
		word pType2 = Node[Node[P2].pRight].pType;
		Cast2(@P1, @pType, @P2, @pType2, @ID, @Buff);
	end:if

	Node[P2].pType = pType;

	return P2;
end

/*****************************************************************************/

word ExprParentheses(word P1; word O;  char @Buff)

	word P2 = _Expr(PRIO_ZERO, @Scan(@Buff));
	if strcmp(@Buff,")")!=0 then
		Stop(@eBRACKETEXP);
	end
	Scan(@Buff);
	return P2;
end

/*****************************************************************************/

word ExprConstExpr(word P1; word O;  char @Buff)
	Scan(@Buff);
	if strcmp(@Buff,"(") != 0 then
		Stop(@eBRACKETEXP);
	end

	word P2 = ExprParentheses(P1, O, @Buff);

	switch Node[P2].ID of
	case iCHAR, iWORD, iINT:
		null;
	default:
		Stop(@eNOTACONSTEXPR);
	end

	return P2;

end

/*****************************************************************************/

word ExprLitChar(word P_; word O; char @Buff)

	word P1=Peek();

	select
	case strcmp(@Buff,"#")=0: /* Символ в #-виде. */
		word N=val(@Scan(@Buff));
		if   N>255 then
			Stop(@eOVERFLOW);
		end

		Node[P1].ID    =iCHAR;
		Node[P1].Value = N;
		Node[P1].pType = st_char;

	case strcmp(@Buff,"'")=0: /* Символ. */
		Node[P1].ID    =iCHAR;
		Node[P1].Value = word(ScanChar());
		Node[P1].pType = st_char;

		if Read()!='~'' then
			Stop(@eQUOTEXP);
		end
		Next();
	default:
		StopInternal();
	end:select

	Scan(@Buff);

	return P1;
end

word ExprLitNULL(word P_; word O; char @Buff)
	word P1=Peek();
	Node[P1].ID = iNULL;
	Node[P1].pType = T_PtrTo(st_void);
	Scan(@Buff);
	return P1;
end

word ExprLitFALSE(word P_; word O; char @Buff)
	word P1 = Peek();
	Node[P1].ID    = iBOOL;
	Node[P1].Value = 0;
	Node[P1].pType = st_bool;
	Scan(@Buff);
	return P1;
end

word ExprLitTRUE(word P_; word O; char @Buff)
	word P1 = Peek();
	Node[P1].ID    = iBOOL;
	Node[P1].Value = 1;
	Node[P1].pType = st_bool;
	Scan(@Buff);
	return P1;
end

/*****************************************************************************/

word ExprNOT(word P_; word O; char @Buff)

	word P1;

	word P2=_Expr(Operator[O].Prio, @Scan(@Buff));
	word pType = Node[P2].pType;

	select
	case pType=st_byte | pType=st_word:
		P1=Peek();
		Node[P1].ID    =iBIT_NOT;
		Node[P1].pLeft = P2;

	case pType = st_bool:
		P1 = Not(P2);

	default:
		Stop(@eTYPE);
	end:select

	Node[P1].pType = pType;

	return P1;
end

/*****************************************************************************/

word ExprNEG(word P_; word O; char @Buff)

	word P1;

	P1=Peek();
	Node[P1].ID    = iNEG;
	Node[P1].pLeft = _Expr(Operator[O].Prio, @Scan(@Buff));
	word pType = Node[Node[P1].pLeft].pType;

	select
	case Node[Node[P1].pLeft].ID=iWORD:
		if Node[Node[P1].pLeft].Value>0x80000000 then
			Stop(@eCALCERR);
		end

		if Node[Node[P1].pLeft].Value!=0 then
			Node[P1].ID   =iINT;
			Node[P1].Value=-Node[Node[P1].pLeft].Value;
			pType         = st_int;
		else
			Node[P1].ID   =iWORD;
			Node[P1].Value= 0;
			pType         = st_word;
		end:if

	case Node[P1].ID=iINT:
		Node[P1].ID   =iWORD;
		Node[P1].Value=-Node[Node[P1].pLeft].Value;
		pType         = st_word;

	default:
		ImplicitCast(st_int, @Node[P1].pLeft);
		pType         = st_int;
	end:select

	Node[P1].pType = pType;

	return P1;

end

/*****************************************************************************/

void RegisterOperators()

	RegisterOperator("|"    , PRIO_BOOL , OPERATOR_BLEFT, iOR , @ExprBinOp);
	RegisterOperator("^"    , PRIO_BOOL , OPERATOR_BLEFT, iXOR, @ExprBinOp);
	RegisterOperator("&"    , PRIO_BOOL , OPERATOR_BLEFT, iAND, @ExprBinOp);

	RegisterOperator("<"    , PRIO_COMP , OPERATOR_BLEFT, iLT , @ExprBinOp);
	RegisterOperator("<="   , PRIO_COMP , OPERATOR_BLEFT, iLE , @ExprBinOp);
	RegisterOperator("="    , PRIO_COMP , OPERATOR_BLEFT, iEQ , @ExprBinOp);
	RegisterOperator("=="   , PRIO_COMP , OPERATOR_BLEFT, iEQ , @ExprBinOp);
	RegisterOperator("!="   , PRIO_COMP , OPERATOR_BLEFT, iNE , @ExprBinOp);
	RegisterOperator(">"    , PRIO_COMP , OPERATOR_BLEFT, iGT , @ExprBinOp);
	RegisterOperator(">="   , PRIO_COMP , OPERATOR_BLEFT, iGE , @ExprBinOp);

	RegisterOperator("+"    , PRIO_ADD  , OPERATOR_BLEFT, iADD, @ExprBinOp);
	RegisterOperator("-"    , PRIO_ADD  , OPERATOR_BLEFT, iSUB, @ExprBinOp);

	RegisterOperator("*"    , PRIO_MUL  , OPERATOR_BLEFT, iMUL, @ExprBinOp);
	RegisterOperator("/"    , PRIO_MUL  , OPERATOR_BLEFT, iDIV, @ExprBinOp);
	RegisterOperator("%"    , PRIO_MUL  , OPERATOR_BLEFT, iMOD, @ExprBinOp);

	RegisterOperator("-"    , PRIO_NEG  , OPERATOR_UPRE , iNEG, @ExprNEG);
	RegisterOperator("!"    , PRIO_NEG  , OPERATOR_UPRE , iNOT, @ExprNOT);

	RegisterOperator("("    , PRIO_EXPR , OPERATOR_UPRE , 0   , @ExprParentheses);
	RegisterOperator("const_expr", PRIO_CONSTEXPR , OPERATOR_UPRE , 0   , @ExprConstExpr);

	RegisterOperator("'"    , PRIO_LITER, OPERATOR_UPRE , iCHAR, @ExprLitChar);
	RegisterOperator("#"    , PRIO_LITER, OPERATOR_UPRE , iCHAR, @ExprLitChar);
	RegisterOperator("NULL" , PRIO_LITER, OPERATOR_UPRE , iNULL, @ExprLitNULL);
	RegisterOperator("false", PRIO_LITER, OPERATOR_UPRE , iBOOL, @ExprLitFALSE);
	RegisterOperator("true" , PRIO_LITER, OPERATOR_UPRE , iBOOL, @ExprLitTRUE);
end

/*****************************************************************************/

