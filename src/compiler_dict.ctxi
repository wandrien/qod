
/*****************************************************************************/

DICT     Dict [nDICT]; // Таблица имен
word    nDict;

/*****************************************************************************/

/* Индексы встроенных типов данных. */

word st_void;
word st_char;
word st_byte;
word st_word;
word st_int;
word st_bool;

/*****************************************************************************/

/*
	Проверяет достаточность памяти таблице Dict для выделения одного элемента.
	TODO: при нехватке памяти, перераспределять динамически.
*/
void DictMemCheck()
	when nDict >= nDICT:
		StopMemory();
end

/*****************************************************************************/

void DictSetName(word D; char@ Name)

	when D >= nDict:
		StopInternal(__FILE__, __LINE__);

	Dict[D].Name2    = SaveString0(@Name);
	Dict[D].NameHash = str_hash(@Name);
end

/*****************************************************************************/

char @DictGetName(word D)

	when D >= nDict:
		StopInternal(__FILE__, __LINE__);

	return @Char[Dict[D].Name2];
end

/*****************************************************************************/

/* Выделить запись в таблице глобальных имён и вернуть её индекс.  */
word DictAlloc()

	DictMemCheck();

	word r = nDict;
	inc nDict;

	Dict[r].Used = 0;
	Dict[r].pType = nDICT;
	Dict[r].tCachedPtrToMe = nDICT;
	Dict[r].tCachedFuncTypeOfMe = nDICT;
	Dict[r].pNamespace = nDICT;
	Dict[r].pNext = nDICT;
	Dict[r].pFirst = nDICT;
	Dict[r].pLast = nDICT;

	return r;
end

/*****************************************************************************/

/*
	Поиск объекта в заданном пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word FindInNamespace(char @Name; word pNamespace)
	when pNamespace >= nDict:
		StopInternal(__FILE__, __LINE__);

	word hash = str_hash(@Name);
	word P = Dict[pNamespace].pFirst;
	while P < nDict do
		when Dict[P].pNamespace != pNamespace:
			StopInternal(__FILE__, __LINE__);
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class != cFILE then
			while Dict[P].Class = cNAME do
				P = Dict[P].pType;
				when P >= nDict:
					StopInternal(__FILE__, __LINE__);
			end
			exit;
		end
		P = Dict[P].pNext;
	end

	return P;
end

/*****************************************************************************/

/*
	Поиск объекта в корневом пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word Find(char @Name)
	word hash = str_hash(@Name);
	word P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class != cFILE
		&  Dict[P].pNamespace = nDICT then
			while Dict[P].Class = cNAME do
				P = Dict[P].pType;
				when P >= nDict:
					StopInternal(__FILE__, __LINE__);
			end
			exit;
		end
		inc P;
	end

	return P;
end

/*****************************************************************************/

/*
	Поиск объекта с классом cFILE в корневом пространстве имён по имени.
*/
word Find_cFILE(char @Name)
	word hash = str_hash(@Name);
	word  P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class = cFILE
		&  Dict[P].pNamespace = nDICT then
			exit;
		end
		inc P;
	end

	return P;
end

/*****************************************************************************/

word DictAddToNamespace(word P; word pNamespace)
	when P >= nDict:
		StopInternal(__FILE__, __LINE__);
	when pNamespace >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[P].pNamespace != nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[P].pNext != nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[pNamespace].pFirst != nDICT & Dict[pNamespace].pLast = nDICT:
		StopInternal(__FILE__, __LINE__);
	when Dict[pNamespace].pFirst = nDICT & Dict[pNamespace].pLast != nDICT:
		StopInternal(__FILE__, __LINE__);

	Dict[P].pNamespace = pNamespace;
	if Dict[pNamespace].pLast < nDICT then
		Dict[Dict[pNamespace].pLast].pNext = P;
		Dict[pNamespace].pLast = P;
	else
		Dict[pNamespace].pFirst = P;
		Dict[pNamespace].pLast = P;
	end:if
end

/*****************************************************************************/

/* Регистрирует ключевое слово. */
void Word(char @Name)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cWORD;
end

/*****************************************************************************/

/* Регистрирует базовый тип. */
word Base(char @Name; word Size)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class    = cTYPE;
	Dict[p].Sub      = sBASE;
	Dict[p].TypeSize = Size;
	return p;
end

/*****************************************************************************/

word DictDupLiteral(word D1)

	when D1 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[D1].Class != cLITERAL:
		StopInternal(__FILE__, __LINE__);

	word D2 = DictAlloc();
	DictSetName(D2, "");
	Dict[D2].Class = Dict[D1].Class;
	Dict[D2].Sub   = Dict[D1].Sub;
	Dict[D2].RO    = Dict[D1].RO;
	Dict[D2].pType = Dict[D1].pType;
	Dict[D2].nLiteralSize = Dict[D1].nLiteralSize;
	Dict[D2].LiteralValue = Dict[D1].LiteralValue;

	return D2;
end

/*****************************************************************************/

word T_IsUnsigned(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T = st_byte | T = st_word:
		return 1;
	return 0;
end

word T_IsSigned(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T = st_int:
		return 1;
	return 0;
end

word T_IsInteger(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T_IsUnsigned(T) = 1 | T_IsSigned(T) = 1:
		return 1;
	return 0;
end

/*****************************************************************************/

word T_SizeOf(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);

	when Dict[T].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	when Dict[T].Sub = sARRAY:
		return Dict[T].TypeSize * T_SizeOf(Dict[T].pType);

	return Dict[T].TypeSize;
end

/*****************************************************************************/
word T_IsArray(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class == cTYPE & Dict[T].Sub == sARRAY:
		return 1;
	return 0;
end

word T_ArrayDeref(word T)
	when T_IsArray(T) = 0:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].pType;
end

word T_ArrayGetSize(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class != cTYPE | Dict[T].Sub != sARRAY:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].TypeSize;
end

word T_ArrayGetSizeOr0(word T)
	when T_IsArray(T) = 0:
		return 0;
	return T_ArrayGetSize(T);
end


word T_Array(word T; word S)
	word P = 0;
	while P < nDict do
		if Dict[P].Class = cTYPE
		 & Dict[P].Sub = sARRAY
		 & Dict[P].pType = T
		 & T_ArrayGetSize(P) = S then
			return P;
		end:if
		inc P;
	end:while

	P = DictAlloc();
	Dict[P].Class    = cTYPE;
	Dict[P].Sub      = sARRAY;
	Dict[P].pType    = T;
	Dict[P].TypeSize = S;
	return P;
end

/*****************************************************************************/

word T_IsPtr(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class = cTYPE & Dict[T].Sub = sPTR:
		return 1;
	return 0;
end

word T_IsPtrTo(word T; word T2)
	when T_IsPtr(T) = 1 & Dict[T].pType = T2:
		return 1;
	return 0;
end

word T_DerefPtr(word T)
	when T_IsPtr(T) = 0:
		StopInternal(__FILE__, __LINE__);
	return Dict[T].pType;
end

word T_PtrTo(word T)
	when T >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[T].Class != cTYPE:
		StopInternal(__FILE__, __LINE__);

	if T_IsArray(T) != 0 then
		T = T_ArrayDeref(T);
	end

	if Dict[T].tCachedPtrToMe >= nDICT then
		word PTR = DictAlloc();
		Dict[PTR].Class    = cTYPE;
		Dict[PTR].Sub      = sPTR;
		Dict[PTR].TypeSize = target_size_of_pointer;
		Dict[PTR].pType    = T;
		Dict[T].tCachedPtrToMe = PTR;
	end

	return Dict[T].tCachedPtrToMe;
end

word T_nPtrTo(word nPtr; word T)
	while nPtr > 0 do
		T = T_PtrTo(T);
		dec nPtr;
	end:while
	return T;
end

/*****************************************************************************/

/*
	Функция проверяет идентичность функциональных типов.
	Аргументами могут выступать функциональные типы, либо функции.
*/
word T_IsFuctTypesIdentical(word T1; word T2)
	when T1 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T2 >= nDict:
		StopInternal(__FILE__, __LINE__);

	when T1 = T2:
		return 1;

	when !((Dict[T1].Class = cTYPE & Dict[T1].Sub = sFUNCTYPE) | (Dict[T1].Class = cFUNC)):
		return 0;

	when !((Dict[T2].Class = cTYPE & Dict[T2].Sub = sFUNCTYPE) | (Dict[T2].Class = cFUNC)):
		return 0;

	when Dict[T1].pType != Dict[T2].pType:
		return 0;

	word pARGS1 = FindInNamespace("args", T1);
	word pARGS2 = FindInNamespace("args", T2);
	when pARGS1 >= nDICT | pARGS2 >= nDICT:
		StopInternal(__FILE__, __LINE__);

	word P1 = Dict[pARGS1].pFirst;
	word P2 = Dict[pARGS2].pFirst;
	do
		when P1 = nDICT & P2 = nDICT:
			return 1;

		when P1 = nDICT & P2 != nDICT:
			exit;
		when P1 != nDICT & P2 = nDICT:
			exit;
		when Dict[P1].pType != Dict[P2].pType:
			exit;

		P1 = Dict[P1].pNext;
		P2 = Dict[P2].pNext;
	end:do

	return 0;
end

word T_FuncTypeForFunction(word F)

	when F >= nDict:
		StopInternal(__FILE__, __LINE__);
	when Dict[F].Class != cFUNC:
		StopInternal(__FILE__, __LINE__);

	when Dict[F].tCachedFuncTypeOfMe < nDict:
		return Dict[F].tCachedFuncTypeOfMe;

	word P = 0;
	while P < nDict do
		if Dict[P].pNamespace = nDICT
		 & Dict[P].Class = cTYPE
		 & Dict[P].Sub = sFUNCTYPE
		 & strcmp(@DictGetName(P), "") = 0
		 & T_IsFuctTypesIdentical(F, P) = 1
		 then
			return P;
		end:if
		inc P;
	end:while

	P = DictAlloc();
	Dict[P].Class = cTYPE;
	Dict[P].Sub   = sFUNCTYPE;
	Dict[P].pType = Dict[F].pType;

	word F_ARGS = FindInNamespace("args", F);

	word P_ARGS = DictAlloc();
	DictSetName(P_ARGS, "args");
	Dict[P_ARGS].Class = cARGS;
	DictAddToNamespace(P_ARGS, P);

	word F_ARG = Dict[F_ARGS].pFirst;
	do
		when F_ARG = nDICT:
			exit;

		word P_ARG = DictAlloc();
		DictSetName(P_ARG, "");
		Dict[P_ARG].Class = cARG;
		Dict[P_ARG].pType = Dict[F_ARG].pType;
		DictAddToNamespace(P_ARG, P_ARGS);

		F_ARG = Dict[F_ARG].pNext;
	end:do

	Dict[F].tCachedFuncTypeOfMe = P;

	return P;
end

/*****************************************************************************/

word DefineInteger(char @Name; word Type; word Value)
	if Find(@Name) < nDict then
		StopInternal(__FILE__, __LINE__);
	end

	when T_IsInteger(Type) == 0:
		StopInternal(__FILE__, __LINE__);

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].pType = Type;
	Dict[D].LiteralValue = Value;

	return D;
end

/*****************************************************************************/

word DefineString(char @Name; char @Value)
	if Find(@Name) < nDict then
		StopInternal(__FILE__, __LINE__);
	end

	word i = strlen(@Value) + 1;

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].pType = T_PtrTo(st_char);
	Dict[D].LiteralValue = SaveString(@Value, i);
	Dict[D].nLiteralSize = i;

	return D;
end

/*****************************************************************************/

void function DumpDictEntryCallback(char @S)

void DumpDictEntry(word I; DumpDictEntryCallback@ cb)

	char B[1024];
	char @dump_prefix = "; ";
	char @s_CLASS = "<UNK>";
	char @s_SUB = "<UNK>";

	strcpy(@B, "");

	strcat(@B, @dump_prefix);
	strcat(@B, @str(I));
	strcat(@B, ": ");
	strcat(@B, @DictGetName(I));
	strcat(@B, "~n");

	strcat(@B, @dump_prefix);
	strcat(@B, "  ");


	select
	case Dict[I].Class = cWORD: @s_CLASS = "cWORD";
	case Dict[I].Class = cNAME: @s_CLASS = "cNAME";
	case Dict[I].Class = cLITERAL: @s_CLASS = "cLITERAL";
	case Dict[I].Class = cTYPE: @s_CLASS = "cTYPE";
	case Dict[I].Class = cDATA: @s_CLASS = "cDATA";
	case Dict[I].Class = cFUNC: @s_CLASS = "cFUNC";
	case Dict[I].Class = cLIB: @s_CLASS = "cLIB";
	case Dict[I].Class = cFILE: @s_CLASS = "cFILE";
	case Dict[I].Class = cFIELD: @s_CLASS = "cFIELD";
	case Dict[I].Class = cARGS: @s_CLASS = "cARGS";
	case Dict[I].Class = cARG: @s_CLASS = "cARG";
	end:select

	select
	case Dict[I].Sub = sBASE: @s_SUB = "sBASE";
	case Dict[I].Sub = sSTRUCT: @s_SUB = "sSTRUCT";
	case Dict[I].Sub = sFUNCTYPE: @s_SUB = "sFUNCTYPE";
	case Dict[I].Sub = sPTR: @s_SUB = "sPTR";
	case Dict[I].Sub = sARRAY: @s_SUB = "sARRAY";
	case Dict[I].Sub = sSYS: @s_SUB = "sSYS";
	case Dict[I].Sub = sFUNC: @s_SUB = "sFUNC";
	case Dict[I].Sub = sMAIN: @s_SUB = "sMAIN";
	end:select

/*
	switch Dict[I].Class of
	case cWORD: @s_CLASS = "cWORD";
	case cNAME: @s_CLASS = "cNAME";
	case cLITERAL: @s_CLASS = "cLITERAL";
	case cTYPE: @s_CLASS = "cTYPE";
	case cDATA: @s_CLASS = "cDATA";
	case cFUNC: @s_CLASS = "cFUNC";
	case cLIB: @s_CLASS = "cLIB";
	case cFILE: @s_CLASS = "cFILE";
	case cFIELD: @s_CLASS = "cFIELD";
	case cARGS: @s_CLASS = "cARGS";
	case cARG: @s_CLASS = "cARG";
	end:switch

	switch Dict[I].Sub of
	case sBASE: @s_SUB = "sBASE";
	case sSTRUCT: @s_SUB = "sSTRUCT";
	case sFUNCTYPE: @s_SUB = "sFUNCTYPE";
	case sPTR: @s_SUB = "sPTR";
	case sARRAY: @s_SUB = "sARRAY";
	case sSYS: @s_SUB = "sSYS";
	case sFUNC: @s_SUB = "sFUNC";
	case sMAIN: @s_SUB = "sMAIN";
	end:switch
*/

	strcat(@B, @s_CLASS);
	strcat(@B, " ");
	strcat(@B, @s_SUB);
/*	strcat(@B, ", Value = ");
	strcat(@B, @str(Dict[I].Value));*/
	strcat(@B, ", pType = ");
	strcat(@B, @str(Dict[I].pType));

	//strcat(@B, "~n");

	if @cb != NULL then
		cb(@B);
	else
		puts(@B);
		puts("~n");
	end
end

void DumpDictEntries(DumpDictEntryCallback@ cb)
	word I = 0;
	while I < nDict do
		DumpDictEntry(I, @cb);
		inc I;
	end:do
end

/*****************************************************************************/