
/*
	Процедуры синтаксического анализа вехнего уровня грамматики.
*/

/*****************************************************************************/

void DeclMainFunc(char@ Buff)

	word p = DictAlloc();

	pCurrentFunc = p;
	pMainFunc = p;
	word Saved_nLocal = nLocal;

	DictSetName(p, "");
	Dict[p].Class = cFUNC;
	Dict[p].Sub   = sMAIN;
	Dict[p].pType = st_void;

	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, p);

	Scan(@Buff);
	Dict[pCurrentFunc].pNode = Statements(@Buff, "end", NULL, NULL);

	nLocal = Saved_nLocal;

	pCurrentFunc = nDICT;
end

/*****************************************************************************/

void AssignFieldOffset(word F; word @NextOffset; word @MaxAlign)
	word pType = Dict[F].pType;
	word Align = 1; // FIXME: T_AlignOf(pType);
	when Align > MaxAlign:
		MaxAlign = Align;
	word Offset = NextOffset + (Align - NextOffset % Align - 1);
	Dict[F].Label = Offset;
	NextOffset = Offset + T_SizeOf(pType);
end

bool DeclStruct(char @Buff)
	word SkipFinalScan;
	CheckDuplicate(@Scan(@Buff));

	word pStruct = DictAlloc();
	DictSetName(pStruct, @Buff);
	Dict[pStruct].Class = cTYPE;
	Dict[pStruct].Sub = sSTRUCT;
	DictAddToNamespace(pStruct, pEnteredNamespace);

	char @TypeName = @DictGetName(pStruct);

	if str_eq(@Scan(@Buff),";") then
		Stop(@eNOTAVAIL);
	end

	char @End;
	bool CurlyBraces;
	select
	case str_eq(@Buff, "of"):
		CurlyBraces = false;
		@End = "end";
		Scan(@Buff);
	case str_eq(@Buff, "{"):
		CurlyBraces = true;
		@End = "}";
		Scan(@Buff);
	default:
		CurlyBraces = false;
		@End = "end";
		Deprecated(@dptMISSINGOF_STRUCT);
	end

	word NextOffset = 0;
	word MaxAlign = 1;

	forever do
		word pType = ResolveGlobal(@Buff, NULL);
		if pType == nDICT then
			Stop(@eTYPEEXP);
		else
			if Dict[pType].Class!=cTYPE then
				Stop(@eTYPEEXP);
			end
		end

		forever do
			word  nPtr = ReadPtrs(@Buff);

			if pType==st_void & nPtr<1 then
				Stop(@eNOVOID);
			end

			if pType==pStruct & nPtr<1 then
				Stop(@eNODATA);
			end

			if Dict[pType].Sub==sFUNCTYPE & nPtr<1 then
				Stop(@eNOVAL);
			end

			word F = FindInNamespace(@Buff, pStruct);
			when F < nDICT:
				StopWithSubject(@eDUPLICATE, @Buff);

			F = DictAlloc();
			DictSetName(F, @Buff);
			Dict[F].Class = cFIELD;
			Dict[F].pType = T_nPtrTo(nPtr, pType);
			//Dict[F].nIndx = Tabl(@Scan(@Buff));
			Dict[F].pType = Tabl_(@Scan(@Buff), Dict[F].pType);
			DictAddToNamespace(F, pStruct);
			AssignFieldOffset(F, @NextOffset, @MaxAlign);

			if str_eq(@Buff,";") then
				Scan(@Buff);
				exit;
			end

			if str_eq(@Buff,"end") then
				when !CurlyBraces:
					exit;
				Stop(@eWRONGEND_STRUCT);
			end

			if str_eq(@Buff,"}") then
				when CurlyBraces:
					exit;
				Stop(@eWRONGBRACE_STRUCT);
			end

			if str_ne(@Buff,",") then
				Stop(@eSEMICOLONEXP);
			end

			Scan(@Buff);
		end:forever

		if str_eq(@Buff,@End) then
			if CurlyBraces then
				MatchSemicolon(@Buff);
				SkipFinalScan = 0;
			else
				SkipFinalScan = EndOf(@Buff, "struct", @TypeName, true);
			end
			exit;
		end:if
	end:forever

	Dict[pStruct].TypeSize = NextOffset;

	return SkipFinalScan == 0;
end

/*****************************************************************************/

bool DeclSynonym(char @Buff) /* FIXME: REMOVE-NEXT */
	Deprecated("'synonym' is deprecaed; use 'alias' instead");

	CheckDuplicate(@Scan(@Buff));

	word D = DictAlloc();
	DictSetName(D, @Buff);
	Dict[D].Class = cNAME;

	word pType = ResolveGlobal(@Scan(@Buff), NULL);
	if pType >= nDict then
		Stop(@eUNDECLARED);
	end

	DictAddToNamespace(D, pEnteredNamespace);
	Dict[D].pType = pType;

	return false;
end

/*****************************************************************************/

bool DeclAlias(char @Buff)
	CheckDuplicate(@Scan(@Buff));

	word D = DictAlloc();
	DictSetName(D, @Buff);

	SOURCELOCATION Location = CurrentFileInfo;

	if str_eq(@Scan(@Buff),"=") then
		Scan(@Buff);
	else
		if str_eq(@Buff,".") then
			StopWithSubject(@eASSIGNEXP2, @DictGetName(D));
		else
			ErrorWithSubject(@eASSIGNEXP2, @DictGetName(D));
		end
	end:if

	word pExpr = Expr(PRIO_ZERO, @Buff);
	select
	case IsTypeExpr(pExpr):
		Dict[D].Class = cNAME;
		Dict[D].pType = Node[pExpr].Value;
	case IsConstExpr(pExpr):
		Dict[D].Class = cLITERAL;
		Dict[D].RO = 1;
		Dict[D].pType = Node[pExpr].pType;
		Dict[D].LiteralValue = Node[pExpr].Value;
	case Node[pExpr].ID == iFUNC:
		Dict[D].Class = cNAME;
		Dict[D].pType = Node[pExpr].Value;
	case Node[pExpr].ID == iDATA:
		Dict[D].Class = cNAME;
		Dict[D].pType = Node[pExpr].Value;
	default:
		Dict[D].Class = cNAME;
		Dict[D].pType = st_void; /* FIXME: better approach? */
		ErrorAt(@Location, @eALIAS_WRONGRVALUE);
	end:select

	DictAddToNamespace(D, pEnteredNamespace);

	if str_eq(@Buff,";") then
		return true;
	else
		Error(@eSEMICOLONEXP);
		return false;
	end:if
end

/*****************************************************************************/

void DeclFunc1(char @Buff; word _pFunc; word pForward)

	pCurrentFunc=_pFunc;

	Dict[pCurrentFunc].Class = cFUNC;
	Dict[pCurrentFunc].Sub   = sFUNC;
	FuncArgs(@Buff, pCurrentFunc);

	if pForward != nDICT then
		word T1 = T_FuncTypeForFunction(pCurrentFunc);
		word T2 = T_FuncTypeForFunction(pForward);
		if !T_IsFuctTypesIdentical(T1, T2) then
			Error(@eTYPE_FUNC_FWD);
		else
			DictFree(@pCurrentFunc);
			pCurrentFunc = pForward;
		end
	end:if

	Scan(@Buff);

	select
		case str_eq(@Buff,";"): /* Прототип. */
			Dict[pCurrentFunc].Forward = 1;

		case str_eq(@Buff,"external"): /* Внешняя функция. */
			select
				case TargetFileFormat == tPE:
					pass;
				default:
					Stop(@eNOTALLOWED);
			end

			/* Читаем имя библиотеки. Добавляем библиотеку в словарь, если она туда еще не занесена. */
			word pLib = Find(@Scan(@Buff));
			if   pLib >= nDict then
				pLib = DictAlloc();
				DictSetName(pLib, @Buff);
				Dict[pLib].Class = cLIB;
			end:if
			when Dict[pLib].Class != cLIB:
				StopInternal(__FILE__, __LINE__);

			/*
				Если для функции в библиотеке указано имя, отличное от объявленного имени функции,
				объявленное имя делаем алиасом для библиотечного имени.
				FIXME: Переделать! Библиотечное имя не должно присутствовать в пространстве имён модуля.
			*/
			if str_eq(@Scan(@Buff),".") then
				if Find(@Scan(@Buff)) < nDict then
					StopWithSubject(@eDUPLICATE, @Buff);
				end:if

				word pAlias = DictAlloc();

				DictSetName(pAlias, @DictGetName(pCurrentFunc));
				Dict[pAlias].Class = cNAME;
				Dict[pAlias].pType = pCurrentFunc;
				DictAddToNamespace(pAlias, pEnteredNamespace);

				DictSetName(pCurrentFunc, @Buff);
				Scan(@Buff);

			end:if

			Dict[pCurrentFunc].Sub   = sSYS;
			Dict[pCurrentFunc].pNode = pLib;

			if str_ne(@Buff,";") then
				Stop(@eSEMICOLONEXP);
			end:if

		default: /* Тело функции. */

			if str_eq(@Buff, "of") then
				/* Optional 'of'. */
				Scan(@Buff);
			end

			word Saved_nLocal = nLocal;
			Dict[pCurrentFunc].pNode = Statements(@Buff, "end", NULL, NULL);
			nLocal = Saved_nLocal;

			CTE_Function(pCurrentFunc);

	end:select

end

/*****************************************************************************/

void DeclVarFuncType(char @Buff; word pType)
	Scan(@Buff);
	word nPtr = ReadPtrs(@Buff);

	CheckDuplicate(@Buff);

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cTYPE;
	Dict[D].Sub   = sFUNCTYPE;
	DictAddToNamespace(D, pEnteredNamespace);

	if str_ne(@Scan(@Buff),"(") then
		Stop(@eBRACKETEXP);
	end

	Dict[D].pType = T_nPtrTo(nPtr, pType);
	FuncArgs(@Buff, D);

	/*if (str_ne(@Scan(@Buff),";")) then
		Stop(@eSEMICOLONEXP);
	end*/

end

/*****************************************************************************/

void DeclVarFunc(char @Buff)
	word pPrefixExpr = Expr(PRIO_LVALUE, @Buff);
	if Node[pPrefixExpr].ID != iTYPE then
		Stop(@eTYPEEXP);
	end

	word pPrefixType = Node[pPrefixExpr].Value;
	//pPrefixType = ResolveAlias(pPrefixType);
	if pPrefixType == nDICT | Dict[pPrefixType].Class != cTYPE then
		Stop(@eTYPEEXP);
	end

	/* Функтор-тип. */
	if str_eq(@Buff,"function") then
		DeclVarFuncType(@Buff, pPrefixType);
		return;
	end


	word FirstName = 1;

	forever do
		word nPtr = ReadPtrs(@Buff);

		word pForward = ResolveInNamespace(@Buff, pEnteredNamespace);
		if pForward < nDict then
			when !Dict_IsFunction(pForward):
				StopWithSubject(@eDUPLICATE, @Buff);
			when Dict[pForward].Forward == 0:
				StopWithSubject(@eDUPLICATE, @Buff);
		end

		word D = DictAlloc();

		DictSetName(D, @Buff);
		Dict[D].pType = T_nPtrTo(nPtr, pPrefixType);
		DictAddToNamespace(D, pEnteredNamespace);

		Scan(@Buff);

		/* Функция. */
		if str_eq(@Buff,"(") then
			if FirstName == 0 then
				Stop(@eNOFUNCTION);
			end
			DeclFunc1(@Buff, D, pForward);
			pCurrentFunc = nDICT;
			return;
		end

		when pForward < nDict:
			StopWithSubject(@eDUPLICATE, @DictGetName(D));

		FirstName = 0;

		if Dict[D].pType == st_void then
			Stop(@eNOVOID);
		end

		if Dict[Dict[D].pType].Sub == sFUNCTYPE then
			Stop(@eNOVAL);
		end

		Dict[D]. Class=cDATA;
		//Dict[D].nIndx = Tabl(@Buff);
		Dict[D].pType = Tabl_(@Buff, Dict[D].pType);
		Dict[D].pNode =nNODE;

		if str_eq(@Buff,"=") then
			/*if Dict[D].nIndx > 0 then
				Stop(@eNOTAVAIL);
			end*/

			word P1=Peek();
			word P2=Peek();
			Node[P1].ID    =iASSIGN;
			Node[P1].pLeft = P2;

			word P3=Peek();
			Node[P2].ID    =iEMPTY;
			Node[P2].pLeft = P3;
			Node[P2].pRight= Expr(PRIO_ZERO, @Scan(@Buff));

			Node[P3].ID    =iDATA;
			Node[P3].Value =D;

			ImplicitCast(Dict[D].pType, @Node[P2].pRight);

			Dict[D].pNode=P1;

		end

		if str_eq(@Buff,";") then
			exit;
		end

		if str_ne(@Buff,",") then
			Stop(@eSEMICOLONEXP);
		end

		Scan(@Buff);

	end:forever

end

/*****************************************************************************/

bool DeclDefine(char @Buff)

	word nPtr = ReadPtrs(@Scan(@Buff));

	CheckDuplicate(@Buff);

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	DictAddToNamespace(D, pEnteredNamespace);

	Scan(@Buff);
	select
		case nPtr==0:

			word P = Expr(PRIO_ZERO, @Buff);

			select
				case Node[P].ID==iLITERAL:
					Dict[D].pType = Node[P].pType;
					Dict[D].LiteralValue = Node[P].Value;

				default:
					Stop(@eTYPE);
			end:select

			if str_eq(@Buff,";") then
				Scan(@Buff);
			end:if

			return false;

		default:
			if str_ne(@Buff,"~"") then
				Stop(@eQUOTEXP);
			end
			ScanString(D);
	end:select

	return true;
end

/*****************************************************************************/

void Include(word pFileName; word pGuard; bool Once)
	bool DoInclude = true;

	if pGuard != nNODE then
		if !IsConstExpr(pGuard) then
			Error(@eINCLUDE_GUARD_CONST_EXP);
			DoInclude = false;
		end:if

		if !NodeIsTrue(pGuard) & !NodeIsFalse(pGuard) then
			Error(@eINCLUDE_GUARD_WRONG_TYPE);
			DoInclude = false;
		end:if

		if !NodeIsTrue(pGuard) then
			DoInclude = false;
		end:if
	end:if

	when Node[pFileName].ID == iLPTR:
		pFileName = Node[pFileName].pLeft;

	if !NodeIsLiteralString(pFileName) then
		Error(@eINCLUDE_NAME_WRONG_TYPE);
		DoInclude = false;
	end:if

	when !DoInclude:
		return;

	char@ FileName = @NodeGetLiteralString(pFileName);
	char@ FullFileName = @ResolveFileName(@FileName);

	word dFile = Find_cFILE(@FullFileName);
	if dFile != nDICT & Once then
		return;
	end:if

	if dFile == nDICT then
		dFile = DictAlloc();
		DictSetName(dFile, @FullFileName);
		Dict[dFile].Class = cFILE;
	end

	IncludeFile(@FullFileName);
end

bool DeclInclude(char @Buff)
	word pFileName = Expr(PRIO_ZERO, @Scan(@Buff));
	when str_ne(@Buff, ";"):
		Stop(@eINCLUDE_SEMICOLON_EXP);
	Include(pFileName, nNODE, false);
	return true;
end

bool DeclIncludeWhen(char @Buff)
	word pFileName = Expr(PRIO_ZERO, @Scan(@Buff));
	when str_ne(@Buff, ","):
		Stop(@eINCLUDE_WHEN_COMMA_EXP);
	word pGuard = Expr(PRIO_ZERO, @Scan(@Buff));
	when str_ne(@Buff, ";"):
		Stop(@eINCLUDE_WHEN_SEMICOLON_EXP);
	Include(pFileName, pGuard, false);
	return true;
end

bool DeclIncludeOnce(char @Buff)
	word pFileName = Expr(PRIO_ZERO, @Scan(@Buff));
	when str_ne(@Buff, ";"):
		Stop(@eINCLUDE_ONCE_SEMICOLON_EXP);
	Include(pFileName, nNODE, true);
	return true;
end

/*****************************************************************************/

bool DeclNamespace(char @Buff)
	word SkipFinalScan;
	CheckDuplicate(@Scan(@Buff));

	word pNamespace = DictMakeNamespace(@Buff);
	DictAddToNamespace(pNamespace, pEnteredNamespace);

	char @TypeName = @DictGetName(pNamespace);

	if str_eq(@Scan(@Buff),";") then
		Stop(@eNOTAVAIL);
	end

	word pPrevNamespace = pEnteredNamespace;
	pEnteredNamespace = pNamespace;

	char @End;
	bool CurlyBraces;
	select
	case str_eq(@Buff, "of"):
		CurlyBraces = false;
		@End = "end";
		Scan(@Buff);
	case str_eq(@Buff, "{"):
		CurlyBraces = true;
		@End = "}";
		Scan(@Buff);
	default:
		CurlyBraces = false;
		@End = "end";
		Deprecated(@dptMISSINGOF_NAMESPACE);
	end

	forever do
		bool DoScan = true;
		select
		case str_eq(@Buff,"include"):
			DoScan = DeclInclude(@Buff);
		case str_eq(@Buff,"include_when"):
			DoScan = DeclIncludeWhen(@Buff);
		case str_eq(@Buff,"include_once"):
			DoScan = DeclIncludeOnce(@Buff);
		case str_eq(@Buff,"define"):
			DoScan = DeclDefine(@Buff);
		case str_eq(@Buff,"struct"):
			DoScan = DeclStruct(@Buff);
		case str_eq(@Buff,"namespace"):
			DoScan = DeclNamespace(@Buff);
		case str_eq(@Buff,"alias"):
			DoScan = DeclAlias(@Buff);
		case str_eq(@Buff,"synonym"):
			DoScan = DeclSynonym(@Buff);
		case str_eq(@Buff,"end"):
			when !CurlyBraces:
				exit;
			Stop(@eWRONGEND_NAMESPACE);
		case str_eq(@Buff,"}"):
			when CurlyBraces:
				exit;
			Stop(@eWRONGBRACE_NAMESPACE);
		case str_eq(@Buff,@End):
			exit;
		case str_eq(@Buff, ";"):
			Warn(@wDANGLING_SEMICOLON);
		default: // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if DoScan then
			Scan(@Buff);
		end
	end:forever

	if str_eq(@Buff,@End) then
		if CurlyBraces then
			MatchSemicolon(@Buff);
			SkipFinalScan = 0;
		else
			SkipFinalScan = EndOf(@Buff, "namespace", @TypeName, true);
		end
	end:if

	pEnteredNamespace = pPrevNamespace;

	return SkipFinalScan == 0;
end

/*****************************************************************************/

void Parse()
	char Buff[nBUFF];
	Scan(@Buff);

	forever do
		bool DoScan = true;
		select
		case str_eq(@Buff,"include"):
			DoScan = DeclInclude(@Buff);
		case str_eq(@Buff,"include_when"):
			DoScan = DeclIncludeWhen(@Buff);
		case str_eq(@Buff,"include_once"):
			DoScan = DeclIncludeOnce(@Buff);
		case str_eq(@Buff,"define"):
			DoScan = DeclDefine(@Buff);
		case str_eq(@Buff,"struct"):
			DoScan = DeclStruct(@Buff);
		case str_eq(@Buff,"namespace"):
			DoScan = DeclNamespace(@Buff);
		case str_eq(@Buff,"alias"):
			DoScan = DeclAlias(@Buff);
		case str_eq(@Buff,"synonym"):
			DoScan = DeclSynonym(@Buff);
		case str_eq(@Buff,"begin"):
			DeclMainFunc(@Buff);
			exit;
		case str_eq(@Buff, ";"):
			Warn(@wDANGLING_SEMICOLON);
		default: // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if DoScan then
			Scan(@Buff);
		end
	end:forever
end

/*****************************************************************************/

