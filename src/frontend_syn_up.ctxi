
/*
	Процедуры синтаксического анализа вехнего уровня грамматики.
*/

/*****************************************************************************/

void DeclMainFunc(char@ Buff)

	word p = DictAlloc();

	pCurrentFunc = p;
	pMainFunc = p;
	word Saved_nLocal = nLocal;

	DictSetName(p, "");
	Dict[p].Class = cFUNC;
	Dict[p].Sub   = sMAIN;
	Dict[p].pType = st_void;

	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, p);

	Scan(@Buff);
	Dict[pCurrentFunc].pNode = Statements(@Buff, "end", NULL, NULL);

	nLocal = Saved_nLocal;

	pCurrentFunc = nDICT;
end

/*****************************************************************************/

void AssignFieldOffset(word F; word @NextOffset; word @MaxAlign)
	word pType = Dict[F].pType;
	word Align = 1; // FIXME: T_AlignOf(pType);
	when Align > MaxAlign:
		MaxAlign = Align;
	word Offset = NextOffset + (Align - NextOffset % Align - 1);
	Dict[F].Label = Offset;
	NextOffset = Offset + T_SizeOf(pType);
end

void DeclStruct(char @Buff)
	CheckDuplicate(@Scan(@Buff));

	word pStruct = DictAlloc();
	DictSetName(pStruct, @Buff);
	Dict[pStruct].Class = cTYPE;
	Dict[pStruct].Sub = sSTRUCT;
	DictAddToNamespace(pStruct, pEnteredNamespace);

	if str_eq(@Scan(@Buff),";") then
		Stop(@eNOTAVAIL);
	end

	word NextOffset = 0;
	word MaxAlign = 1;

	do
		word pType = ResolveGlobal(@Buff, NULL);
		if pType == nDICT then
			Stop(@eTYPEEXP);
		else
			if Dict[pType].Class!=cTYPE then
				Stop(@eTYPEEXP);
			end
		end

		do
			word  nPtr = ReadPtrs(@Buff);

			if pType==st_void & nPtr<1 then
				Stop(@eNOVOID);
			end

			if pType==pStruct & nPtr<1 then
				Stop(@eNODATA);
			end

			if Dict[pType].Sub==sFUNCTYPE & nPtr<1 then
				Stop(@eNOVAL);
			end

			word F = FindInNamespace(@Buff, pStruct);
			when F < nDICT:
				StopWithSubject(@eDUPLICATE, @Buff);

			F = DictAlloc();
			DictSetName(F, @Buff);
			Dict[F].Class = cFIELD;
			Dict[F].pType = T_nPtrTo(nPtr, pType);
			//Dict[F].nIndx = Tabl(@Scan(@Buff));
			Dict[F].pType = Tabl_(@Scan(@Buff), Dict[F].pType);
			DictAddToNamespace(F, pStruct);
			AssignFieldOffset(F, @NextOffset, @MaxAlign);

			if str_eq(@Buff,";") then
				Scan(@Buff);
				exit;
			end

			if str_eq(@Buff,"end") then
				exit;
			end

			if str_ne(@Buff,",") then
				Stop(@eSEMICOLONEXP);
			end

			Scan(@Buff);
		end

		if str_eq(@Buff,"end") then
			exit;
		end
	end

	Dict[pStruct].TypeSize = NextOffset;
end

/*****************************************************************************/

bool DeclSynonym(char @Buff)
	CheckDuplicate(@Scan(@Buff));

	word D = DictAlloc();
	DictSetName(D, @Buff);
	Dict[D].Class = cNAME;

	word pType = ResolveGlobal(@Scan(@Buff), NULL);
	if pType >= nDict then
		Stop(@eUNDECLARED);
	end

	DictAddToNamespace(D, pEnteredNamespace);
	Dict[D].pType = pType;

	return false;
end

/*****************************************************************************/

void DeclFunc1(char @Buff; word _pFunc; word pForward)

	pCurrentFunc=_pFunc;

	Dict[pCurrentFunc].Class = cFUNC;
	Dict[pCurrentFunc].Sub   = sFUNC;
	FuncArgs(@Buff, pCurrentFunc);

	if pForward != nDICT then
		word T1 = T_FuncTypeForFunction(pCurrentFunc);
		word T2 = T_FuncTypeForFunction(pForward);
		if !T_IsFuctTypesIdentical(T1, T2) then
			Error(@eTYPE_FUNC_FWD);
		else
			DictFree(@pCurrentFunc);
			pCurrentFunc = pForward;
		end
	end:if

	Scan(@Buff);

	select
		case str_eq(@Buff,";"): /* Прототип. */
			Dict[pCurrentFunc].Forward = 1;

		case str_eq(@Buff,"external"): /* Внешняя функция. */
			select
				case TargetFileFormat == tPE:
					null;
				default:
					Stop(@eNOTALLOWED);
			end

			/* Читаем имя библиотеки. Добавляем библиотеку в словарь, если она туда еще не занесена. */
			word pLib = Find(@Scan(@Buff));
			if   pLib >= nDict then

				pLib = DictAlloc();

				DictSetName(pLib, @Buff);
				Dict[pLib].Class = cLIB;

			end:if


			/*
				Если для функции в библиотеке указано имя, отличное от объявленного имени функции,
				объявленное имя делаем алиасом для библиотечного имени.
				FIXME: Переделать! Библиотечное имя не должно присутствовать в пространстве имён модуля.
			*/
			if str_eq(@Scan(@Buff),".") then
				if Find(@Scan(@Buff)) < nDict then
					StopWithSubject(@eDUPLICATE, @Buff);
				end:if

				word pAlias = DictAlloc();

				DictSetName(pAlias, @DictGetName(pCurrentFunc));
				Dict[pAlias].Class = cNAME;
				Dict[pAlias].pType = pCurrentFunc;

				DictSetName(pCurrentFunc, @Buff);
				Scan(@Buff);

			end:if

			Dict[pCurrentFunc].Sub   = sSYS;
			Dict[pCurrentFunc].pNode = pLib;

			if str_ne(@Buff,";") then
				Stop(@eSEMICOLONEXP);
			end:if

		default: /* Тело функции. */
			word Saved_nLocal = nLocal;
			Dict[pCurrentFunc].pNode = Statements(@Buff, "end", NULL, NULL);
			nLocal = Saved_nLocal;

			CTE_Function(pCurrentFunc);

	end:select

end

/*****************************************************************************/

void DeclVarFuncType(char @Buff; word pType)
	Scan(@Buff);
	word nPtr = ReadPtrs(@Buff);

	CheckDuplicate(@Buff);

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cTYPE;
	Dict[D].Sub   = sFUNCTYPE;

	if str_ne(@Scan(@Buff),"(") then
		Stop(@eBRACKETEXP);
	end

	Dict[D].pType = T_nPtrTo(nPtr, pType);
	FuncArgs(@Buff, D);

	/*if (str_ne(@Scan(@Buff),";")) then
		Stop(@eSEMICOLONEXP);
	end*/

end

/*****************************************************************************/

void DeclVarFunc(char @Buff)
	word pPrefixType = ResolveGlobal(@Buff, NULL);
	//pPrefixType = ResolveAlias(pPrefixType);
	if pPrefixType == nDICT | Dict[pPrefixType].Class != cTYPE then
		Stop(@eTYPEEXP);
	end

	/* Функтор-тип. */
	if str_eq(@Buff,"function") then
		DeclVarFuncType(@Buff, pPrefixType);
		return;
	end


	word FirstName = 1;

	do
		word nPtr = ReadPtrs(@Buff);

		word pForward = ResolveInNamespace(@Buff, pEnteredNamespace);
		if pForward < nDict then
			when !Dict_IsFunction(pForward):
				StopWithSubject(@eDUPLICATE, @Buff);
			when Dict[pForward].Forward == 0:
				StopWithSubject(@eDUPLICATE, @Buff);
		end

		word D = DictAlloc();

		DictSetName(D, @Buff);
		Dict[D].pType = T_nPtrTo(nPtr, pPrefixType);
		DictAddToNamespace(D, pEnteredNamespace);

		Scan(@Buff);

		/* Функция. */
		if str_eq(@Buff,"(") then
			if FirstName == 0 then
				Stop(@eNOFUNCTION);
			end
			DeclFunc1(@Buff, D, pForward);
			pCurrentFunc = nDICT;
			return;
		end

		when pForward < nDict:
			StopWithSubject(@eDUPLICATE, @DictGetName(D));

		FirstName = 0;

		if Dict[D].pType == st_void then
			Stop(@eNOVOID);
		end

		if Dict[Dict[D].pType].Sub == sFUNCTYPE then
			Stop(@eNOVAL);
		end

		Dict[D]. Class=cDATA;
		//Dict[D].nIndx = Tabl(@Buff);
		Dict[D].pType = Tabl_(@Buff, Dict[D].pType);
		Dict[D].pNode =nNODE;

		if str_eq(@Buff,"=") | str_eq(@Buff,":=") then
			/*if Dict[D].nIndx > 0 then
				Stop(@eNOTAVAIL);
			end*/

			word P1=Peek();
			word P2=Peek();
			Node[P1].ID    =iASSIGN;
			Node[P1].pLeft = P2;

			word P3=Peek();
			Node[P2].ID    =iEMPTY;
			Node[P2].pLeft = P3;
			Node[P2].pRight= Expr(PRIO_ZERO, @Scan(@Buff));

			Node[P3].ID    =iDATA;
			Node[P3].Value =D;

			ImplicitCast(Dict[D].pType, @Node[P2].pRight);

			Dict[D].pNode=P1;

		end

		if str_eq(@Buff,";") then
			exit;
		end

		if str_ne(@Buff,",") then
			Stop(@eSEMICOLONEXP);
		end

		Scan(@Buff);

	end:do

end

/*****************************************************************************/

bool DeclDefine(char @Buff)

	word nPtr = ReadPtrs(@Scan(@Buff));

	CheckDuplicate(@Buff);

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	DictAddToNamespace(D, pEnteredNamespace);

	Scan(@Buff);
	select
		case nPtr==0:

			word P = Expr(PRIO_ZERO, @Buff);

			select
				case Node[P].ID==iLITERAL:
					Dict[D].pType = Node[P].pType;
					Dict[D].LiteralValue = Node[P].Value;

				default:
					Stop(@eTYPE);
			end:select

			if str_eq(@Buff,";") then
				Scan(@Buff);
			end:if

			return false;

		default:
			if str_ne(@Buff,"~"") then
				Stop(@eQUOTEXP);
			end
			ScanString(D);
	end:select

	return true;
end

/*****************************************************************************/

bool DeclInclude(char @Buff)

	/* Читаем имя файла. */

	if str_ne(@Scan(@Buff),"~"") then
		Stop(@eQUOTEXP);
	end

	word P=0;
	while Read()!='"' do
		if iswhitespace(Read()) != 0 then
			Stop(@eQUOTEXP);
		end

		Buff[P]=Read();
		inc  P;

		if P >= nBUFF then
			Stop(@eLONGNAME);
		end

		Next();
	end:while

	Buff[P]=#0;
	Next();

	char@ FileName = @ResolveFileName(@Buff);

	/* Проверка, подключался ли уже указанный файл. */
	P = Find_cFILE(@FileName);
	if P < nDict then
		return true;
	end:if

	/* Заносим имя файла в словарь. */
	word D = DictAlloc();
	DictSetName(D, @FileName);
	Dict[D].Class = cFILE;

	IncludeFile(@FileName);

	return true;
end

/*****************************************************************************/

void DeclNamespace(char @Buff)
	CheckDuplicate(@Scan(@Buff));

	word pNamespace = DictAlloc();
	DictSetName(pNamespace, @Buff);
	Dict[pNamespace].Class = cTYPE;
	Dict[pNamespace].Sub = sNAMESPACE;
	DictAddToNamespace(pNamespace, pEnteredNamespace);

	if str_eq(@Scan(@Buff),";") then
		Stop(@eNOTAVAIL);
	end

	word pPrevNamespace = pEnteredNamespace;
	pEnteredNamespace = pNamespace;

	do
		bool DoScan = true;
		select
		case str_eq(@Buff,"include"):
			DoScan = DeclInclude(@Buff);
		case str_eq(@Buff,"define"):
			DoScan = DeclDefine(@Buff);
		case str_eq(@Buff,"struct"):
			DeclStruct(@Buff);
		case str_eq(@Buff,"namespace"):
			DeclNamespace(@Buff);
		case str_eq(@Buff,"synonym"):
			DoScan = DeclSynonym(@Buff);
		case str_eq(@Buff,"end"):
			exit;
		default: // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if DoScan then
			Scan(@Buff);
		end
	end

	pEnteredNamespace = pPrevNamespace;
end

/*****************************************************************************/

void Parse()

	char Buff[nBUFF];
	Scan(@Buff);

	do
		bool DoScan = true;
		select
		case str_eq(@Buff,"begin"):
			DeclMainFunc(@Buff);
			exit;
		case str_eq(@Buff,"include"):
			DoScan = DeclInclude(@Buff);
		case str_eq(@Buff,"define"):
			DoScan = DeclDefine(@Buff);
		case str_eq(@Buff,"struct"):
			DeclStruct(@Buff);
		case str_eq(@Buff,"namespace"):
			DeclNamespace(@Buff);
		case str_eq(@Buff,"synonym"):
			DoScan = DeclSynonym(@Buff);
		default: // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if DoScan then
			Scan(@Buff);
		end
	end:do

end

/*****************************************************************************/

