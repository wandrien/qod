
/*
	Процедуры синтаксического анализа вехнего уровня грамматики.
*/

/*****************************************************************************/

void DeclMainFunc(char@ Buff)

	word p = DictAlloc();

	pFunc = p;
	word Saved_nLocal = nLocal;

	DictSetName(p, "");
	Dict[p].Class = cFUNC;
	Dict[p].Sub   = sMAIN;
	Dict[p].pType = st_void;

	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, p);

	Scan(@Buff);
	Dict[pFunc].pNode = Statements(@Buff, "end", NULL, NULL);

	nLocal = Saved_nLocal;
end

/*****************************************************************************/

void DeclStruct(char @Buff)

        word pType1 = Find(@Scan(@Buff));
        if pType1 < nDict then
          Stop(@eDUPLICATE);
        end

        word pStruct = DictAlloc();
        DictSetName(pStruct, @Buff);
        Dict[pStruct].Class = cTYPE;
        Dict[pStruct].Sub = sSTRUCT;

        if strcmp(@Scan(@Buff),";")=0 then
          Stop(@eNOTAVAIL);
        end

        do
          word pType = Find(@Buff);
          if pType >= nDict then
            Stop(@eTYPEEXP);
          else
            if Dict[pType].Class!=cTYPE then
              Stop(@eTYPEEXP);
            end
          end

          do
            word  nPtr=0;
            while strcmp(@Scan(@Buff),"@")=0 do
              inc nPtr;
            end

            if pType=st_void & nPtr<1 then
              Stop(@eNOVOID);
            end

            if pType=pStruct & nPtr<1 then
              Stop(@eNODATA);
            end

            if Dict[pType].Sub=sFUNCTYPE & nPtr<1 then
              Stop(@eNOVAL);
            end

            word F = FindInNamespace(@Buff, pStruct);
            when F < nDICT:
              Stop(@eDUPLICATE);

            F = DictAlloc();
            DictSetName(F, @Buff);
            Dict[F].Class = cFIELD;
            Dict[F].pType = T_nPtrTo(nPtr, pType);
            Dict[F].nIndx = Tabl(@Scan(@Buff));
            DictAddToNamespace(F, pStruct);

            if strcmp(@Buff,";") =0 then
              Scan(@Buff);
              exit;
            end

            if strcmp(@Buff,"end")=0 then
              exit;
            end

            if strcmp(@Buff,",")!=0 then
              Stop(@eSEMICOLONEXP);
            end
          end

          if strcmp(@Buff,"end")=0 then
            exit;
          end
        end

end

/*****************************************************************************/

void DeclSynonym(char @Buff)

	if Find(@Scan(@Buff)) < nDict then
		Stop(@eDUPLICATE);
	end

	word D = DictAlloc();
	DictSetName(D, @Buff);
	Dict[D].Class = cNAME;

	word pType = Find(@Scan(@Buff));
	if pType >= nDict then
		Stop(@eUNDEFINED);
	end

	Dict[D].pType = pType;
end

/*****************************************************************************/

void DeclFunc1(char @Buff; word a)

	pFunc=a;

	Dict[pFunc].Class = cFUNC;
	Dict[pFunc].Sub   = sFUNC;
	FuncArgs(@Buff, pFunc);

	Scan(@Buff);

	select
		case strcmp(@Buff,";")=0: /* Прототип. */
			Stop(@eNOTAVAIL);

		case strcmp(@Buff,"external")=0: /* Внешняя функция. */
			select
				case TargetFileFormat = tPE:
					null;
				default:
					Stop(@eNOTALLOWED);
			end

			/* Читаем имя библиотеки. Добавляем библиотеку в словарь, если она туда еще не занесена. */
			word pLib = Find(@Scan(@Buff));
			if   pLib >= nDict then

				pLib = DictAlloc();

				DictSetName(pLib, @Buff);
				Dict[pLib].Class = cLIB;

			end:if


			/*
				Если для функции в библиотеке указано имя, отличное от объявленного имени функции,
				объявленное имя делаем алиасом для библиотечного имени.
				FIXME: Переделать! Библиотечное имя не должно присутствовать в пространстве имён модуля.
			*/
			if strcmp(@Scan(@Buff),".")=0 then
				if Find(@Scan(@Buff)) < nDict then
					Stop(@eDUPLICATE);
				end:if

				word pAlias = DictAlloc();

				DictSetName(pAlias, @DictGetName(pFunc));
				Dict[pAlias].Class = cNAME;
				Dict[pAlias].pType = pFunc;

				DictSetName(pFunc, @Buff);
				Scan(@Buff);

			end:if

			Dict[pFunc].Sub   = sSYS;
			Dict[pFunc].pNode = pLib;

			if strcmp(@Buff,";")!=0 then
				Stop(@eSEMICOLONEXP);
			end:if

		default: /* Тело функции. */
			word Saved_nLocal = nLocal;
			Dict[pFunc].pNode = Statements(@Buff, "end", NULL, NULL);
			nLocal = Saved_nLocal;

	end:select

end

/*****************************************************************************/

void DeclVarFuncType(char @Buff; word pType)

	Scan(@Buff);
	word nPtr = ReadPtrs(@Buff);

	if Find(@Buff) < nDict then
		Stop(@eDUPLICATE);
	end

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cTYPE;
	Dict[D].Sub   = sFUNCTYPE;

	if strcmp(@Scan(@Buff),"(")!=0 then
		Stop(@eBRACKETEXP);
	end

	Dict[D].pType = T_nPtrTo(nPtr, pType);
	FuncArgs(@Buff, D);

	/*if (strcmp(@Scan(@Buff),";")!=0) then
		Stop(@eSEMICOLONEXP);
	end*/

end

/*****************************************************************************/

void DeclVarFunc(char @Buff)

	word pPrefixType = Find(@Buff);
	if pPrefixType >= nDict | Dict[pPrefixType].Class != cTYPE then
		Stop(@eTYPEEXP);
	end

	/* Функтор-тип. */
	if strcmp(@Scan(@Buff),"function")=0 then
		DeclVarFuncType(@Buff, pPrefixType);
		return;
	end


	word FirstName = 1;

	do
		word nPtr = ReadPtrs(@Buff);

		if Find(@Buff) < nDict then
			Stop(@eDUPLICATE);
		end

		word D = DictAlloc();

		DictSetName(D, @Buff);
		Dict[D].pType = T_nPtrTo(nPtr, pPrefixType);

		Scan(@Buff);

		/* Функция. */
		if strcmp(@Buff,"(")=0 then
			if FirstName = 0 then
				Stop(@eNOFUNCTION);
			end
			DeclFunc1(@Buff, D);
			return;
		end

		FirstName = 0;

		if Dict[D].pType = st_void then
			Stop(@eNOVOID);
		end

		if Dict[Dict[D].pType].Sub = sFUNCTYPE then
			Stop(@eNOVAL);
		end

		Dict[D]. Class=cDATA;
		Dict[D].nIndx = Tabl(@Buff);
		Dict[D].pNode =nNODE;

		if strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0 then
			if Dict[D].nIndx > 0 then
				Stop(@eNOTAVAIL);
			end

			word P1=Peek();
			word P2=Peek();
			Node[P1].ID    =iASSIGN;
			Node[P1].pLeft = P2;

			word P3=Peek();
			Node[P2].ID    =iEMPTY;
			Node[P2].pLeft = P3;
			Node[P2].pRight= Expr(PRIO_ZERO, @Scan(@Buff));

			Node[P3].ID    =iDATA;
			Node[P3].Value =D;

			ImplicitCast(Dict[D].pType, @Node[P2].pRight);

			Dict[D].pNode=P1;

		end

		if strcmp(@Buff,";") =0 then
			exit;
		end

		if strcmp(@Buff,",")!=0 then
			Stop(@eSEMICOLONEXP);
		end

		Scan(@Buff);

	end:do

end

/*****************************************************************************/

word DeclDefine(char @Buff)

	word nPtr = ReadPtrs(@Scan(@Buff));

	if Find(@Buff) < nDict then
		Stop(@eDUPLICATE);
	end

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;

	Scan(@Buff);
	select
		case nPtr=0:

			word P = Expr(PRIO_ZERO, @Buff);

			select
				case Node[P].ID=iWORD:
					Dict[D].pType=st_word;
					Dict[D].Value=Node[P].Value;

				case Node[P].ID=iINT:
					Dict[D].pType=st_int;
					Dict[D].Value=Node[P].Value;

				case Node[P].ID=iCHAR:
					Dict[D].pType=st_char;
					Dict[D].Value=Node[P].Value;

				default:
					Stop(@eTYPE);
			end:select

			if strcmp(@Buff,";")=0 then
				Scan(@Buff);
			end:if

			return 1;

		default:
			if strcmp(@Buff,"~"")!=0 then
				Stop(@eQUOTEXP);
			end
			ScanString(D);
	end:select

	return 0;
end

/*****************************************************************************/

word DeclInclude(char @Buff)

	/* Читаем имя файла. */

	if strcmp(@Scan(@Buff),"~"")!=0 then
		Stop(@eQUOTEXP);
	end

	word P=0;
	while Read()!='"' do
		if iswhitespace(Read()) != 0 then
			Stop(@eQUOTEXP);
		end

		Buff[P]=Read();
		inc  P;

		if P>=nNAME then
			Stop(@eLONGNAME);
		end

		Next();
	end:while

	Buff[P]=#0;
	Next();

	char@ FileName = @ResolveFileName(@Buff);

	/* Проверка, подключался ли уже указанный файл. */
	P = Find_cFILE(@FileName);
	if P < nDict then
		return 0;
	end:if

	/* Заносим имя файла в словарь. */
	word D = DictAlloc();
	DictSetName(D, @FileName);
	Dict[D].Class = cFILE;

	IncludeFile(@FileName);

	return 0;
end

/*****************************************************************************/

void Parse()

	char Buff[nBUFF];
	Scan(@Buff);

	do
		word R = 0;
		select
		case strcmp(@Buff,"begin")=0:         // Главная функция
			DeclMainFunc(@Buff);
			exit;
		case strcmp(@Buff,"include")=0:       // Включаемый файл
			R = DeclInclude(@Buff);
		case strcmp(@Buff,"define")=0:        // Константа
			R = DeclDefine(@Buff);
		case strcmp(@Buff,"struct")=0:        // Стpуктуpа
			DeclStruct(@Buff);
		case strcmp(@Buff,"synonym")=0:       // Синоним
			DeclSynonym(@Buff);
		case strcmp(@Buff,"$context2")=0:
			null;
		default:                              // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if R = 0 then
			Scan(@Buff);
		end

	end:do

end

/*****************************************************************************/

