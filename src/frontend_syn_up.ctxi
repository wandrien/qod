
/*
	Процедуры синтаксического анализа вехнего уровня грамматики.
*/

/*****************************************************************************/

void DeclMainFunc(char@ Buff)

	word p = DictAlloc();

	pFunc = p;
	word Saved_nLocal = nLocal;

	DictSetName(p, "");
	Dict[p].Class = cFUNC;
	Dict[p].Sub   = sMAIN;
	Dict[p].pType = st_void;

	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, p);

	Scan(@Buff);
	Dict[pFunc].pNode = Statements(@Buff, "end", NULL, NULL);

	nLocal = Saved_nLocal;
end

/*****************************************************************************/

void DeclStruct(char @Buff)

        word pType1 = Find(@Scan(@Buff));
        if pType1 < nDict then
          StopWithSubject(@eDUPLICATE, @Buff);
        end

        word pStruct = DictAlloc();
        DictSetName(pStruct, @Buff);
        Dict[pStruct].Class = cTYPE;
        Dict[pStruct].Sub = sSTRUCT;

        if str_eq(@Scan(@Buff),";") then
          Stop(@eNOTAVAIL);
        end

        do
          word pType = Find(@Buff);
          if pType >= nDict then
            Stop(@eTYPEEXP);
          else
            if Dict[pType].Class!=cTYPE then
              Stop(@eTYPEEXP);
            end
          end

          do
            word  nPtr=0;
            while str_eq(@Scan(@Buff),"@") do
              inc nPtr;
            end

            if pType==st_void & nPtr<1 then
              Stop(@eNOVOID);
            end

            if pType==pStruct & nPtr<1 then
              Stop(@eNODATA);
            end

            if Dict[pType].Sub==sFUNCTYPE & nPtr<1 then
              Stop(@eNOVAL);
            end

            word F = FindInNamespace(@Buff, pStruct);
            when F < nDICT:
              StopWithSubject(@eDUPLICATE, @Buff);

            F = DictAlloc();
            DictSetName(F, @Buff);
            Dict[F].Class = cFIELD;
            Dict[F].pType = T_nPtrTo(nPtr, pType);
            //Dict[F].nIndx = Tabl(@Scan(@Buff));
            Dict[F].pType = Tabl_(@Scan(@Buff), Dict[F].pType);
            DictAddToNamespace(F, pStruct);

            if str_eq(@Buff,";") then
              Scan(@Buff);
              exit;
            end

            if str_eq(@Buff,"end") then
              exit;
            end

            if str_ne(@Buff,",") then
              Stop(@eSEMICOLONEXP);
            end
          end

          if str_eq(@Buff,"end") then
            exit;
          end
        end

end

/*****************************************************************************/

void DeclSynonym(char @Buff)

	if Find(@Scan(@Buff)) < nDict then
		StopWithSubject(@eDUPLICATE, @Buff);
	end

	word D = DictAlloc();
	DictSetName(D, @Buff);
	Dict[D].Class = cNAME;

	word pType = Find(@Scan(@Buff));
	if pType >= nDict then
		Stop(@eUNDECLARED);
	end

	Dict[D].pType = pType;
end

/*****************************************************************************/

void DeclFunc1(char @Buff; word _pFunc; word pForward)

	pFunc=_pFunc;

	Dict[pFunc].Class = cFUNC;
	Dict[pFunc].Sub   = sFUNC;
	FuncArgs(@Buff, pFunc);

	if pForward != nDICT then
		word T1 = T_FuncTypeForFunction(pFunc);
		word T2 = T_FuncTypeForFunction(pForward);
		if !T_IsFuctTypesIdentical(T1, T2) then
			Error(@eTYPE_FUNC_FWD);
		else
			DictFree(@pFunc);
			pFunc = pForward;
		end
	end:if

	Scan(@Buff);

	select
		case str_eq(@Buff,";"): /* Прототип. */
			Dict[pFunc].Forward = 1;

		case str_eq(@Buff,"external"): /* Внешняя функция. */
			select
				case TargetFileFormat == tPE:
					null;
				default:
					Stop(@eNOTALLOWED);
			end

			/* Читаем имя библиотеки. Добавляем библиотеку в словарь, если она туда еще не занесена. */
			word pLib = Find(@Scan(@Buff));
			if   pLib >= nDict then

				pLib = DictAlloc();

				DictSetName(pLib, @Buff);
				Dict[pLib].Class = cLIB;

			end:if


			/*
				Если для функции в библиотеке указано имя, отличное от объявленного имени функции,
				объявленное имя делаем алиасом для библиотечного имени.
				FIXME: Переделать! Библиотечное имя не должно присутствовать в пространстве имён модуля.
			*/
			if str_eq(@Scan(@Buff),".") then
				if Find(@Scan(@Buff)) < nDict then
					StopWithSubject(@eDUPLICATE, @Buff);
				end:if

				word pAlias = DictAlloc();

				DictSetName(pAlias, @DictGetName(pFunc));
				Dict[pAlias].Class = cNAME;
				Dict[pAlias].pType = pFunc;

				DictSetName(pFunc, @Buff);
				Scan(@Buff);

			end:if

			Dict[pFunc].Sub   = sSYS;
			Dict[pFunc].pNode = pLib;

			if str_ne(@Buff,";") then
				Stop(@eSEMICOLONEXP);
			end:if

		default: /* Тело функции. */
			word Saved_nLocal = nLocal;
			Dict[pFunc].pNode = Statements(@Buff, "end", NULL, NULL);
			nLocal = Saved_nLocal;

			CTE_Function(pFunc);

	end:select

end

/*****************************************************************************/

void DeclVarFuncType(char @Buff; word pType)

	Scan(@Buff);
	word nPtr = ReadPtrs(@Buff);

	if Find(@Buff) < nDict then
		StopWithSubject(@eDUPLICATE, @Buff);
	end

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cTYPE;
	Dict[D].Sub   = sFUNCTYPE;

	if str_ne(@Scan(@Buff),"(") then
		Stop(@eBRACKETEXP);
	end

	Dict[D].pType = T_nPtrTo(nPtr, pType);
	FuncArgs(@Buff, D);

	/*if (str_ne(@Scan(@Buff),";")) then
		Stop(@eSEMICOLONEXP);
	end*/

end

/*****************************************************************************/

void DeclVarFunc(char @Buff)

	word pPrefixType = Find(@Buff);
	if pPrefixType >= nDict | Dict[pPrefixType].Class != cTYPE then
		Stop(@eTYPEEXP);
	end

	/* Функтор-тип. */
	if str_eq(@Scan(@Buff),"function") then
		DeclVarFuncType(@Buff, pPrefixType);
		return;
	end


	word FirstName = 1;

	do
		word nPtr = ReadPtrs(@Buff);

		word pForward = Find(@Buff);
		if pForward < nDict then
			when !Dict_IsFunction(pForward):
				StopWithSubject(@eDUPLICATE, @Buff);
			when Dict[pForward].Forward == 0:
				StopWithSubject(@eDUPLICATE, @Buff);
		end

		word D = DictAlloc();

		DictSetName(D, @Buff);
		Dict[D].pType = T_nPtrTo(nPtr, pPrefixType);

		Scan(@Buff);

		/* Функция. */
		if str_eq(@Buff,"(") then
			if FirstName == 0 then
				Stop(@eNOFUNCTION);
			end
			DeclFunc1(@Buff, D, pForward);
			return;
		end

		when pForward < nDict:
			StopWithSubject(@eDUPLICATE, @DictGetName(D));

		FirstName = 0;

		if Dict[D].pType == st_void then
			Stop(@eNOVOID);
		end

		if Dict[Dict[D].pType].Sub == sFUNCTYPE then
			Stop(@eNOVAL);
		end

		Dict[D]. Class=cDATA;
		//Dict[D].nIndx = Tabl(@Buff);
		Dict[D].pType = Tabl_(@Buff, Dict[D].pType);
		Dict[D].pNode =nNODE;

		if str_eq(@Buff,"=") | str_eq(@Buff,":=") then
			/*if Dict[D].nIndx > 0 then
				Stop(@eNOTAVAIL);
			end*/

			word P1=Peek();
			word P2=Peek();
			Node[P1].ID    =iASSIGN;
			Node[P1].pLeft = P2;

			word P3=Peek();
			Node[P2].ID    =iEMPTY;
			Node[P2].pLeft = P3;
			Node[P2].pRight= Expr(PRIO_ZERO, @Scan(@Buff));

			Node[P3].ID    =iDATA;
			Node[P3].Value =D;

			ImplicitCast(Dict[D].pType, @Node[P2].pRight);

			Dict[D].pNode=P1;

		end

		if str_eq(@Buff,";") then
			exit;
		end

		if str_ne(@Buff,",") then
			Stop(@eSEMICOLONEXP);
		end

		Scan(@Buff);

	end:do

end

/*****************************************************************************/

word DeclDefine(char @Buff)

	word nPtr = ReadPtrs(@Scan(@Buff));

	if Find(@Buff) < nDict then
		StopWithSubject(@eDUPLICATE, @Buff);
	end

	word D = DictAlloc();

	DictSetName(D, @Buff);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;

	Scan(@Buff);
	select
		case nPtr==0:

			word P = Expr(PRIO_ZERO, @Buff);

			select
				case Node[P].ID==iLITERAL:
					Dict[D].pType = Node[P].pType;
					Dict[D].LiteralValue = Node[P].Value;

				default:
					Stop(@eTYPE);
			end:select

			if str_eq(@Buff,";") then
				Scan(@Buff);
			end:if

			return 1;

		default:
			if str_ne(@Buff,"~"") then
				Stop(@eQUOTEXP);
			end
			ScanString(D);
	end:select

	return 0;
end

/*****************************************************************************/

word DeclInclude(char @Buff)

	/* Читаем имя файла. */

	if str_ne(@Scan(@Buff),"~"") then
		Stop(@eQUOTEXP);
	end

	word P=0;
	while Read()!='"' do
		if iswhitespace(Read()) != 0 then
			Stop(@eQUOTEXP);
		end

		Buff[P]=Read();
		inc  P;

		if P >= nBUFF then
			Stop(@eLONGNAME);
		end

		Next();
	end:while

	Buff[P]=#0;
	Next();

	char@ FileName = @ResolveFileName(@Buff);

	/* Проверка, подключался ли уже указанный файл. */
	P = Find_cFILE(@FileName);
	if P < nDict then
		return 0;
	end:if

	/* Заносим имя файла в словарь. */
	word D = DictAlloc();
	DictSetName(D, @FileName);
	Dict[D].Class = cFILE;

	IncludeFile(@FileName);

	return 0;
end

/*****************************************************************************/

void Parse()

	char Buff[nBUFF];
	Scan(@Buff);

	do
		word R = 0;
		select
		case str_eq(@Buff,"begin"):         // Главная функция
			DeclMainFunc(@Buff);
			exit;
		case str_eq(@Buff,"include"):       // Включаемый файл
			R = DeclInclude(@Buff);
		case str_eq(@Buff,"define"):        // Константа
			R = DeclDefine(@Buff);
		case str_eq(@Buff,"struct"):        // Стpуктуpа
			DeclStruct(@Buff);
		case str_eq(@Buff,"synonym"):       // Синоним
			DeclSynonym(@Buff);
		case str_eq(@Buff,"$qod.strong"):
			Stop(@eQODSTRONGNOTIMPL);
		case str_eq(@Buff,"$qod.strong.transitional"):
			null;
		case str_eq(@Buff,"$context2"):
			Warn(@wDEPRECATED);
		default:                            // Пеpеменная, функция, ...
			DeclVarFunc(@Buff);
		end:select

		if R == 0 then
			Scan(@Buff);
		end

	end:do

end

/*****************************************************************************/

