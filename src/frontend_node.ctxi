

/*****************************************************************************/

NODE     Node [nNODE]; // Массив узлов синтаксического деpева
word    nNode;

/*****************************************************************************/

/* Выделить узел и вернуть его индекс. */
word Peek()
	word N  = nNode;
	when N >= nNODE:
		StopMemory();

	Node[nNode].Used = 0;
	Node[nNode].pLeft  = nNODE;
	Node[nNode].pRight = nNODE;
	Node[nNode].pType  = nDICT;
	Node[nNode].SourceLocation = CurrentFileInfo;
	inc  nNode;

	return N;
end

/*****************************************************************************/

word NodeHasImmediateValue(word P)

	when P >= nNode:
		StopInternal(__FILE__, __LINE__);

	switch Node[P].ID of
	case iCHAR, iWORD, iINT:
		return 1;
	end

	return 0;
end

word NodeGetImmediateValue(word P)
	when NodeHasImmediateValue(P) != 0:
		return Node[P].Value;

	StopInternal(__FILE__, __LINE__);
	return 0;
end

void NodeSetImmediateValue(word P; word Value)
	when NodeHasImmediateValue(P) != 0:
		Node[P].Value = Value;

	StopInternal(__FILE__, __LINE__);
end

/*****************************************************************************/

bool NodeIsLValue(word P)
	/*
		FIXME: Incomplete implementation.
		Сначала требуется избавиться от постфиксных деревьев в Primary.
	*/
	when P >= nNode:
		StopInternal(__FILE__, __LINE__);

	switch Node[P].ID of
	case
		iEMPTY,
		iNULL,
		iCHAR,
		iWORD,
		iINT,
		iFUNC,
		iSTRING,
		iBIT_NOT,
		iNEG,
		iOR,
		iXOR,
		iEQV,
		iAND,
		iBIT_OR,
		iBIT_XOR,
		iBIT_AND,
		iLT,
		iLE,
		iEQ,
		iNE,
		iGE,
		iGT,
		iADD,
		iSUB,
		iMUL,
		iDIV,
		iMOD,
		iCAST,
		iBOOL,
		iNOT:
		return false;
	end
	return true;
end

/*****************************************************************************/

word NodeGetDict(word P)

	when P >= nNode:
		StopInternal(__FILE__, __LINE__);

	switch Node[P].ID of
	case iFUNC, iCALL, iCALL2, iSTRING, iDATA:
		return Node[P].Value;
	end

	StopInternal(__FILE__, __LINE__);
	return 0;
end

void NodeSetDict(word P; word D)

	when P >= nNode:
		StopInternal(__FILE__, __LINE__);

	switch Node[P].ID of
	case iFUNC, iCALL, iCALL2, iSTRING, iDATA:
		Node[P].Value = D;
	default:
		StopInternal(__FILE__, __LINE__);
	end
end

/*****************************************************************************/

word NodeTypeIs(word P; word T)
	when P >= nNode:
		StopInternal(__FILE__, __LINE__);
	when Node[P].pType == T:
		return 1;
	return 0;
end

/*****************************************************************************/

word NodeTypeIsPointerTo(word P; word T)
	when P >= nNode:
		StopInternal(__FILE__, __LINE__);
	when Node[P].pType == T_PtrTo(T):
		return 1;
	return 0;
end

/*****************************************************************************/

void WarnAtNode(word P; char @Msg)
	WarnAt(@Node[P].SourceLocation, @Msg);
end

void ErrorAtNode(word P; char @Msg)
	ErrorAt(@Node[P].SourceLocation, @Msg);
end

void StopAtNode(word P; char @Msg)
	StopAt(@Node[P].SourceLocation, @Msg);
end
