$comment DOCUMENTATION ********************************************************

word fpath_first_part(char@ S);
Возвращает индекс, слева от которого находится первый элемент файлового пути,
а справа (включая сам индекс) - все остальные. Если за первым элементом нет следующего,
возвращает индекс, указывающий на завершающий 0-символ.
Строка @S должна быть ненулевой длины, иначе функция вызывает assert exception.

word fpath_first_part(char@ S);
Возвращает индекс, справа от которого (включая сам индекс) находится последний элемент файлового пути,
а слева - все предыдущие. Если в строке только один элемент, возвращает индекс 0.
Строка @S должна быть ненулевой длины, иначе функция вызывает assert exception.

***************************************************************** DOCUMENTATION

include_once "strings.qdi";

/*****************************************************************************/

define MAX_FPATH 1024

/*****************************************************************************/

char@ fpath_p_dir_separator;  /* Основной используемый символ-разделитель элементов файлового пути (в виде 0-терминированной строки для удобства). */
char@ fpath_p_dir_separators; /* Все распознаваемые нами символы-разделители. */

/*****************************************************************************/

word fpath_first_part(char@ S)
	word L = strlen(@S);
	if L == 0 then
		/* FIXME: тут должен быть ассерт. */
		return 0;
	end:if
	
	word P = 0; /* Текущая позиция поиска разделителя. */
	
	forever do
		word P1 = str_find_chars_from(@S, @fpath_p_dir_separators, P); /*  Ищем следующий разделитель. */
		if P1 == L then /* Если конец строки, заканчиваем. */
			return P;
		end:if

		/*
			Если найденная позиция дальше, чем "прямо тут",
			значит P указывает на реальное начало элемента файлового пути.
		*/
		if P != P1 then
			exit;
		end:if
		/*
			Иначе мы имеем дело с последовательностью повторяющихся разделителей "//..",
			так что пробуем следующую позицию.
		*/
		P = P1 + 1;
	end:forever
	
	return P;
end

/*****************************************************************************/

word fpath_last_part(char@ S)
	word L = strlen(@S);
	if L == 0 then
		/* FIXME: тут должен быть ассерт. */
		return 0;
	end:if

	/* Частный случай для строки из одного символа, поскольку в цикле строка "/" не обработается корректно. */
	if L == 1 then
		if str_has_char(@fpath_p_dir_separators, S[0]) != 0 then /* Корневой каталог... */
			return 1;
		else
			return 0;
		end:if
	end:if
	
	word P = L - 1;
	word P1;
	forever do
		P1 = str_rfind_chars_from(@S, @fpath_p_dir_separators, P); /*  Ищем следующий разделитель. */
		if P == INDEX_INVALID then /* Если всю строку просканировали, заканчиваем. */
			return 0;
		end:if
		
		/*
			Если найденная позиция дальше, чем "прямо тут",
			значит P1 нашло то, что надо.
		*/
		if P != P1 then
			exit;
		end:if
		/*
			Иначе мы имеем дело с последовательностью повторяющихся разделителей "//.." в конце строки,
			так что пробуем следующую позицию.
		*/
		P = P1 - 1;
	end:forever
	
	return P1 + 1;
	
end

/*****************************************************************************/

char @fpath_cat(char @Dst, @Src)

	/* Присобачиваем разделитель, если его еще нет в конце строки @Dst. */
	word L = strlen(@Dst);
	if L > 1 then
		if str_has_char(@fpath_p_dir_separators, Dst[L - 1]) == 0 then
			strcat(@Dst, @fpath_p_dir_separator);
		end:if
	end:if

	/* Пропускаем лишние разделители в начале строки @Src. */
	while str_has_char(@fpath_p_dir_separators, Src[0]) != 0 do
		@Src = @Src[1];
	end:while
	
	strcat(@Dst, @Src);
	return @Dst;
end

/*****************************************************************************/

char @fpathn_cat(char @Dst, @Src; word Size)

	/* Присобачиваем разделитель, если его еще нет в конце строки @Dst. */
	word L = strlen(@Dst);
	if L > 1 then
		if str_has_char(@fpath_p_dir_separators, Dst[L - 1]) == 0 then
			strn_cat(@Dst, @fpath_p_dir_separator, Size);
		end:if
	end:if

	/* Пропускаем лишние разделители в начале строки @Src. */
	while str_has_char(@fpath_p_dir_separators, Src[0]) != 0 do
		@Src = @Src[1];
	end:while
	
	strn_cat(@Dst, @Src, Size);
	return @Dst;
end

/*****************************************************************************/
