
/*****************************************************************************/

DICT     Dict [nDICT]; // Таблица имен
word    nDict;

/*****************************************************************************/

/* Индексы встроенных типов данных. */

word st_void;
word st_char;
word st_byte;
word st_word;
word st_int;
word st_bool;

/*****************************************************************************/

/*
	Проверяет достаточность памяти таблице Dict для выделения одного элемента.
	TODO: при нехватке памяти, перераспределять динамически.
*/
void DictMemCheck()
	when nDict >= nDICT:
		StopMemory();
end

/*****************************************************************************/

void DictSetName(word D; char@ Name)

	when D >= nDict:
		StopInternal();

	Dict[D].Name2    = SaveString0(@Name);
	Dict[D].NameHash = str_hash(@Name);
end

/*****************************************************************************/

char @DictGetName(word D)

	when D >= nDict:
		StopInternal();

	return @Char[Dict[D].Name2];
end

/*****************************************************************************/

/* Выделить запись в таблице глобальных имён и вернуть её индекс.  */
word DictAlloc()

	DictMemCheck();

	word r = nDict;
	inc nDict;

	Dict[r].Used = 0;
	Dict[r].pType = nDICT;
	Dict[r].tPtrToMe = nDICT;

	return r;

end

/*****************************************************************************/

/*
	Поиск объекта в словаре по имени.
	(Кроме объектов класса cFILE.)
*/
word Find(char @Name)
	word hash = str_hash(@Name);
	word P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash & strcmp(@DictGetName(P), @Name) = 0 & Dict[P].Class != cFILE then
			while Dict[P].Class = cNAME do
				P = Dict[P].pType;
			end

			exit;
		end

		inc P;
	end

	return P;
end

/*****************************************************************************/

/*
	Поиск объекта с классом cFILE в словаре по имени.
*/
word Find_cFILE(char @Name)
	word hash = str_hash(@Name);
	word  P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash & strcmp(@DictGetName(P), @Name) = 0 & Dict[P].Class = cFILE then
			exit;
		end

		inc P;
	end

	return P;
end

/*****************************************************************************/

/* Регистрирует ключевое слово. */
void Word(char @Name)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cWORD;
end

/*****************************************************************************/

/* Регистрирует базовый тип. */
word Base(char @Name; word Size)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cTYPE;
	Dict[p].Sub   = sBASE;
	Dict[p].Value = Size;
	return p;
end

/*****************************************************************************/

word DictDupLiteral(word D1)

	when D1 >= nDict:
		StopInternal();

	when Dict[D1].Class != cLITERAL:
		StopInternal();

	word D2 = DictAlloc();
	DictSetName(D2, "");
	Dict[D2].Class = Dict[D1].Class;
	Dict[D2].Sub   = Dict[D1].Sub;
	Dict[D2].pType = Dict[D1].pType;
	Dict[D2].nPtr  = Dict[D1].nPtr;
	Dict[D2].pIndx = Dict[D1].pIndx;
	Dict[D2].nIndx = Dict[D1].nIndx;
	Dict[D2].RO    = Dict[D1].RO;

	return D2;
end

/*****************************************************************************/

void DefineWord(char @Name; word Value)
	if Find(@Name) < nDict then
		StopInternal();
	end

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].nPtr = 0;
	Dict[D].pType = st_word;
	Dict[D].Value = Value;
end

/*****************************************************************************/

void DefineString(char @Name; char @Value)
	if Find(@Name) < nDict then
		StopInternal();
	end

	word i = strlen(@Value) + 1;

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].nPtr = 1;
	Dict[D].pType = st_char;
	Dict[D].pIndx = SaveString(@Value, i);
	Dict[D].nIndx = Dict[D].pIndx + i;
end

/*****************************************************************************/

word T_PtrTo(word T)
	when T >= nDict:
		StopInternal();
	when Dict[T].Class != cTYPE:
		StopInternal();

	if Dict[T].tPtrToMe >= nDICT then
		word PTR = DictAlloc();
		Dict[PTR].Class = cTYPE;
		Dict[PTR].Sub   = sPTR;
		Dict[PTR].Value = 4; /* FIXME */
		Dict[PTR].pType = T;
		Dict[T].tPtrToMe = PTR;
	end

	return Dict[T].tPtrToMe;
end

/*****************************************************************************/

word T_ArrayGetSize(word T)
	when T >= nDict:
		StopInternal();
	when Dict[T].Class != cTYPE | Dict[T].Sub != sARRAY:
		StopInternal();
	return Dict[T].Value;
end

word T_Array(word T; word S)
	word P = 0;
	while P < nDict do
		if Dict[P].Class = cTYPE
		 & Dict[P].Sub = sARRAY
		 & Dict[P].pType = T
		 & T_ArrayGetSize(P) = S then
			return P;
		end:if
		inc P;
	end:while

	P = DictAlloc();
	Dict[P].Class = cTYPE;
	Dict[P].Sub = sARRAY;
	Dict[P].pType = T;
	Dict[P].Value = S;
	return P;
end

/*****************************************************************************/
