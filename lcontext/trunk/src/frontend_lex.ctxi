
/* Лексический сканеp. */

/*****************************************************************************/

define nDIGRAPH 8

struct Digraph
	char Name[3];
end

Digraph Digraphs[nDIGRAPH];
word nDigraph;

/*****************************************************************************/

define nCOMMENT 2
define nCOMMENT_AFFIX 4
struct Comment
	char Prefix[nCOMMENT_AFFIX];
	char Suffix[nCOMMENT_AFFIX];
end

Comment Comments[nCOMMENT];
word nComment;

char@ HereCommentPrefix;

/*****************************************************************************/

/*
	Пропуск пробельных символов.
*/
void SkipWhitespaces()

	while iswhitespace(Read()) != 0 do
		Next();
	end
end

/*****************************************************************************/

/*
	Чтение одного символа для строковых/символьных литералов с обработкой escape-последовательностей.
*/
char ScanChar()
	char Ch = Read();
	Next();

	if Ch != '~~' then
		return Ch;
	end

	Ch = Read();
	select
		case Ch='n': Ch='~n';
		case Ch='r': Ch='~r';
		case Ch='t': Ch='~t';
		case Ch='0': Ch='~0';
	end
	Next();

	return Ch;
end

/*****************************************************************************/

/*
	Чтение строкового литерала с обработкой escape-последовательностей.
*/
void ScanString(word D)

	char Buff[nMAX_STR_LEN];

	word i = 0;
	do

		while Read()!='"' do
			if Read() = '~r' | Read() = '~n' then
				Stop(@eQUOTEXP);
			end

			if i >= nMAX_STR_LEN then
				Stop(@eNOMEMORY);
			end

			Buff[i] = ScanChar();
			inc  i;
		end:while

		Next();
		SkipWhitespaces();

		if Read() != '"' then
			exit;
		end
		Next();

	end:do

	if i >= nMAX_STR_LEN then
		Stop(@eNOMEMORY);
	end

	Buff[i] = #0;
	inc  i;

	Dict[D].pType = st_char;
	Dict[D].nPtr  = 1;
	Dict[D].pIndx = SaveString(@Buff, i);
	Dict[D].nIndx = Dict[D].pIndx + i;

end

/*****************************************************************************/

char@ ScanAlphaNum(char@ Buff)
	word P = 0;
	while isalpha(Read()) != 0 | isdigit(Read()) != 0 do
		Buff[P]=Read();
		inc  P;
		if   P >= nNAME then
			Stop(@eLONGNAME);
		end

		Next();
	end:while
	Buff[P] = #0;
	return @Buff;
end

/*****************************************************************************/

char @Scan1(char @Buff)

	SkipWhitespaces();

	if strlen(@ScanAlphaNum(@Buff)) != 0 then
		return @Buff;
	end

	word P = 0;

	Buff[P] = Read();
	inc P;
	Next();

	word i = 0;
	while i < nDigraph do
		if Buff[0] = Digraphs[i].Name[0] & Read() = Digraphs[i].Name[1] then
			Next();
			return @strcpy(@Buff, @Digraphs[i].Name);
		end:if
		inc i;
	end:while

	Buff[P] = #0;
	return  @Buff;
end

/*****************************************************************************/

char@ Scan(char@ Buff)

	do
		Scan1(@Buff);

		/* Обработка комментариев. */

		char@ Suffix = NULL; /* Признак конца комментария. */

		if @HereCommentPrefix != NULL & strcmp(@Buff, @HereCommentPrefix) = 0 then
			SkipWhitespaces();
			if strlen(@ScanAlphaNum(@Buff)) = 0 then
				Stop(@eEXPECTED);
			end
			@Suffix = @Buff;
		else
			word i = 0;
			while i < nComment do
				if strcmp(@Buff, @Comments[i].Prefix) = 0 then
					@Suffix = @Comments[i].Suffix;
				end:if
				inc i;
			end:while
		end:if

		if @Suffix = NULL then
			exit;
		end:if

		/* Пропускаем символы, пока не встретится Suffix. */
		word suffix_len = strlen(@Suffix);
		word k = 0;
		while k < suffix_len do
			select
			case Suffix[k] = Read():
				inc k;
			case Suffix[0] = Read():
				k = 1;
			default:
				k = 0;
			end:select
			Next();
		end:while
	end:do

	return @Buff;
end
/*****************************************************************************/

void RegisterDigraph(char@ Name)
	if strlen(@Name) != 2 then
		StopInternal();
	end

	strcpy(@Digraphs[nDigraph].Name, @Name);

	inc nDigraph;
end

/*****************************************************************************/

void RegisterHereCommentPrefix(char@ Prefix)
	@HereCommentPrefix = @Char[SaveString0(@Prefix)];
end

/*****************************************************************************/

void RegisterComment(char@ Prefix; char@ Suffix)
	if strlen(@Prefix) >= nCOMMENT_AFFIX then
		StopInternal();
	end

	if strlen(@Suffix) >= nCOMMENT_AFFIX then
		StopInternal();
	end

	strcpy(@Comments[nComment].Prefix, @Prefix);
	strcpy(@Comments[nComment].Suffix, @Suffix);

	inc nComment;
end

/*****************************************************************************/

void InitLex()
	nDigraph = 0;
	nComment = 0;
	@HereCommentPrefix = NULL;
end

/*****************************************************************************/
