
/*****************************************************************************/

word Code_OR(word P; word F; word T; word M; char @Buff)
	word L = LabelResolve(P, lBRANCH);
	if T=0 then
		_Code(Node[P].pLeft ,  0, M, L);
		EmitLabel(L);
		_Code(Node[P].pRight, F, 0, M);
	else
		_Code(Node[P].pLeft , 0, T, L);
		EmitLabel(L);
		_Code(Node[P].pRight, 0, T, M);
	end
end

/*****************************************************************************/

word Code_XOR(word P; word F; word T; word M; char @Buff)
	Stop(@eXORNOTIMPL);
end

/*****************************************************************************/

word Code_EQV(word P; word F; word T; word M; char @Buff)
	Stop(@eEQVNOTIMPL);
end

/*****************************************************************************/

word Code_AND(word P; word F; word T; word M; char @Buff)
	word L = LabelResolve(P, lBRANCH);
	if T=0 then
		_Code(Node[P].pLeft , F, 0, L);
		EmitLabel(L);
		_Code(Node[P].pRight, F, 0, M);
	else
		_Code(Node[P].pLeft , M, 0, L);
		EmitLabel(L);
		_Code(Node[P].pRight, 0, T, M);
	end
end

/*****************************************************************************/

word Code_PUSH(word P; word F; word T; word M; char @Buff)

	if Node[P].pRight<nNODE then
		_Code(Node[P].pRight,0,0,0);
	end

	/* Оптимизация прямой загрузки значения из переменной. */

	word P1 = Node[P].pLeft;

	if Node[P1].ID=iDATA
	 | Node[P1].ID=iPARM
	 | Node[P1].ID=iLOCAL then

		if Node[P1].pLeft < nNODE & Node[Node[P1].pLeft].ID=iLOAD then

			word pIndx;
			word nIndx;
			word pType;
			word nPtr;
			word  Ofs;
			word  RO;
			word ID=ExtractDataInfo(P1, @pType, @nPtr, @pIndx, @nIndx, @Ofs, @RO);

			/* FIXME: проверка pIndx >= nIndx не работает для локальных переменных, поскольку компилятор не сохраняет эту информацию >< */
//			if pIndx >= nIndx & SizeOfType(pType, nPtr) = 4 then
			if 1 >= 1 & SizeOfType(pType, nPtr) = 4 then
				strcpy(@Buff, "push    dword ");
				Emit(@CodeDataIX_offset(@Buff, ID, 0, Ofs));
				return nDICT;
			end:if
		end:if
	end:if


	/* Оптимизация прямой загрузки указателя на строку. */
	if Node[P1].ID=iSTRING then

		if Node[P1].pLeft != nNODE
		 & Node[Node[P1].pLeft].ID=iLPTR then

			word pIndx;
			word nIndx;
			word pType;
			word nPtr;
			word  Ofs;
			word  RO;
			word ID=ExtractDataInfo(P1, @pType, @nPtr, @pIndx, @nIndx, @Ofs, @RO);

			strcpy(@Buff, "push    ");

			char @s = "dword @@ROLITERALS+";
			when RO = 0:
				@s = "dword @@RWLITERALS+";
			Emit(@strcat(@strcat(@strcat(@Buff,@s),@str(Ofs)),""));

			return nDICT;
		end:if
	end:if


	/* Оптимизация прямой загрузки числа из регистра. */
	select
	case Node[P1].ID=iNULL:
		word RegC = PHO_FindRegWithConst(0);
		if RegC != PHO_REG_INVALID then
			strcpy(@Buff, "push    ");
			strcat(@Buff, @PHO_EncodeReg(RegC, 0xFFFF_FFFF));
			Emit(@Buff);
			return nDICT;
		end:if
	case Node[P1].ID=iWORD | Node[P1].ID=iINT:
		word RegC = PHO_FindRegWithConst(Node[P1].Value);
		if RegC != PHO_REG_INVALID then
			strcpy(@Buff, "push    ");
			strcat(@Buff, @PHO_EncodeReg(RegC, 0xFFFF_FFFF));
			Emit(@Buff);
			return nDICT;
		end:if
	end:select

	/* Оптимизация прямой загрузки числа. */
	if (Node[P1].ID=iWORD | Node[P1].ID=iINT) & Node[P1].Value != 0 then

		strcpy(@Buff, "push    dword ");
		strcat(@Buff, @str(Node[Node[P].pLeft].Value));
		Emit(@Buff);

		return nDICT;
	end:if

	/* Все остальные варианты... */

	fEAX=0;
	word pType = _Code(Node[P].pLeft,0,0,0);

	word Size = PointerSize;
	if pType<nDICT then
		Size=Dict[pType].Value;
	end

	select
	case Size=1:
		Emit("push    EAX");
	case Size=4:
		Emit("push    EAX");
	default:
		Emit(@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(DefaultInStackAlign(Size))));
		Emit("mov     ESI,  EAX");
		Emit("mov     EDI,  ESP");
		Emit("cld");
		Emit(@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
		Emit("rep     movsb");
	end:select
end

/*****************************************************************************/

word Code_RETURN(word P; word F; word T; word M; char @Buff)

	if Node[P].pLeft<nNODE then
		fEAX=0;
		word pType=_Code(Node[P].pLeft,0,0,0);
		word  Size=4;
		if pType<nDICT then
			Size=Dict[pType].Value;
		end:if

		if Size!=1 & Size!=4 then
			StopInternal();
		end:if
	end:if

	if Dict[pFunc].Sub = sMAIN then
		select
		case TargetFileFormat = tPE:
			Emit("xor     EAX,  EAX");
			Emit("push    EAX");
			Emit(@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Find("ExitProcess")].Value)),"]"));
		case TargetFileFormat = tELF:
			Emit("mov     EAX,  1");
			Emit("xor     EBX,  EBX");
			Emit("int     80H");
		default:
			StopInternal();
		end:select
	else
		if CompactFunctionEnterLeave != 0 then
			Emit("leave");
		else
			Emit("mov     ESP,  EBP");
			Emit("pop     EBP");
		end:if

		if pSize > 0 then
			Emit(@strcat(@strcpy(@Buff,"ret     "),@str(pSize)));
		else
			Emit("ret");
		end:if
	end:if

end

/*****************************************************************************/

word Code_SELECT(word P; word F; word T; word M; char @Buff)

	/*
	                 iSELECT
	                /       \
	              iCASE      [next statement]
	             /     \
	            iCOND   [next case]
	           /     \
	[condition]     iBODY
	               /    \
	         [body]     NULL
	*/

	word CASE = Node[P].pLeft;
	while CASE < nNODE do
		when Node[CASE].ID != iCASE:
			StopInternal();

		word COND = Node[CASE].pLeft;
		word BODY = Node[COND].pRight;

		when Node[BODY].ID != iBODY
		|    Node[COND].ID != iCOND:
			StopInternal();

		if Node[COND].pLeft < nNODE then
			_Code(Node[COND].pLeft,LabelResolve(CASE, lCASEBODYEND),0,LabelResolve(CASE, lCASEBODY));
			EmitLabel(LabelResolve(CASE, lCASEBODY));
		end

		Code_Block(Node[BODY].pLeft);

		if Node[CASE].pRight < nNODE then
			Emit(@strcat(@strcpy(@Buff,"jmp     @"),@str(LabelResolve(P, lEXIT))));
		end

		if Node[COND].pLeft < nNODE then
			EmitLabel(LabelResolve(CASE, lCASEBODYEND));
		end

		CASE = Node[CASE].pRight;
	end:while

	EmitLabel(LabelResolve(P, lEXIT));
end

/*****************************************************************************/

word Code_SWITCH(word P; word F; word T; word M; char @Buff)

	/*
	                 iSWITCH
	                /       \
	              iCOND      [next statement]
	             /     \
	 [expression]     iCASE
	                 /     \
	            iVALUE      [next case]
	           /      \
	    [value]       iVALUE
                    /      \
	         [value]       iBODY
	                      /     \
	                [body]       NULL


                      iCASE
	                 /     \
	          iDEFAULT      [next case]
	         /        \
	     NULL        iBODY
	                /     \
	          [body]       NULL


	*/

	word COND = Node[P].pLeft;
	when Node[COND].ID != iCOND:
		StopInternal();

	fEAX = 0;
	word pType = _Code(Node[COND].pLeft,0,0,0);
	if pType = st_byte then
		Emit("and     EAX,  0FFH");
	end:if

	word L_Default = LabelResolve(P, lEXIT);
	word offset = 0;

	word  CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		when Node[CASE_I].ID != iCASE:
			StopInternal();

		word  VALUE_I = Node[CASE_I].pLeft;
		while VALUE_I < nNode do
			switch Node[VALUE_I].ID of
			case iVALUE:
				word value = Node[Node[VALUE_I].pLeft].Value - offset;

				char@ Reg = "EAX";
				if pType = st_char then
					value = value & 0xFF;
					@Reg = "AL";
				end:if

				switch value of
				case 1:
					strcpy(@Buff, "dec    ");
					strcat(@Buff, @Reg);
					Emit(@Buff);
				case 2:
					strcpy(@Buff, "dec    ");
					strcat(@Buff, @Reg);
					Emit(@Buff);
					Emit(@Buff);
				default:
					strcpy(@Buff, "sub    ");
					strcat(@Buff, @Reg);
					strcat(@Buff, ", 0x");
					strcat(@Buff, @str2(value, 16));
					Emit(@Buff);
				end:switch

				offset = offset + value;

				Emit(@strcat(@strcpy  (@Buff,"je      @"),@str(LabelResolve(CASE_I, lCASEBODY))));

			case iDEFAULT:
				L_Default = LabelResolve(CASE_I, lCASEBODY);
			case iBODY:
				null;
			default:
				StopInternal();
			end:switch
			VALUE_I = Node[VALUE_I].pRight;
		end:while

		CASE_I = Node[CASE_I].pRight;
	end:while

	Emit(@strcat(@strcpy(@Buff,"jmp     @"),@str(L_Default)));

	CASE_I = Node[COND].pRight;
	while CASE_I < nNODE do
		when Node[CASE_I].ID != iCASE:
			StopInternal();

		word  VALUE_I = Node[CASE_I].pLeft;
		while VALUE_I < nNode do
			switch Node[VALUE_I].ID of
			case iVALUE, iDEFAULT:
				null;
			case iBODY:
				EmitLabel(LabelResolve(CASE_I, lCASEBODY));
				Code_Block(Node[VALUE_I].pLeft);
				Emit(@strcat(@strcpy(@Buff,"jmp     @"),@str(LabelResolve(P, lEXIT))));
			default:
				StopInternal();
			end:switch
			VALUE_I = Node[VALUE_I].pRight;
		end:while

		CASE_I = Node[CASE_I].pRight;
	end:while

	EmitLabel(LabelResolve(P, lEXIT));

end

/*****************************************************************************/

word Code_WHILE(word P; word F; word T; word M; char @Buff)

	/*
	                 iWHILE
	                /     \
	              iBODY    [next statement]
	             /    \
	  [loop body]    iHEAD
	                /    \
	[loop condition]      NULL
	*/

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternal();

	EmitLabel(LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		_Code(Node[COND].pLeft, LabelResolve(P, lEXIT), 0, LabelResolve(P, lLOOPBODY));
		EmitLabel(LabelResolve(P, lLOOPBODY));
	end

	Code_List(Node[BODY].pLeft);

	Emit(@strcat(@strcpy(@Buff, "jmp     @"), @str(LabelResolve(P, lCONTINUE))));
	EmitLabel(LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);
end

/*****************************************************************************/

word Code_REPEAT(word P; word F; word T; word M; char @Buff)

	/*
	                 iREPEAT
	                /      \
	              iBODY     [next statement]
	             /    \
	  [loop body]    iHEAD
	                /    \
	[loop condition]      NULL
	*/

	CODEBLOCK CB;
	Code_BeginBlock(@CB);

	word BODY = Node[P].pLeft;
	word COND = Node[BODY].pRight;

	when Node[BODY].ID != iBODY
	|    Node[COND].ID != iCOND:
		StopInternal();


	EmitLabel(LabelResolve(P, lLOOPBODY));

	Code_List(Node[BODY].pLeft);

	EmitLabel(LabelResolve(P, lCONTINUE));

	if Node[COND].pLeft < nNODE then
		_Code(Node[COND].pLeft, LabelResolve(P, lLOOPBODY), 0, LabelResolve(P, lEXIT));
	end

	EmitLabel(LabelResolve(P, lEXIT));

	Code_EndBlock(@CB);

end

/*****************************************************************************/

word Code_CONTINUE(word P; word F; word T; word M; char @Buff)
	Emit(@strcat(@strcpy(@Buff,"jmp     @"),@str(LabelResolve(Node[P].Value, lCONTINUE))));
end

/*****************************************************************************/

word Code_EXIT(word P; word F; word T; word M; char @Buff)
	Emit(@strcat(@strcpy(@Buff,"jmp     @"),@str(LabelResolve(Node[P].Value, lEXIT))));
end

/*****************************************************************************/
