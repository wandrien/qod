
/*
	Анализатор выражений.
*/

/*****************************************************************************/

/* Парсинг строки в целое число по указанному основанию. */
word val2(char @Str; word Base)
	if Str[0] = #0 then
		Stop(@eMALFORMEDINT);
	end

	if Base < 2 |  Base > 16 then
		Stop(@eINVALIDBASE);
	end

	word i = 0;

	word Value = 0;
	while Str[i] != #0 do

		while Str[i] = '_' do
			inc i;
		end

		word Digit;
		word ch = word(Str[i]);

		select
		case ch >= word('0') & ch <= word('9'):
			Digit = ch - word('0');
		case ch >= word('A') & ch <= word('F'):
			Digit = ch - word('A') + 10;
		case ch >= word('a') & ch <= word('f'):
			Digit = ch - word('a') + 10;
		default:
			Stop(@eWRONGCHAR);
		end:select

		/* TODO: детектить переполнение. */

		Value = Value * Base + Digit;

		inc i;
	end:while

	return Value;
end

/*****************************************************************************/

/* Парсинг строки в число. */
word val(char @Buff)
	word  Base;
	word  P;

	word k = str_find_chars(@Buff, "$");
	select
	/* Префиксы 0x - шестнадцатиричное. */
	case str_has_prefix(@Buff, "0x") != 0 :
		Base = 16;
		P    = 2;
	/* Символ $ не найден - десятичное. */
	case Buff[k] = #0:
		Base = 10;
		P    = 0;
	/* Символ $ в начале строки - шестнадцатиричное. */
	case k = 0:
		Warn(@wDEPRECATED);
		Base = 16;
		P    = 1;
	/* Символ $ в середине строки - слева от него основание в десятичном виде, справа - само число. */
	default:
		Buff[k] = #0;
		Base = val2(@Buff, 10);
		P    = k + 1;
		Buff[k] = '$';
	end:select

	return val2(@Buff[P], Base);
end

/*****************************************************************************/

word Tabl(char @Buff)
	word nIndx = 0;
	if strcmp(@Buff,"[")=0 then
		word P = _Expr(pZERO, @Scan(@Buff));

		when Node[P].ID!=iWORD:
			Stop(@eTYPE);

		nIndx = NodeGetImmediateValue(P);

		when strcmp(@Buff,"]")!=0:
			Stop(@eBRACKETEXP);
	    Scan(@Buff);
	end:if

	return nIndx;
end

/*****************************************************************************/

/* Читает строковой литерал и создаёт синтаксический узел для него. */

word StringNode()
	word D = DictAlloc();
	Dict[D].Class = cLITERAL;
	Dict[D].RO = ROStrings;
	DictSetName(D, "");
	ScanString(D);

	word P = Peek();
	Node[P].ID    = iSTRING;
	NodeSetDict(P, D);

	return P;
end

/*****************************************************************************/

/* Парсит последовательность операций разыменования указателя, возвращает количество операций. */

word ReadPtrs(char @Buff)
	word nPtr=0;
	while strcmp(@Buff,"@")=0 do
		inc nPtr;
		Scan(@Buff);
	end
	return nPtr;
end

/*****************************************************************************/

void FuncArgs(char @Buff; word pFunc)
	word pARGS = DictAlloc();
	DictSetName(pARGS, "args");
	Dict[pARGS].Class = cARGS;
	DictAddToNamespace(pARGS, pFunc);

	Scan(@Buff);
	while strcmp(@Buff,")")!=0 do
		word pType = Find(@Buff);
		when pType >= nDICT | Dict[pType].Class != cTYPE:
			Stop(@eTYPEEXP);

		do
			Scan(@Buff);
			word  nPtr=ReadPtrs(@Buff);

			when pType=st_void & nPtr<1:
				Stop(@eNOVOID);
			when Dict[pType].Sub=sFUNCTYPE & nPtr<1:
				Stop(@eNOVAL);

			word pARG = FindInNamespace(@Buff, pARGS);
			when pARG < nDICT:
				Stop(@eDUPLICATE);

			pARG = DictAlloc();
			DictSetName(pARG, @Buff);
			Dict[pARG].Class = cARG;
			Dict[pARG].pType = pType;
			Dict[pARG].nPtr  = nPtr;
			DictAddToNamespace(pARG, pARGS);

			when strcmp(@Scan(@Buff),",")!=0:
				exit;
		end

		if strcmp(@Buff,")")!=0 then
			when strcmp(@Buff,";")!=0:
				Stop(@eSEMICOLONEXP);
			when strcmp(@Scan(@Buff),")")=0:
				Stop(@eTYPEEXP);
		end

	end:while

end

/*****************************************************************************/

include "frontend_syn_cte.ctxi"
include "frontend_syn_cast.ctxi"

/*****************************************************************************/

/*
	Вычисление логического НЕ преобразованием исходной форумулы.

	FIXME: Эта функция должна быть частью подсистемы CTE.
*/

void Not(word P)
	switch Node[P].ID of
	case iOR:   Node[P].ID = iAND; Not(Node[P].pLeft); Not(Node[P].pRight);
	case iAND:  Node[P].ID = iOR;  Not(Node[P].pLeft); Not(Node[P].pRight);
	case iXOR:  Node[P].ID = iEQV;
	case iEQV:  Node[P].ID = iXOR;
	case iLT:   Node[P].ID = iGE;
	case iLE:   Node[P].ID = iGT;
	case iEQ:   Node[P].ID = iNE;
	case iNE:   Node[P].ID = iEQ;
	case iGE:   Node[P].ID = iLT;
	case iGT:   Node[P].ID = iLE;
	default:    StopInternal();
	end:switch
end

/*****************************************************************************/

void ParseCallArgs(word pFunc; word @P7; char @Buff)
	word pARGS = FindInNamespace("args", pFunc);
	when pARGS >= nDICT:
		StopInternal();
	word pARG = Dict[pARGS].pFirst;

	while pARG < nDICT do
		word P8=Peek();
		Node[P8].ID   =iPUSH;
		Node[P8].pLeft=_Expr(pZERO, @Buff);

		ImplicitCast(Dict[pARG].pType, Dict[pARG].nPtr, @Node[P8].pLeft);

		P7 = P8;
		@P7=@Node[P8].pRight;

		pARG = Dict[pARG].pNext;

		if  pARG < nDICT then
			when strcmp(@Buff,",")!=0:
				Stop(@eCOMMAEXP);
			Scan(@Buff);
		end:if

	end:while

	when strcmp(@Buff,")")!=0:
		Stop(@eBRACKETEXP);

end

/*****************************************************************************/

word Primary(word Prty; char @Buff)

	word pType;
	word nPtr;

	if isdigit(Buff)!=0 then /* Число. */
		word P1 = Peek();
		Node[P1].ID    = iWORD;
		Node[P1].Value = val (@Buff);
		pType          = st_word;
		nPtr           = 0;
		Node[P1].pType = pType;
		Node[P1].nPtr  = nPtr;
		Scan(@Buff);
		return P1;
	end

	word Flag=0;
	word Call=0;
	word P1;

	nPtr = ReadPtrs(@Buff);

	word nPtr1=0;
	word nIndx=0;

	if Flag=0 then /* Это строка? */
		if strcmp(@Buff,"~"")=0 then
			if nPtr>0 then
				Stop(@eSTRING);
			end

			P1    = StringNode();
			nPtr  = 1;
			pType = st_char;
			Flag  = 1;
		end:if
	end:if

	if Flag=0 then /* Это локальная переменная? */
		word I = ResolveLocal(@Buff);
		if I < nLOCAL then
			P1=Peek();
			Node[P1].ID    =iLOCAL;
			Node[P1].Value = I;
			pType          = Local[I].pType;
			nPtr1          = Local[I].nPtr;
			nIndx          = Local[I].nIndx;
			Flag           = 1;
		end:if
	end:if

	if Flag=0 then /* Это параметр функции? */
		word I = ResolveParm(@Buff);
		if I < nDICT then
			P1=Peek();
			Node[P1].ID    =iPARM;
			Node[P1].Value = I;
			pType          = Dict[I].pType;
			nPtr1          = Dict[I].nPtr;
			Flag           = 1;
		end:if
	end:if

	if Flag=0 then /* Значит это глобальное имя. */
		word I=Find(@Buff);
		if I>=nDict then
			Stop(@eUNDEFINED);
		end:if

		select
		case Dict[I].Class=cLITERAL: /* Именованный литерал? */
			P1=Peek();
			select
			case Dict[I].pType=st_word & Dict[I].nPtr=0:
				Node[P1].ID    =iWORD;
				Node[P1].Value = Dict[I].Value;

			case Dict[I].pType=st_int & Dict[I].nPtr=0:
				Node[P1].ID    =iINT;
				Node[P1].Value = Dict[I].Value;

			case Dict[I].pType=st_char & Dict[I].nPtr=0:
				Node[P1].ID    =iCHAR;
				Node[P1].Value = Dict[I].Value;

			case Dict[I].pType=st_char & Dict[I].nPtr=1:
				Node[P1].ID    =iSTRING;
				if ROStrings != 0 then
					Node[P1].Value = I;
				else
					word NewLiteral = DictDupLiteral(I);
					Dict[NewLiteral].RO = 0;
					Node[P1].Value = NewLiteral;
				end
			default:
				StopInternal();
			end:select

			pType          = Dict[I].pType;

		case Dict[I].Class=cDATA | Dict[I].Class=cFUNC: /* Глобальная переменная/функция? */
			P1=Peek();
			Node[P1].ID    =iDATA;
			Node[P1].Value = I;
			pType          = Dict[I].pType;
			nPtr1          = Dict[I].nPtr;

			if Dict[I].Class=cFUNC then
				if strcmp(@Scan(@Buff),"(")=0 then
					word P2=Peek();
					Node[P1].pLeft = P2;
					Node[P2].ID    =iCALL;
					Node[P2].Value = I;
					Call           = 1;

					Scan(@Buff);

					ParseCallArgs(I, @Node[P2].pLeft, @Buff);
				else
					if Prty>=pINC | nPtr!=1 then
						Stop(@eNOADDR);
					end

					Node[P1].ID    =iFUNC;
					Node[P1].Value = I;
					pType          = T_FuncTypeForFunction(I);
					Node[P1].pType = pType;
					Node[P1].nPtr  = nPtr;

					return P1;
				end:if
			else
				nIndx            = Dict[I].nIndx;
			end:if

		case Dict[I].Class=cTYPE: /* Тип данных? */
			if Prty<pLVALUE then
				if strcmp(@Scan(@Buff),"(")!=0 then
					Stop(@eBRACKETEXP);
				end:if

				P1             = Peek();
				word P2        = Peek();
				Node[P1]. ID   =iCAST;
				Node[P1]. Value= I;
				Node[P1].pLeft = P2;

				Node[P2]. ID   = iEMPTY;
				Node[P2].pLeft = _Expr(pZERO, @Scan(@Buff));
				pType = Node[Node[P2].pLeft].pType;
				nPtr1 = Node[Node[P2].pLeft].nPtr;

				if strcmp(@Buff,")")!=0 then
					Stop(@eBRACKETEXP);
				end:if

				if CanExplicitCast(I, nPtr, pType, nPtr1) != 0 then
					pType=I;
				else
					Stop(@eTYPE);
				end:if
			else
				if nPtr>0 then
					Stop(@eUNDEFINED);
				end:if

				return nNODE;
			end:if
		default:
			Stop(@eUNDEFINED);
		end:select
	end:if


	/*
		В этом месте имеем следующие поля:
		P1 - (логически) дочерний узел
		pType, nPtr1, nIndx - тип дочернего узла: собственно тип, количество уровней @-косвенности, размерность массива.
		nPtr - количество операций @ перед узлом.
	*/

	word @P2=@Node[P1].pLeft;
	if Node[P1].pLeft<nNODE then
		@P2=@Node[Node[P1].pLeft].pRight;
	end:if

	do
		Scan(@Buff);
		if strcmp(@Buff,"[")=0 & nIndx > 0 then /* Индексация массива. */
			word P3=Peek();
			Node[P3].ID   =iINDEX;
			Node[P3].Value= nIndx;
			Node[P3].pLeft= _Expr(pZERO, @Scan(@Buff));
			nIndx = 0;

			if strcmp(@Buff,"]")!=0 then
				Stop(@eBRACKETEXP);
			end:if

			ImplicitCast(st_word, 0, @Node[P3].pLeft);

			P2 = P3;
			@P2=@Node[P3].pRight;

			Scan(@Buff);
		end:if

		while strcmp(@Buff,"[")=0 do /* Индексация указателя. */
			if nPtr1<1 then
				Stop(@eNOADDR);
			end:if

			word P3=Peek();
			Node[P3].ID   =iADDR;
			Node[P3].pLeft= _Expr(pZERO, @Scan(@Buff));

			if strcmp(@Buff,"]")!=0 then
				Stop(@eBRACKETEXP);
			end:if

			ImplicitCast(st_word, 0, @Node[P3].pLeft);

			P2 = P3;
			@P2=@Node[P3].pRight;

			dec nPtr1;
			Call=   0;

			Scan(@Buff);
		end:while

		select
		case strcmp(@Buff,"(")=0: /* Вызов функтора. */
			if Dict[pType].Sub!=sFUNCTYPE then
				Stop(@eHEADEREXP);
			end

			while nPtr1>0 do
				word P3=Peek();
				Node[P3].ID   =iADDR;

				P2 = P3;
				@P2=@Node[P3].pRight;

				dec nPtr1;
				Call=   0;
			end:while

			word  P3        = Peek();
			Node [P3].ID    =iLPTR;
			P2              = P3;

			word  P4        = Peek();
			Node [P4].ID    =iDATA;

			word  P5        = Peek();
			Node [P5].ID    =iCALL2;
			Node [P5].Value =pType;

			Node [P4].pLeft = P5;

			word  P6        = Peek();
			Node [P6].ID    =iEMPTY;
			Node [P6].pLeft = P1;

			Node [P5].pLeft = P6;

			Scan(@Buff);

			ParseCallArgs(pType, @Node[P6].pRight, @Buff);

			word pType0     =pType;
			pType           = Dict[pType0].pType;
			nPtr1           = Dict[pType0].nPtr;
			nIndx           = 0;
			Call            = 1;

			P1 = P4;
			@P2=@Node[P5].pRight;

		case strcmp(@Buff,".")=0: /* Обращение к полю структуры. */
			if Dict[pType].Sub!=sSTRUCT then
				Stop(@eSTRUCTEXP);
			end:if

			while nPtr1>0 do
				word P3=Peek();
				Node[P3].ID   =iADDR;

				P2 = P3;
				@P2=@Node[P3].pRight;

				dec nPtr1;
				Call=   0;
			end:while

			if Call!=0 then
				Stop(@eNOTAVAIL);
			end:if

			Scan(@Buff);

			word F = FindInNamespace(@Buff, pType);
			when F >= nDICT:
				Stop(@eUNDEFINED);
			when Dict[F].Class != cFIELD:
				StopInternal();

			word P3=Peek();
			Node[P3].ID   =iFIELD;
			Node[P3].Value= F;
			pType         = Dict[F].pType;
			nPtr1         = Dict[F].nPtr;
			nIndx         = Dict[F].nIndx;
			Call          = 0;

			P2 = P3;
			@P2=@Node[P3].pRight;

		default:
			exit;
		end:select
	end:do

	if Prty>=pLVALUE & strcmp(@Buff,"=")!=0 & strcmp(@Buff,":=")!=0 then
		if Call=0 | nPtr>0 then
			Stop(@eASSIGNEXP);
		end:if

		nPtr1=0;
	end:if

	word P4=nNODE;
	if Prty<pINC then
		if nPtr>nPtr1+1 then
			Stop(@eNOADDR);
		end:if

		P4=Peek();
		if nPtr>nPtr1 then
			Node[P4].ID=iLPTR;
		else
			Node[P4].ID=iLOAD;
		end:if
	else
		if (nPtr>nPtr1)
		 | (Node[P1].ID=iCHAR)
		 | (Node[P1].ID=iWORD)
		 | (Node[P1].ID=iSTRING)
		 | (nPtr>=nPtr1 & Call!=0 & (strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0)) then
			Stop(@eNOADDR);
		end:if
	end:if

	while nPtr1>nPtr do
		word P3=Peek();
		Node[P3].ID   =iADDR;

		P2 = P3;
		@P2=@Node[P3].pRight;

		dec nPtr1;
	end:while

	P2  =P4;

	Node[P1].pType = pType;
	Node[P1].nPtr  = nPtr;

	return P1;

end

/*****************************************************************************/

void Cast2(word @P1, @pType, @nPtr; word @P2, @pType2, @nPtr2; word @ID; char @Buff)

	if nPtr=0 & nPtr2=0 then
		if pType2!=pType then /* Преобразование целочисленных типов к одному типу. */
			select
			case pType=st_byte & pType2=st_word:
				AddCast(pType2,pType,@Node[P2].pLeft);
				pType=pType2;

			case pType=st_byte & pType2=st_int:
				AddCast(pType2,pType,@Node[P2].pLeft);
				pType=pType2;

			case pType=st_word & pType2=st_byte:
				AddCast(pType,pType2,@Node[P2].pRight);

			case pType=st_word & pType2=st_int:
				AddCast(pType2,pType,@Node[P2].pLeft);
				pType=pType2;

			case pType=st_int & pType2=st_byte:
				AddCast(pType,pType2,@Node[P2].pRight);

			case pType=st_int & pType2=st_word:
				AddCast(pType,pType2,@Node[P2].pRight);

			default:
				Stop(@eTYPE);
			end:select
		end:if
	else
		/* Если один из типов указатель, 1) а второй - нет; или 2) справа не NULL... */
		if nPtr=0 | Node[Node[P2].pRight].ID!=iNULL then
			Stop(@eTYPE);
		end:if
	end:if

	select
	case nPtr>0: /* Между указателями возможны только операции сравнения на равенство и неравенство. */
		if ID!=iEQ & ID!=iNE then
			Stop(@eTYPE);
		end

		pType = st_bool;
		nPtr  = 0;

	case ID=iOR: /* операция ИЛИ возможна либо между беззнаковыми целыми, либо между булевыми значениями (тип "отсутствие типа"). */
		select
		case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_OR;
		case pType != st_bool:
			Stop(@eTYPE);
		end

	case ID=iXOR: /* Аналогично предыдущему. */
		select
		case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_XOR;
		case pType = st_bool:
			Stop(@eXORNOTIMPL);
		default:
			Stop(@eTYPE);
		end

	case ID=iAND: /* Аналогично предыдущему. */
		select
			case pType=st_byte | pType=st_word:
			Node[P2].ID=iBIT_AND;
		case pType != st_bool:
			Stop(@eTYPE);
		end

	case iLT<=ID & ID<=iGT: /* Сравнения возможны только между целыми и символами (case с указателями был выше) */
		if pType!=st_char & pType!=st_byte & pType!=st_word & pType!=st_int then
			Stop(@eTYPE);
		end

		pType = st_bool;

	case iADD<=ID & ID<=iDIV:
		if pType!=st_byte & pType!=st_word & pType!=st_int then /* Арифметические операции только с целыми. */
			Stop(@eTYPE);
		end

		CTE1(@P1, @pType, @nPtr, @P2, @pType2, @nPtr2, @ID);

	case ID=iMOD:
		if pType!=st_byte & pType!=st_word then
			Stop(@eTYPE);
		end

		CTE2(@P1, @pType, @nPtr, @P2, @pType2, @nPtr2, @ID);

	default:
		StopInternal();
	end:select

end

/*****************************************************************************/

word Expr(word Prio; char @Buff)

	word P1;
	word O;

	O = FindOperator(@Buff, Prio, OPERATOR_UPRE);
	if O = OPERATOR_INVALID then
		P1 = Primary(Prio, @Buff);
	else
		P1 = Operator[O].Handler(nNODE, O, @Buff);
	end:if

	do
		O = FindOperator(@Buff, Prio, OPERATOR_BLEFT);
		if O = OPERATOR_INVALID then
			exit;
		end

		P1 = Operator[O].Handler(P1, O, @Buff);
	end:do

	return P1;
end

/*****************************************************************************/

word Expr1(word P1; word O; char @Buff)

	word P2 = Peek();
	Node[P2].ID = Operator[O].ID;

	word ID = Operator[O].ID;

	word pType;
	word nPtr;

	if P1 >= nNODE then
		Node[P2].pLeft  = _Expr(Operator[O].Prio, @Scan(@Buff));
		pType = Node[Node[P2].pLeft].pType;
		nPtr  = Node[Node[P2].pLeft].nPtr;
		//Cast1(@P, @pType, @nPtr);
	else
		pType = Node[P1].pType;
		nPtr  = Node[P1].nPtr;
		Node[P2].pLeft  = P1;
		Node[P2].pRight = _Expr(Operator[O].Prio, @Scan(@Buff));
		word pType2 = Node[Node[P2].pRight].pType;
		word nPtr2  = Node[Node[P2].pRight].nPtr;
		Cast2(@P1, @pType, @nPtr, @P2, @pType2, @nPtr2, @ID, @Buff);
	end:if

	Node[P2].pType = pType;
	Node[P2].nPtr  = nPtr;

	return P2;
end

/*****************************************************************************/

word Expr2(word P1; word O;  char @Buff)

	word P2 = _Expr(pZERO, @Scan(@Buff));
	if strcmp(@Buff,")")!=0 then
		Stop(@eBRACKETEXP);
	end
	Scan(@Buff);
	return P2;
end

/*****************************************************************************/

word ExprLitChar(word P_; word O; char @Buff)

	word P1=Peek();

	select
	case strcmp(@Buff,"#")=0: /* Символ в #-виде. */
		word N=val(@Scan(@Buff));
		if   N>255 then
			Stop(@eOVERFLOW);
		end

		Node[P1].ID    =iCHAR;
		Node[P1].Value = N;
		Node[P1].pType = st_char;
		Node[P1].nPtr  = 0;

	case strcmp(@Buff,"'")=0: /* Символ. */
		Node[P1].ID    =iCHAR;
		Node[P1].Value = word(ScanChar());
		Node[P1].pType = st_char;
		Node[P1].nPtr  = 0;

		if Read()!='~'' then
			Stop(@eQUOTEXP);
		end
		Next();
	default:
		StopInternal();
	end:select

	Scan(@Buff);

	return P1;
end

word ExprLitNULL(word P_; word O; char @Buff)
	word P1=Peek();
	Node[P1].ID = iNULL;
	Node[P1].pType = st_void;
	Node[P1].nPtr = 1;
	Scan(@Buff);
	return P1;
end

word ExprLitFALSE(word P_; word O; char @Buff)
	word P1 = Peek();
	Node[P1].ID    = iBOOL;
	Node[P1].Value = 0;
	Node[P1].pType = st_bool;
	Node[P1].nPtr  = 0;
	Scan(@Buff);
	return P1;
end

word ExprLitTRUE(word P_; word O; char @Buff)
	word P1 = Peek();
	Node[P1].ID    = iBOOL;
	Node[P1].Value = 1;
	Node[P1].pType = st_bool;
	Node[P1].nPtr  = 0;
	Scan(@Buff);
	return P1;
end

/*****************************************************************************/

word ExprNOT(word P_; word O; char @Buff)

	word P1;

	word P2=_Expr(Operator[O].Prio, @Scan(@Buff));
	word pType = Node[P2].pType;
	word nPtr  = Node[P2].nPtr;

	if pType<nDICT & nPtr>0 then
		 Stop(@eTYPE);
	end

	select
	case pType=st_byte | pType=st_word:
		P1=Peek();
		Node[P1].ID    =iNOT;
		Node[P1].pLeft = P2;

	case pType = st_bool:
		Not(P2);
		P1= P2;

	default:
		Stop(@eTYPE);
	end:select

	Node[P1].pType = pType;
	Node[P1].nPtr  = nPtr;

	return P1;
end

/*****************************************************************************/

word ExprNEG(word P_; word O; char @Buff)

	word P1;

	P1=Peek();
	Node[P1].ID    = iNEG;
	Node[P1].pLeft = _Expr(Operator[O].Prio, @Scan(@Buff));
	word pType = Node[Node[P1].pLeft].pType;
	word nPtr  = Node[Node[P1].pLeft].nPtr;

	select
	case Node[Node[P1].pLeft].ID=iWORD:
		if Node[Node[P1].pLeft].Value>0x80000000 then
			Stop(@eCALCERR);
		end

		if Node[Node[P1].pLeft].Value!=0 then
			Node[P1].ID   =iINT;
			Node[P1].Value=-Node[Node[P1].pLeft].Value;
			pType         = st_int;
		else
			Node[P1].ID   =iWORD;
			Node[P1].Value= 0;
			pType         = st_word;
		end:if

	case Node[P1].ID=iINT:
		Node[P1].ID   =iWORD;
		Node[P1].Value=-Node[Node[P1].pLeft].Value;
		pType         = st_word;

	default:
		ImplicitCast(st_int, 0, @Node[P1].pLeft);
		pType         = st_int;
	end:select

	Node[P1].pType = pType;
	Node[P1].nPtr  = nPtr;

	return P1;

end

/*****************************************************************************/

void RegisterOperators()

	RegisterOperator("|"   , pBOOL , OPERATOR_BLEFT, iOR , @Expr1);
	RegisterOperator("^"   , pBOOL , OPERATOR_BLEFT, iXOR, @Expr1);
	RegisterOperator("&"   , pBOOL , OPERATOR_BLEFT, iAND, @Expr1);

	RegisterOperator("<"   , pCOMP , OPERATOR_BLEFT, iLT , @Expr1);
	RegisterOperator("<="  , pCOMP , OPERATOR_BLEFT, iLE , @Expr1);
	RegisterOperator("="   , pCOMP , OPERATOR_BLEFT, iEQ , @Expr1);
	RegisterOperator("!="  , pCOMP , OPERATOR_BLEFT, iNE , @Expr1);
	RegisterOperator(">"   , pCOMP , OPERATOR_BLEFT, iGT , @Expr1);
	RegisterOperator(">="  , pCOMP , OPERATOR_BLEFT, iGE , @Expr1);

	RegisterOperator("+"   , pADD  , OPERATOR_BLEFT, iADD, @Expr1);
	RegisterOperator("-"   , pADD  , OPERATOR_BLEFT, iSUB, @Expr1);

	RegisterOperator("*"   , pMUL  , OPERATOR_BLEFT, iMUL, @Expr1);
	RegisterOperator("/"   , pMUL  , OPERATOR_BLEFT, iDIV, @Expr1);
	RegisterOperator("%"   , pMUL  , OPERATOR_BLEFT, iMOD, @Expr1);

	RegisterOperator("-"   , pNEG  , OPERATOR_UPRE , iNEG, @ExprNEG);
	RegisterOperator("!"   , pNEG  , OPERATOR_UPRE , iNOT, @ExprNOT);

	RegisterOperator("("   , pEXPR , OPERATOR_UPRE , 0   , @Expr2);

	RegisterOperator("'"    , pCONST, OPERATOR_UPRE , iCHAR, @ExprLitChar);
	RegisterOperator("#"    , pCONST, OPERATOR_UPRE , iCHAR, @ExprLitChar);
	RegisterOperator("NULL" , pCONST, OPERATOR_UPRE , iNULL, @ExprLitNULL);
	RegisterOperator("false", pCONST, OPERATOR_UPRE , iBOOL, @ExprLitFALSE);
//	RegisterOperator("FALSE", pCONST, OPERATOR_UPRE , iBOOL, @ExprLitFALSE);
	RegisterOperator("true" , pCONST, OPERATOR_UPRE , iBOOL, @ExprLitTRUE);
//	RegisterOperator("TRUE" , pCONST, OPERATOR_UPRE , iBOOL, @ExprLitTRUE);
end

/*****************************************************************************/

