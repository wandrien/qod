

/*****************************************************************************/

NODE     Node [nNODE]; // Массив узлов синтаксического деpева
word    nNode;

/*****************************************************************************/

/* Выделить узел и вернуть его индекс. */
word Peek()
	word N  = nNode;
	when N >= nNODE:
		StopMemory();

	Node[nNode].Used = 0;
	Node[nNode].pLeft  = nNODE;
	Node[nNode].pRight = nNODE;
	Node[nNode].pType  = nDICT;
	inc  nNode;

	return N;
end

/*****************************************************************************/

word NodeGetImmediateValue(word P)

	when P >= nNode:
		StopInternal();

	switch Node[P].ID of
	case iCHAR, iWORD, iINT:
		return Node[P].Value;
	end

	StopInternal();
	return 0;
end

void NodeSetImmediateValue(word P; word Value)

	when P >= nNode:
		StopInternal();

	switch Node[P].ID of
	case iCHAR, iWORD, iINT:
		Node[P].Value = Value;
	default:
		StopInternal();
	end
end

/*****************************************************************************/

word NodeGetDict(word P)

	when P >= nNode:
		StopInternal();

	switch Node[P].ID of
	case iFUNC, iCALL, iCALL2, iSTRING, iDATA:
		return Node[P].Value;
	end

	StopInternal();
	return 0;
end

void NodeSetDict(word P; word D)

	when P >= nNode:
		StopInternal();

	switch Node[P].ID of
	case iFUNC, iCALL, iCALL2, iSTRING, iDATA:
		Node[P].Value = D;
	default:
		StopInternal();
	end
end

/*****************************************************************************/
