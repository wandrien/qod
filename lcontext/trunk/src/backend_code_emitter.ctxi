
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word pSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word pVar;  /* Текущий размер фрейма стека, задействованный под локальные переменные. */
word fEAX;  /* Маркер активного регистра. (Cуть этого хака более ясна его автору - Хохлову, нежели мне. VU) */

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word P; word F; word T; word M)

	char Buff [nBUFF];

	Buff[0] = #0;

	word ID1=Node[P].ID;
	if ID1=iINC | ID1=iDEC then
		fEAX=0;
		P   =Node[P].pLeft;
	end

	word pIndx;
	word nIndx;

	word pType;
	word nPtr;
	word  Ofs;
	word ID=ExtractDataInfo(P, @pType, @nPtr, @pIndx, @nIndx, @Ofs);
	word IX=0;

	word P1=Node[P].pLeft;
	do
		select
		case P1>=nNODE:
			select
			case ID1=iINC | ID1=iDEC:
				if IX=2 | nPtr>0 then
					StopInternal();
				end:if

				if ID1=iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=Dict[pType].Value;
				select
				case Size=1:
					strcat(@Buff,"byte  ");     // FASM
				case Size=4:
					strcat(@Buff,"dword ");     // FASM
				default:
					StopInternal();
				end:select

				Emit(0,@CodeDataIX_offset(@Buff, ID, IX, Ofs));

			case ID!=iCALL:
				word Size = SizeOfType(pType, nPtr);

				select
				case Size=1:
					strcpy(@Buff,"mov     byte  ");     // FASM
				case Size=4:
					strcpy(@Buff,"mov     dword ");     // FASM
				default:
					strcpy(@Buff,"lea     EDI,  ");
				end:select

				CodeDataIX_offset(@Buff, ID, IX, Ofs);

				select
				case fEAX!=0:
					select
					case Size=1:
						Emit(0,@strcat(@Buff,", AL"));
					case Size=4:
						Emit(0,@strcat(@Buff,", EAX"));

					default:
						Emit(0,"mov     ESI,  EAX");
						Emit(0,@Buff);
					end:select

				case IX=1:
					select
					case Size=1:
						Emit(0,"pop     EBX");
						Emit(0,@strcat(@Buff,", BL"));
					case Size=4:
						Emit(0,"pop     EBX");
						Emit(0,@strcat(@Buff,", EBX"));
					default:
						Emit(0,"pop     ESI");
						Emit(0,@Buff);
					end:select

				case IX=2:
					select
					case Size=1:
						Emit(0,"pop     EAX");
						Emit(0,@strcat(@Buff,", AL"));
					case Size=4:
						Emit(0,"pop     EAX");
						Emit(0,@strcat(@Buff,", EAX"));
					default:
						Emit(0,"pop     ESI");
						Emit(0,@Buff);
					end:select
				end:select

				if Size!=1 & Size!=4 then
					Emit(0,"cld");
					Emit(0,@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
					Emit(0,"rep     movsb");
				end:if
			end:select

			exit;

		case Node[P1].ID=iLOAD:
			word Size = SizeOfType(pType, nPtr);

			select
			case Size=1:
				if fEAX=0 then
					strcpy(@Buff,"mov     AL,   byte  ");     // FASM
				else
					strcpy(@Buff,"mov     BL,   byte  ");     // FASM
				end:if

			case Size=4:
				if fEAX=0 then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if

			default:
				if fEAX=0 then
					strcpy(@Buff,"lea     EAX,  ");
				else
					strcpy(@Buff,"lea     EBX,  ");
				end:if
			end:select

			if IX!=0 then
				char RX[4];
				if IX=1 then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end

				select
				case ID=iDATA:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"-"),@str(Ofs)),"]"));
				case ID=iREF:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"["),@RX),"+"),@str(Ofs)),"]"));
				default:
					StopInternal();
				end:select
			else
				select
				case ID=iDATA:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs)),"]"));
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs)),"]"));
				case ID!=iCALL:
					StopInternal();
				end:select
			end:if

			if nPtr>0 then
				return nDICT;
			else
				return pType;
			end:if

		case Node[P1].ID=iLPTR:
			if fEAX!=0 | IX=2 then
				StopInternal();
			end:if

			if IX!=0 then
				select
				case ID=iDATA:
					Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  @@TEXT+"),@str(Ofs)));
				case ID=iREF & Ofs!=0:
					Emit(0,@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopInternal();
				end:select
			else
				select
				case ID=iDATA:
					Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					Emit(0,@strcat(@strcpy(@Buff,"mov     EAX,  @@TEXT+"),@str(Ofs)));
				case ID!=iCALL:
					StopInternal();
				end:select
			end:if

			return nDICT;

		case Node[P1].ID=iCALL:
			if fEAX!=0 then
				Emit(0,"push    EAX");
				fEAX=0;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub=sSYS then
				Emit(0,@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Node[P1].Value].Value)),"]"));
			else
				Emit(0,@strcat(@strcpy(@Buff,"call    @"),@str(Dict[Node[P1].Value].Value)));
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID=iCALL2:
			if fEAX!=0 then
				Emit(0,"push    EAX");
				fEAX=0;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit(0,"call    EAX");

			pType=Dict[Node[P1].Value].pType;
			nPtr =Dict[Node[P1].Value].nPtr;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID=iINDEX:

			word  C   = 0;
			word  N   = 0;
			word  IX1 = 0;
			word fIX  = 1;
			do
				if Node[Node[P1].pLeft].ID=iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					select
					case IX1=2:
						if fEAX!=0 then
							if IX!=0 then
								StopInternal();
							end:if

							fEAX=0;
						else
							if IX!=1 then
								StopInternal();
							end:if

							fIX=0;
						end:if

						Emit(0,"push    EAX");
						Emit(0,"push    EBX");

						_Code(Node[P1].pLeft,0,0,0);

						Emit(0,"pop     EBX");
						Emit(0,@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						Emit(0,"add     EAX,  EBX");

						IX1=1;

					case IX1=1:
						if fEAX!=0 | IX!=0 then
							StopInternal();
						end

						fEAX=1;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=0 then
							Emit(0,"pop     EBX");
							Emit(0,@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						else
							Emit(0,@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(N*Node[P1].Value)));
						end:if

						Emit(0,"add     EAX,  EBX");

						fEAX=0;

					case IX =2:
						if fEAX=0 then
							StopInternal();
						end:if

						Emit(0,"push    EAX");
						Emit(0,"push    EBX");

						fEAX=0;
						fIX =0;

						_Code(Node[P1].pLeft,0,0,0);

						IX1=1;

					case IX =1:
						if fEAX!=0 then
							StopInternal();
						end:if

						fEAX=1;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=0 then
							fIX=0;
							IX1=1;
						else
							IX1=2;
						end:if

						fEAX=0;

					default:
						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=0 then
							IX1=1;
						else
							IX1=2;
						end:if
					end:select

					C=C*Node[P1].Value;
					N=1;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType, nPtr);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

			if IX1!=0 then
				Size = Size * N;

				select
				case Size=2:
					if IX1=1 then
						Emit(0,"add     EAX, EAX");
					else
						Emit(0,"add     EBX, EBX");
					end:if

				case Size=4:
					if IX1=1 then
						Emit(0,"shl     EAX,  2");
					else
						Emit(0,"shl     EBX,  2");
					end:if

				case Size=8:
					if IX1=1 then
						Emit(0,"shl     EAX,  3");
					else
						Emit(0,"shl     EBX,  3");
					end:if

				case Size>1:
					if IX1=1 then
						Emit(0,@strcat(@strcpy(@Buff,"imul    EAX, "),@str(Size)));
					else
						Emit(0,@strcat(@strcpy(@Buff,"imul    EBX, "),@str(Size)));
					end:if
				end:select

				if IX!=0 then
					select
					case IX1=2:
						if IX!=1 | fIX=0 then
							StopInternal();
						end:if

						Emit(0,"add     EAX,  EBX");

					case IX1=1:
						if fIX!=0 then
							Stop(@eINTERNAL);
						end

						Emit(0,"pop     EBX");
						Emit(0,"add     EAX,  EBX");

						IX=1;

					default:
						StopInternal();
					end:select
				else
					IX=IX1;
				end:if
			end:if

		case Node[P1].ID=iADDR:
			if nPtr<1 then
				StopInternal();
			end:if

			dec nPtr;

			if Node[P1].pLeft<nNODE then
				word Size = SizeOfType(pType, nPtr);

				select
				case IX=2:
					if fEAX!=0 then
						Emit(0,"push    EAX");
					end:if

					Emit(0,"xchg    EAX,  EBX");
					IX  =1;
					fEAX=1;

				case IX=1:
					fEAX=1;
				end:select

				_Code(Node[P1].pLeft,0,0,0);
				if fEAX=0 then
					select
					case Size=4:
						Emit(0,"shl     EAX,  2");
					case Size>1:
						Emit(0,@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(Size)));
					end:select

					if IX!=0 then
						Emit(0,"pop     EBX");
						IX=2;
					end:if

					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					select
					case Size=4:
						Emit(0,"shl     EBX,  2");
					case Size>1:
						Emit(0,@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(Size)));
					end:select

					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX=0 then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=0 then
				char RX[4];
				if IX=1 then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end:if

				select
				case ID=iDATA:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"-"),@str(Ofs)),"]"));
				case ID=iREF:
					Emit(0,@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"["),@RX),"+"),@str(Ofs)),"]"));
				default:
					StopInternal();
				end:select
			else
				select
				case ID=iDATA:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs)),"]")); // FASM
				case ID=iPARM:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(0,@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs)),"]"));
				//TODO Пpовеpить!
				case ID=iCALL:
					null
				default:
					StopInternal();
				end:select
			end:if

			if fEAX=0 then
				IX=1;
			else
				if IX!=0 then
					fEAX=0;
				end:if

				IX=2;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID=iFIELD:
			CodeData_FIELD(@P1, @pType, @nPtr, @ID, @Ofs);

		default:
			StopInternal();
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff [nBUFF];

	Buff[0] = #0;

	switch Node[P].ID of
	case iNULL:
		CodeLoadConstant(@Buff, fEAX, 4, 0);
		Emit(0, @Buff);
		return nDICT;

	case iCHAR:
		CodeLoadConstant(@Buff, fEAX, 1, Node[P].Value);
		Emit(0, @Buff);
		return st_char;

	case iWORD:
		CodeLoadConstant(@Buff, fEAX, 4, Node[P].Value);
		Emit(0, @Buff);
		return st_word;

	case iINT:
		CodeLoadConstant(@Buff, fEAX, 4, Node[P].Value);
		Emit(0, @Buff);
		return st_int;

	case iFUNC:
		CodeLoadLabel(@Buff, fEAX, Node[P].Value);
		Emit(0, @Buff);
		return nDICT;

///////////////////////////////////////////////////////////////////////////////

	case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
		return Code1(P, F, T, M);

///////////////////////////////////////////////////////////////////////////////

	case iCAST:
		word pType = Code(Node[Node[P].pLeft].pLeft, 0, 0, 0);
		select
		case Node[P].Value=st_char & pType=st_byte:
			null
		case Node[P].Value=st_char & pType=st_word:
			null
		case Node[P].Value=st_char & pType=st_int:
			null
		case Node[P].Value=st_byte & pType=st_char:
			null
		case Node[P].Value=st_word & pType=st_char:
			Emit(0, @CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_word & pType=st_byte:
			Emit(0, @CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_char:
			Emit(0, @CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_byte:
			Emit(0, @CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_word:
			null
		default:
			StopInternal();
		end
		return  Node[P].Value;

///////////////////////////////////////////////////////////////////////////////

	case iNOT:
		word pType = Code(Node[P].pLeft, 0, 0, 0);
		word  Size = Dict[pType].Value;
		Emit(0, @CodeCmdReg(@Buff, "not", fEAX, Size));

		return pType;

///////////////////////////////////////////////////////////////////////////////

	case iNEG:
		if Node[Node[P].pLeft].ID=iWORD then
			CodeLoadConstant(@Buff, fEAX, 4, -Node[Node[P].pLeft].Value);
			Emit(0, @Buff);
			return st_int;
		end

		Code(Node[P].pLeft,0,0,0);

		Emit(0, @CodeCmdReg(@Buff, "neg", fEAX, 4));

		return st_int;

///////////////////////////////////////////////////////////////////////////////

	case iOR:
		word L = Node[P].Value;
		if T=0 then
			Code(Node[P].pLeft ,  0, M, L);
			Emit(L,"");
			Code(Node[P].pRight, F, 0, M);
		else
			Code(Node[P].pLeft , 0, T, L);
			Emit(L,"");
			Code(Node[P].pRight, 0, T, M);
		end

///////////////////////////////////////////////////////////////////////////////

	case iXOR:
		word L1=Node[Node[P].pLeft] .Value;
		word L2=Node[P].Value;
		if T=0 then
			Code(Node[Node[P].pLeft] .pLeft, L2,0,L1);
			Emit(L1,"");
			Code(Node[Node[P].pLeft] .pRight,M, 0,F);
			Emit(0 ,@strcat(@strcpy(@Buff,"jmp     @"),@str(F)));
			Emit(L2,"");
			Code(Node[P].pRight,             F, 0,M);
		else
			Code(Node[Node[P].pLeft] .pLeft, L2,0,L1);
			Emit(L1,"");
			Code(Node[Node[P].pLeft] .pRight,T, 0,M);
			Emit(0 ,@strcat(@strcpy(@Buff,"jmp     @"),@str(M)));
			Emit(L2,"");
			Code(Node[P].pRight,             M, 0,T);
		end

///////////////////////////////////////////////////////////////////////////////

	case iEQV:
		word L1=Node[Node[P].pLeft] .Value;
		word L2=Node[P].Value;
		if T=0 then
			Code(Node[Node[P].pLeft] .pLeft, L2,0,L1);
			Emit(L1,"");
			Code(Node[Node[P].pLeft] .pRight,F, 0,M);
			Emit(0 ,@strcat(@strcpy(@Buff,"jmp     @"),@str(M)));
			Emit(L2,"");
			Code(Node[P].pRight,             0, F,M);
		else
			Code(Node[Node[P].pLeft] .pLeft, L2,0,L1);
			Emit(L1,"");
			Code(Node[Node[P].pLeft] .pRight,0, T,M);
			Emit(0 ,@strcat(@strcpy(@Buff,"jmp     @"),@str(M)));
			Emit(L2,"");
			Code(Node[P].pRight,             T, 0,M);
		end

///////////////////////////////////////////////////////////////////////////////

	case iAND:
		word L = Node[P].Value;
		if T=0 then
			Code(Node[P].pLeft , F, 0, L);
			Emit(L,"");
			Code(Node[P].pRight, F, 0, M);
		else
			Code(Node[P].pLeft , M, 0, L);
			Emit(L,"");
			Code(Node[P].pRight, 0, T, M);
		end

///////////////////////////////////////////////////////////////////////////////

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:

      if iLT<=Node[P].ID & Node[P].ID<=iGT then
        fEAX=0;
      end

      if fEAX!=0 then
        Emit(0,"push    EAX");
        fEAX=0;
      end

      word fSwap=0;
      word pType;
      select
        case Node[Node[P].pRight].ID=iCHAR | Node[Node[P].pRight].ID=iWORD | Node[Node[P].pRight].ID=iINT:
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=2;

        case Node[Node[P].pLeft].ID=iCHAR | Node[Node[P].pLeft].ID=iWORD | Node[Node[P].pLeft].ID=iINT:
          Code(Node[P].pRight,0,0,0);
          fEAX =1;
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=1;

        case Node[Node[Node[P].pLeft].pLeft].ID=iLOAD:
          Code(Node[P].pRight,0,0,0);
          fEAX =1;
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=1;

        default:
          pType=Code(Node[P].pLeft,0,0,0);
          fEAX =1;
          Code(Node[P].pRight,0,0,0);
          if fEAX=0 then
            Emit(0,"pop     EBX");
            fSwap=1;
          end
      end

      word ID=Node[P].ID;
      select
        case fSwap=1:
          select
            case ID=iLT:
              ID=iGT;

            case ID=iLE:
              ID=iGE;

            case ID=iGE:
              ID=iLE;

            case ID=iGT:
              ID=iLT;

            case ID=iSUB | ID=iDIV | ID=iMOD:
              Emit(0,"xchg    EAX,  EBX");
          end

        case fSwap=2:
          select
            case ID=iMUL | ID=iDIV | ID=iMOD:
              fEAX =1;
              Code(Node[P].pRight,0,0,0);
          end
      end

      fEAX=0;

      word Size=4;
      if pType<nDICT then
        Size=Dict[pType].Value;
      end

      select
        case iLT<=ID & ID<=iGT:
          select
            case Size=1:
              select
                case fSwap=2:
                  Emit(0,@strcat(@strcpy(@Buff,"cmp     AL,   "),@str(Node[Node[P].pRight].Value)));

                default:
                  Emit(0,"cmp     AL,   BL");
              end

            case Size=4:
              select
                case fSwap=2:
                  Emit(0,@strcat(@strcpy(@Buff,"cmp     EAX,  "),@str(Node[Node[P].pRight].Value)));

                default:
                  Emit(0,"cmp     EAX,  EBX");
              end

            default:
              StopInternal();
          end

          if T=0 then
            select
              case ID=iLT:
                ID=iGE;

              case ID=iLE:
                ID=iGT;

              case ID=iEQ:
                ID=iNE;

              case ID=iNE:
                ID=iEQ;

              case ID=iGE:
                ID=iLT;

              case ID=iGT:
                ID=iLE;

              default:
                StopInternal();
            end

            T=F;
            F=0;
          end

          if T=0 | F!=0 then
            StopInternal();
          end

          char@ Cmd;
          select
            case pType=st_int:
              select
                case ID=iLT:
                  @Cmd = "jl ";
                case ID=iLE:
                  @Cmd = "jle";
                case ID=iEQ:
                  @Cmd = "je ";
                case ID=iNE:
                  @Cmd = "jne";
                case ID=iGE:
                  @Cmd = "jge";
                case ID=iGT:
                  @Cmd = "jg ";
                default:
                  StopInternal();
              end

            default:
              select
                case ID=iLT:
                  @Cmd = "jb ";
                case ID=iLE:
                  @Cmd = "jbe";
                case ID=iEQ:
                  @Cmd = "je ";
                case ID=iNE:
                  @Cmd = "jne";
                case ID=iGE:
                  @Cmd = "jae";
                case ID=iGT:
                  @Cmd = "ja ";
                default:
                  StopInternal();
              end
          end
          Emit(0,@strcat(@strcat(@strcpy(@Buff, @Cmd),"     @"),@str(T)));

          return nDICT;

        case ID=iBIT_OR:
          strcpy(@Buff,"or      ");

        case ID=iBIT_XOR:
          strcpy(@Buff,"xor     ");

        case ID=iBIT_AND:
          strcpy(@Buff,"and     ");

        case ID=iADD:
          strcpy(@Buff,"add     ");

        case ID=iSUB:
          strcpy(@Buff,"sub     ");

        case ID=iMUL:
          select
            case pType=st_byte:
              Emit(0,"mul     BL");

            case pType=st_word:
              Emit(0,"mul     EBX");

            case pType=st_int:
              Emit(0,"imul    EBX");

            default:
              StopInternal();
          end

          return pType;

        case ID=iDIV:
          select
            case pType=st_byte:
              Emit(0,"xor     AH,   AH");
              Emit(0,"div     BL");

            case pType=st_word:
              Emit(0,"xor     EDX,  EDX");
              Emit(0,"div     EBX");

            case pType=st_int:
              Emit(0,"xor     EDX,  EDX");
              Emit(0,"idiv    EBX");

            default:
              StopInternal();
          end

          return pType;

        case ID=iMOD:
          select
            case pType=st_byte:
              Emit(0,"xor     AH,   AH");
              Emit(0,"div     BL");
              Emit(0,"xchg    AL,   AH");

            case pType=st_word:
              Emit(0,"xor     EDX,  EDX");
              Emit(0,"div     EBX");
              Emit(0,"xchg    EAX,  EDX");

            default:
              StopInternal();
          end

          return pType;

        default:
          StopInternal();
      end

      select
        case Size=1:
          select
            case fSwap=2:
              Emit(0,@strcat(@strcat(@Buff,"AL,   "),@str(Node[Node[P].pRight].Value)));

            default:
              Emit(0,@strcat(@Buff,"AL,   BL"));
          end

        case Size=4:
          select
            case fSwap=2:
              Emit(0,@strcat(@strcat(@Buff,"EAX,  "),@str(Node[Node[P].pRight].Value)));

            default:
              Emit(0,@strcat(@Buff,"EAX,  EBX"));
          end

        default:
          StopInternal();
      end

      return pType;

///////////////////////////////////////////////////////////////////////////////

    case iDEF:
      if nParm>=nPARM then
        Stop(@eNOMEMORY);
      end

      word pType = Node[P].Value;
      word nPtr  = Node[Node[P].pLeft].Value;
      word Size  = SizeOfType(pType, nPtr);

      pVar=pVar+DefaultInStackAlign(Node[Node[Node[P].pLeft].pLeft].Value*Size);

      Parm[nParm].pType=pType;
      Parm[nParm].nPtr =nPtr;
      Parm[nParm].Value=pVar;
      inc  nParm;

      Code(Node[Node[P].pLeft].pLeft,0,0,0);

///////////////////////////////////////////////////////////////////////////////

	case iPUSH:
		if Node[P].pRight<nNODE then
			Code(Node[P].pRight,0,0,0);
		end

		//fEAX=0;
		//Code(Node[P].pLeft,0,0,0);
		//Emit(0,"push    EAX");

		/* Оптимизация прямой загрузки значения из пременной. */

		word P1 = Node[P].pLeft;

		if Node[P1].ID=iDATA
		 | Node[P1].ID=iPARM
		 | Node[P1].ID=iLOCAL then

			if Node[P1].pLeft < nNODE & Node[Node[P1].pLeft].ID=iLOAD then

				word pIndx;
				word nIndx;
				word pType;
				word nPtr;
				word  Ofs;
				word ID=ExtractDataInfo(P1, @pType, @nPtr, @pIndx, @nIndx, @Ofs);

				/* FIXME: проверка pIndx >= nIndx не работает для локальных переменных, поскольку компилятор не сохраняет эту информацию >< */
//				if pIndx >= nIndx & SizeOfType(pType, nPtr) = 4 then
				if 1 >= 1 & SizeOfType(pType, nPtr) = 4 then
					strcpy(@Buff, "push    dword ");
					Emit(0, @CodeDataIX_offset(@Buff, ID, 0, Ofs));
					return nDICT;
				end:if
			end:if
		end:if


		/* Оптимизация прямой загрузки указателя на строку. */
		if Node[P1].ID=iSTRING then

			if Node[P1].pLeft != nNODE
			 & Node[Node[P1].pLeft].ID=iLPTR then

				word pIndx;
				word nIndx;
				word pType;
				word nPtr;
				word  Ofs;
				word ID=ExtractDataInfo(P1, @pType, @nPtr, @pIndx, @nIndx, @Ofs);

				strcpy(@Buff, "push    ");
				Emit(0,@strcat(@strcat(@strcat(@Buff,"dword @@TEXT+"),@str(Ofs)),""));

				return nDICT;
			end:if
		end:if


		/* Оптимизация прямой загрузки числа из регистра. */
		select
		case Node[P1].ID=iNULL:
			word RegC = PHO_FindRegWithConst(0);
			if RegC != PHO_REG_INVALID then
				strcpy(@Buff, "push    ");
				strcat(@Buff, @PHO_EncodeReg(RegC, 0xFFFF_FFFF));
				Emit(0, @Buff);
				return nDICT;
			end:if
		case Node[P1].ID=iWORD | Node[P1].ID=iINT:
			word RegC = PHO_FindRegWithConst(Node[P1].Value);
			if RegC != PHO_REG_INVALID then
				strcpy(@Buff, "push    ");
				strcat(@Buff, @PHO_EncodeReg(RegC, 0xFFFF_FFFF));
				Emit(0, @Buff);
				return nDICT;
			end:if
		end:select

		/* Оптимизация прямой загрузки числа. */
		if (Node[P1].ID=iWORD | Node[P1].ID=iINT) & Node[P1].Value != 0 then

			strcpy(@Buff, "push    dword ");
			strcat(@Buff, @str(Node[Node[P].pLeft].Value));
			Emit(0, @Buff);

			return nDICT;
		end:if

		/* Все остальные варианты... */

		fEAX=0;
		word pType = Code(Node[P].pLeft,0,0,0);

		word Size = PointerSize;
		if pType<nDICT then
			Size=Dict[pType].Value;
		end

		select
		case Size=1:
			Emit(0,"push    EAX");
		case Size=4:
			Emit(0,"push    EAX");
		default:
			Emit(0,@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(DefaultInStackAlign(Size))));
			Emit(0,"mov     ESI,  EAX");
			Emit(0,"mov     EDI,  ESP");
			Emit(0,"cld");
			Emit(0,@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
			Emit(0,"rep     movsb");
		end:select

///////////////////////////////////////////////////////////////////////////////

	case iASSIGN:
		P    = Node[P].pLeft;
		fEAX = 0;
		if Node[P].pRight < nNODE then
			Code(Node[P].pRight, 0, 0, 0);
			fEAX = 1;
		end

		Code(Node[P].pLeft, 0, 0, 0);

///////////////////////////////////////////////////////////////////////////////

	case iRETURN:
    
		if Node[P].pLeft<nNODE then
			fEAX=0;
			word pType=Code(Node[P].pLeft,0,0,0);
			word  Size=4;
			if pType<nDICT then
				Size=Dict[pType].Value;
			end:if

			if Size!=1 & Size!=4 then
				StopInternal();
			end:if
		end:if

		if Dict[pFunc].Sub = sMAIN then
			select
			case TargetFileFormat = tPE:
				Emit(0,"xor     EAX,  EAX");
				Emit(0,"push    EAX");
				Emit(0,@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Find("ExitProcess")].Value)),"]"));

			case TargetFileFormat = tELF:
				Emit(0,"mov     EAX,  1");
				Emit(0,"xor     EBX,  EBX");
				Emit(0,"int     80H");

			default:
				StopInternal();
			end:select
		else
		
			if CompactFunctionEnterLeave != 0 then
				Emit(0,"leave");
			else
				Emit(0,"mov     ESP,  EBP");
				Emit(0,"pop     EBP");
			end:if

			if pSize > 0 then
				Emit(0,@strcat(@strcpy(@Buff,"ret     "),@str(pSize)));
			else
				Emit(0,"ret");
			end:if
		end:if

///////////////////////////////////////////////////////////////////////////////

	case iINLINE:
		Emit(0,@strcat(@strcpy(@Buff,"db      0x"),@str2(Node[P].Value,16)));

///////////////////////////////////////////////////////////////////////////////

    case iSELECT:
      word E=Node[P].Value;

      P=Node[P].pLeft;
      while P<nNODE do
        if Node[Node[P].pLeft].pLeft<nNODE then
          F=Node[P].Value;
          T=Node[Node[P].pLeft].Value;
          Code(Node[Node[P].pLeft].pLeft,F,0,T);
          Emit(T,"");
        end

        word nParm1=nParm;
        word pVar1 =pVar;

        word  P1=Node[Node[P].pLeft].pRight;
        while P1<nNODE do
          Code(P1,0,0,0);
          P1=Node[P1].pRight;
        end

        pVar =pVar1;
        nParm=nParm1;

        if Node[P].pRight<nNODE then
          Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(E)));
        end

        if Node[Node[P].pLeft].pLeft<nNODE then
          Emit(F,"");
        end

        P=Node[P].pRight;
      end

      Emit(E,"");

///////////////////////////////////////////////////////////////////////////////

	case iSWITCH:
		word L_End = Node[P].Value;
		word L_Default = L_End;

		fEAX = 0;
		word pType = Code(Node[Node[P].pLeft].pLeft,0,0,0);
		if pType = st_byte then
			Emit(0,"and     EAX,  0FFH");
		end:if

		word offset = 0;

		word  P1 = Node[Node[P].pLeft].pRight;
		while P1 < nNODE do
			word  P2 = Node[Node[P1].pLeft].pLeft;
			if    P2 = nNODE then
				L_Default = Node[P1].Value;
			end:if

			while P2 != nNODE do
				word value = Node[P2].Value - offset;

				char@ Reg = "EAX";
				if pType = st_char then
					value = value & $FF;
					@Reg = "AL";
				end:if

				switch value of
				case 1:
					strcpy(@Buff, "dec    ");
					strcat(@Buff, @Reg);
				case 2:
					strcpy(@Buff, "dec    ");
					strcat(@Buff, @Reg);
					Emit(0, @Buff);
				default:
					strcpy(@Buff, "sub    ");
					strcat(@Buff, @Reg);
					strcat(@Buff, ", ");
					strcat(@Buff, @str(value));
				end
				Emit(0, @Buff);

				offset = offset + value;

				Emit(0,@strcat(@strcpy  (@Buff,"je      @"),@str(Node[P1].Value)));

				P2=Node[P2].pLeft;
			end:while

			P1=Node[P1].pRight;
		end:while

		Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(L_Default)));

		word  P2= Node[Node[P].pLeft].pRight;
		while P2<nNODE do
			Emit(Node[P2].Value,"");

			word nParm1=nParm;
			word pVar1 =pVar;

			word  P3=Node[Node[P2].pLeft].pRight;
			while P3<nNODE do
				Code(P3,0,0,0);
				P3=Node[P3].pRight;
			end

			pVar =pVar1;
			nParm=nParm1;

			Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(L_End)));

			P2=Node[P2].pRight;
		end:while

		Emit(L_End,"");

///////////////////////////////////////////////////////////////////////////////

	/*
		       iWHILE
		      /      \ <-- F
		    BODY      ...
	         /    \ <-T
	      HEAD     ...
	     L -> \...
	*/

	case iWHILE:
		F = Node[P].Value;
		P = Node[P].pLeft;
		T = Node[P].Value;

		word HEAD = Node[P].pLeft;
		word L = Node[HEAD].Value;
		Emit(L, "");
		if Node[HEAD].pRight < nNODE then
			Code(Node[HEAD].pRight, F, 0, T);
			Emit(T, "");
		end

		word nParm1 = nParm;
		word pVar1  = pVar;

		P = Node[P].pRight;
		while P < nNODE do
			Code(P, 0, 0, 0);
			P = Node[P].pRight;
		end

		pVar =pVar1;
		nParm=nParm1;

		Emit(0, @strcat(@strcpy(@Buff, "jmp     @"), @str(L)));
		Emit(F, "");

///////////////////////////////////////////////////////////////////////////////

	/*
		       iREPEAT
		      /       \ <-- T
		    BODY       ...
	         |    \
	         |   TAIL
	    F ---+> /    \
               ...      ...

	*/

	case iREPEAT:
		T = Node[P].Value;
		P = Node[P].pLeft;
		F = Node[P].Value;
		P = Node[P].pRight;

		Emit(F, "");

		word nParm1 = nParm;
		word pVar1  = pVar;

		word  P1 = Node[P].pLeft;
		while P1 < nNODE do
			Code(P1, 0, 0, 0);
			P1 = Node[P1].pRight;
		end

		Code(Node[P].pRight, F, 0, T);

		pVar  = pVar1;
		nParm = nParm1;

		Emit(T, "");

///////////////////////////////////////////////////////////////////////////////

	case iLOOP, iEXIT:
		Emit(0,@strcat(@strcpy(@Buff,"jmp     @"),@str(Node[Node[P].Value].Value)));

///////////////////////////////////////////////////////////////////////////////

	case iEMPTY:
		null

	default:
		StopInternal();

	end

	return nDICT;
end


/*****************************************************************************/


word EmitFunctions(char @Buff)

	word S;

	word pRet = Peek();
	Node[pRet].ID = iRETURN;


	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class = cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				EmitStringNL("");
				if Dict[I].Sub!=sMAIN then
					Emit(Dict[I].Value,@strcat(@strcpy(@Buff,"       ;"),@GetDictName(I)));
				else
					Emit(Dict[I].Value,"       ;begin");
					S = Dict[I].Value;
				end

				word S1 = 0;

				word K = Dict[I].pIndx;
				while K < Dict[I].nIndx do
					Parm[K].Value = S1 + 8;
					if Parm[K].nPtr = 0 then
						S1 = S1 + DefaultInStackAlign(Dict[Parm[K].pType].Value);
					else
						S1 = S1 + 4;
					end

					inc K;
				end

				PHO_InvalidateRegs();

				if CompactFunctionEnterLeave != 0 & Dict[I].Stack > 0 then
					Emit(0,@strcat(@strcat(@strcpy(@Buff,"enter   "),@str(Dict[I].Stack)), ", 0"));
				else
					Emit(0,"push    EBP");
					Emit(0,"mov     EBP,  ESP");

					if Dict[I].Stack > 0 then
						Emit(0,@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(Dict[I].Stack)));
					end:if
				end:if

				if Dict[I].Sub = sMAIN then
					word  J = 0;
					while J < nDict do
						if Dict[J].Class = cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
							if Node[Dict[J].pNode].ID != iASSIGN then
								StopInternal();
							end:if
							if StaticDataIsZeroed = 0
							 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) = 0 then
								Code(Dict[J].pNode, 0, 0, 0);
							end:if
						end:if

						inc J;
					end:while
				end:if

				pParm =nParm;
				pFunc = I;
				pSize = S1;
				pVar  = 0;

				word  P = Dict[I].pNode;
				word  ID;
				while P < nNODE do
					Code(P, 0, 0, 0);
					ID = Node[P].ID;
					P  = Node[P].pRight;
				end

				if ID!=iRETURN then
					Code(pRet, 0, 0, 0);
				end

				nParm=pParm;
		end // of select

		inc I;
	end // of while

	return S;

end

/*****************************************************************************/

word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat = tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat = tELF:
			EmitStringNL("section readable executable");

		default:
			StopInternal();
	end

	EmitROData();

	word S = EmitFunctions(@Buff);

	return S;

end

/*****************************************************************************/

