
/*
	Основная часть кодогенератора.
*/

/*****************************************************************************/

word ParmFrameSize; /* Размер фрейма стека, освобождаемого при выходе из функции. */
word AllocatedFrameSize; /* Текущий размер фрейма стека, задействованный под локальные переменные. */
word fEAX;  /* Маркер активного регистра. (Cуть этого хака более ясна его автору - Хохлову, нежели мне. VU) */

/*****************************************************************************/

word function __Code(word P; word F; word T; word M)
__Code @_Code;

/*****************************************************************************/

struct CODEBLOCK
	word Saved_nLocal;
	word Saved_AllocatedFrameSize;
end

void Code_BeginBlock(CODEBLOCK@ CB)
	CB.Saved_nLocal = nLocal;
	CB.Saved_AllocatedFrameSize = AllocatedFrameSize;
end

void Code_EndBlock(CODEBLOCK@ CB)
	nLocal = CB.Saved_nLocal;
	AllocatedFrameSize = CB.Saved_AllocatedFrameSize;
end

/*****************************************************************************/

word Code_List(word P)
	while P < nNODE do
		_Code(P,0,0,0);
		P = Node[P].pRight;
	end
end

word Code_Block(word P)
	CODEBLOCK CB;
	Code_BeginBlock(@CB);
	Code_List(P);
	Code_EndBlock(@CB);
end

/*****************************************************************************/

include "backend_code_emitter_ctrl.ctxi"

/*****************************************************************************/

/*
	Генератор кода для "постфиксных деревьев", генерируемых функцией Primary синтаксического анализатора.
	(Эта функция - самая главная среди множества причин, почему весь кодогенератор надо переписать. VU)
*/
word Code1(word P)

	char Buff [nBUFF];

	Buff[0] = #0;

	word ID1=Node[P].ID;
	if ID1=iINC | ID1=iDEC then
		fEAX=RegA;
		P   =Node[P].pLeft;
	end

	word pIndx;
	word nIndx;

	word pType;
	word nPtr;
	word  Ofs;
	word  RO;
	word ID=ExtractDataInfo(P, @pType, @nPtr, @pIndx, @nIndx, @Ofs, @RO);
	word IX=RegNone;

	word P1=Node[P].pLeft;
	do
		select
		case P1>=nNODE:
			select
			case ID1=iINC | ID1=iDEC:
				if IX=RegB | nPtr>0 then
					StopInternal();
				end:if

				if ID1=iINC then
					strcpy(@Buff,"inc     ");
				else
					strcpy(@Buff,"dec     ");
				end:if

				word Size=Dict[pType].Value;
				select
				case Size=1:
					strcat(@Buff,"byte  ");     // FASM
				case Size=4:
					strcat(@Buff,"dword ");     // FASM
				default:
					StopInternal();
				end:select

				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));

			case ID!=iCALL:
				word Size = SizeOfType(pType, nPtr);

				select
				case Size=1:
					strcpy(@Buff,"mov     byte  ");     // FASM
				case Size=4:
					strcpy(@Buff,"mov     dword ");     // FASM
				default:
					strcpy(@Buff,"lea     EDI,  ");
				end:select

				CodeDataIX_offset(@Buff, ID, IX, Ofs);

				select
				case fEAX!=RegA:
					select
					case Size=1:
						Emit(@strcat(@Buff,", AL"));
					case Size=4:
						Emit(@strcat(@Buff,", EAX"));

					default:
						Emit("mov     ESI,  EAX");
						Emit(@Buff);
					end:select

				case IX=RegA:
					select
					case Size=1:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", BL"));
					case Size=4:
						Emit("pop     EBX");
						Emit(@strcat(@Buff,", EBX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select

				case IX=RegB:
					select
					case Size=1:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", AL"));
					case Size=4:
						Emit("pop     EAX");
						Emit(@strcat(@Buff,", EAX"));
					default:
						Emit("pop     ESI");
						Emit(@Buff);
					end:select
				end:select

				if Size!=1 & Size!=4 then
					Emit("cld");
					Emit(@strcat(@strcpy(@Buff,"mov     ECX,  "),@str(Size)));
					Emit("rep     movsb");
				end:if
			end:select

			exit;

		case Node[P1].ID=iLOAD:
			word Size = SizeOfType(pType, nPtr);

			select
			case Size=1:
				if fEAX=RegA then
					strcpy(@Buff,"mov     AL,   byte  ");     // FASM
				else
					strcpy(@Buff,"mov     BL,   byte  ");     // FASM
				end:if

			case Size=4:
				if fEAX=RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if

			default:
				if fEAX=RegA then
					strcpy(@Buff,"lea     EAX,  ");
				else
					strcpy(@Buff,"lea     EBX,  ");
				end:if
			end:select

			if IX=RegNone & ID=iCALL then
				null;
			else
				Emit(@CodeDataIX_offset(@Buff, ID, IX, Ofs));
			end:if

			if nPtr>0 then
				return nDICT;
			else
				return pType;
			end:if

		case Node[P1].ID=iLPTR:
			if fEAX!=RegA | IX=RegB then
				StopInternal();
			end:if

			if IX!=RegNone then
				select
				case ID=iDATA:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+EAX-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					char @s = "@@ROLITERALS+";
					when RO = 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"add     EAX,  "), @s),@str(Ofs)));
				case ID=iREF & Ofs!=0:
					Emit(@strcat(@strcpy(@Buff,"add     EAX,  "),@str(Ofs)));
				case ID!=iREF & ID!=iCALL:
					StopInternal();
				end:select
			else
				select
				case ID=iDATA:
					Emit(@strcat(@strcpy(@Buff,"mov     EAX,  @@DATA+"),@str(Ofs)));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcpy(@Buff,"lea     EAX,  [EBP-"),@str(Ofs)),"]"));
				case ID=iSTRING:
					char @s = "@@ROLITERALS+";
					when RO = 0:
						@s = "@@RWLITERALS+";
					Emit(@strcat(@strcat(@strcpy(@Buff,"mov     EAX,  "), @s),@str(Ofs)));
				case ID!=iCALL:
					StopInternal();
				end:select
			end:if

			return nDICT;

		case Node[P1].ID=iCALL:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			if Node[P1].pLeft<nNODE then
				_Code(Node[P1].pLeft,0,0,0);
			end:if

			if Dict[Node[P1].Value].Sub=sSYS then
				Emit(@strcat(@strcat(@strcpy(@Buff,"call   [@"),@str(Dict[Node[P1].Value].Value)),"]"));
			else
				Emit(@strcat(@strcpy(@Buff,"call    @"),@str(Dict[Node[P1].Value].Value)));
			end:if

			ID =iCALL;
			Ofs=    0;

		case Node[P1].ID=iCALL2:
			if fEAX!=RegA then
				Emit("push    EAX");
				fEAX=RegA;
			end:if

			word P2=Node[P1].pLeft;

			if Node[P2].pRight<nNODE then
				_Code(Node[P2].pRight,0,0,0);
			end:if

			_Code(Node[P2].pLeft,0,0,0);

			Emit("call    EAX");

			pType=Dict[Node[P1].Value].pType;
			nPtr =Dict[Node[P1].Value].nPtr;

			ID   =iCALL;
			Ofs  =    0;

		case Node[P1].ID=iINDEX:

			word  C   = 0;
			word  N   = 0;
			word  IX1 = RegNone;
			word fIX  = 1;
			do
				if Node[Node[P1].pLeft].ID=iWORD then
					C = C * Node[P1].Value + Node[Node[P1].pLeft].Value;
					N = N * Node[P1].Value;
				else
					select
					case IX1=RegB:
						if fEAX!=RegA then
							if IX!=0 then
								StopInternal();
							end:if

							fEAX=RegA;
						else
							if IX!=RegA then
								StopInternal();
							end:if

							fIX=0;
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						_Code(Node[P1].pLeft,0,0,0);

						Emit("pop     EBX");
						Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						Emit("add     EAX,  EBX");

						IX1=RegA;

					case IX1=RegA:
						if fEAX!=RegA | IX!=RegNone then
							StopInternal();
						end

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							Emit("pop     EBX");
							Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(N*Node[P1].Value)));
						else
							Emit(@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(N*Node[P1].Value)));
						end:if

						Emit("add     EAX,  EBX");

						fEAX=RegA;

					case IX=RegB:
						if fEAX=RegA then
							StopInternal();
						end:if

						Emit("push    EAX");
						Emit("push    EBX");

						fEAX=RegA;
						fIX =0;

						_Code(Node[P1].pLeft,0,0,0);

						IX1=RegA;

					case IX=RegA:
						if fEAX!=RegA then
							StopInternal();
						end:if

						fEAX=RegB;

						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							fIX=0;
							IX1=RegA;
						else
							IX1=RegB;
						end:if

						fEAX=RegA;

					default:
						_Code(Node[P1].pLeft,0,0,0);

						if fEAX=RegA then
							IX1=RegA;
						else
							IX1=RegB;
						end:if
					end:select

					C=C*Node[P1].Value;
					N=1;
				end:if

				if Node[P1].pRight>=nNODE then
					exit;
				end:if

				if Node[Node[P1].pRight].ID!=iINDEX then
					exit;
				end:if

				P1  =Node[P1].pRight;
			end:do

			word Size = SizeOfType(pType, nPtr);

			C = C * Size;

			if ID != iLOCAL then
				Ofs = Ofs + C;
			else
				Ofs = Ofs - C;
			end

			if IX1!=RegNone then
				Size = Size * N;

				select
				case Size=2:
					if IX1=RegA then
						Emit("add     EAX, EAX");
					else
						Emit("add     EBX, EBX");
					end:if

				case Size=4:
					if IX1=RegA then
						Emit("shl     EAX,  2");
					else
						Emit("shl     EBX,  2");
					end:if

				case Size=8:
					if IX1=RegA then
						Emit("shl     EAX,  3");
					else
						Emit("shl     EBX,  3");
					end:if

				case Size>1:
					if IX1=RegA then
						Emit(@strcat(@strcpy(@Buff,"imul    EAX, "),@str(Size)));
					else
						Emit(@strcat(@strcpy(@Buff,"imul    EBX, "),@str(Size)));
					end:if
				end:select

				if IX!=RegNone then
					select
					case IX1=RegB:
						if IX!=RegNone | fIX=0 then
							StopInternal();
						end:if

						Emit("add     EAX,  EBX");

					case IX1=RegA:
						if fIX!=0 then
							StopInternal();
						end

						Emit("pop     EBX");
						Emit("add     EAX,  EBX");

						IX=RegA;

					default:
						StopInternal();
					end:select
				else
					IX=IX1;
				end:if
			end:if

		case Node[P1].ID=iADDR:
			if nPtr<1 then
				StopInternal();
			end:if

			dec nPtr;

			if Node[P1].pLeft<nNODE then
				word Size = SizeOfType(pType, nPtr);

				select
				case IX=RegB:
					if fEAX!=RegA then
						Emit("push    EAX");
					end:if

					Emit("xchg    EAX,  EBX");
					IX  =RegA;
					fEAX=RegB;

				case IX=RegA:
					fEAX=RegB;
				end:select

				_Code(Node[P1].pLeft,0,0,0);
				if fEAX=RegA then
					select
					case Size=4:
						Emit("shl     EAX,  2");
					case Size>1:
						Emit(@strcat(@strcpy(@Buff,"imul    EAX,  "),@str(Size)));
					end:select

					if IX!=RegNone then
						Emit("pop     EBX");
						IX=RegB;
					end:if

					strcpy(@Buff,"add     EAX,  dword ");     // FASM
				else
					select
					case Size=4:
						Emit("shl     EBX,  2");
					case Size>1:
						Emit(@strcat(@strcpy(@Buff,"imul    EBX,  "),@str(Size)));
					end:select

					strcpy(@Buff,"add     EBX,  dword ");     // FASM
				end:if
			else
				if fEAX=RegA then
					strcpy(@Buff,"mov     EAX,  dword ");     // FASM
				else
					strcpy(@Buff,"mov     EBX,  dword ");     // FASM
				end:if
			end:if

			if IX!=RegNone then
				char RX[4];
				if IX=RegA then
					strcpy(@RX,"EAX");
				else
					strcpy(@RX,"EBX");
				end:if

				select
				case ID=iDATA:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@RX),"-"),@str(Ofs)),"]"));
				case ID=iREF:
					Emit(@strcat(@strcat(@strcat(@strcat(@strcat(@Buff,"["),@RX),"+"),@str(Ofs)),"]"));
				default:
					StopInternal();
				end:select
			else
				select
				case ID=iDATA:
					Emit(@strcat(@strcat(@strcat(@Buff,"[@@DATA+"),@str(Ofs)),"]")); // FASM
				case ID=iPARM:
					Emit(@strcat(@strcat(@strcat(@Buff,"[EBP+"),@str(Ofs)),"]"));
				case ID=iLOCAL:
					Emit(@strcat(@strcat(@strcat(@Buff,"[EBP-"),@str(Ofs)),"]"));
				//TODO Пpовеpить!
				case ID=iCALL:
					null;
				default:
					StopInternal();
				end:select
			end:if

			if fEAX=RegA then
				IX=RegA;
			else
				if IX!=RegNone then
					fEAX=RegA;
				end:if

				IX=RegB;
			end:if

			ID =iREF;
			Ofs=   0;

		case Node[P1].ID=iFIELD:
			CodeData_FIELD(@P1, @pType, @nPtr, @ID, @Ofs);

		default:
			StopInternal();
		end:select

		P1=Node[P1].pRight;
	end:do

	return nDICT;
end

/*****************************************************************************/

/*
	Основная функция кодогенератора.

	Параметры F, T и M используются в условных переходах:
	F указывает метку перехода, если условие ложно.
	T указывает метку перехода, если условие истинно.
	Ноль в F/T указывает, что если условие ложно/истинно, нужно выполнять код дальше (не переходить по метке).
	Один из F и T всегда равен нулю, а второй имеет ненулевое значение.
	M содержит метку кода, идущего за данным, чтобы можно делать переходы "изнутри" блока кода в то же место, куда попадет управление при F/T = 0.
*/

word Code(word P; word F; word T; word M)

	char Buff[nBUFF];

	Buff[0] = #0;

	switch Node[P].ID of
	case iNULL:
		CodeLoadConstant(@Buff, fEAX, 4, 0);
		Emit(@Buff);
		return nDICT;

	case iCHAR:
		CodeLoadConstant(@Buff, fEAX, 1, Node[P].Value);
		Emit(@Buff);
		return st_char;

	case iWORD:
		CodeLoadConstant(@Buff, fEAX, 4, Node[P].Value);
		Emit(@Buff);
		return st_word;

	case iINT:
		CodeLoadConstant(@Buff, fEAX, 4, Node[P].Value);
		Emit(@Buff);
		return st_int;

	case iFUNC:
		CodeLoadLabel(@Buff, fEAX, Node[P].Value);
		Emit(@Buff);
		return nDICT;

///////////////////////////////////////////////////////////////////////////////

	case iDATA, iPARM, iLOCAL, iSTRING, iINC, iDEC:
		return Code1(P);

///////////////////////////////////////////////////////////////////////////////

	case iCAST:
		word pType = Code(Node[Node[P].pLeft].pLeft, 0, 0, 0);
		select
		case Node[P].Value=st_char & pType=st_byte:
			null;
		case Node[P].Value=st_char & pType=st_word:
			null;
		case Node[P].Value=st_char & pType=st_int:
			null;
		case Node[P].Value=st_byte & pType=st_char:
			null;
		case Node[P].Value=st_word & pType=st_char:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_word & pType=st_byte:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_char:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_byte:
			Emit(@CodeCmdRegConst(@Buff, "and", fEAX, 4, 0xFF));
		case Node[P].Value=st_int & pType=st_word:
			null;
		default:
			StopInternal();
		end
		return  Node[P].Value;

///////////////////////////////////////////////////////////////////////////////

	case iNOT:
		word pType = Code(Node[P].pLeft, 0, 0, 0);
		word  Size = Dict[pType].Value;
		Emit(@CodeCmdReg(@Buff, "not", fEAX, Size));

		return pType;

///////////////////////////////////////////////////////////////////////////////

	case iNEG:
		if Node[Node[P].pLeft].ID=iWORD then
			CodeLoadConstant(@Buff, fEAX, 4, -Node[Node[P].pLeft].Value);
			Emit(@Buff);
			return st_int;
		end

		Code(Node[P].pLeft,0,0,0);

		Emit(@CodeCmdReg(@Buff, "neg", fEAX, 4));

		return st_int;

///////////////////////////////////////////////////////////////////////////////

	case iBIT_OR, iBIT_XOR, iBIT_AND, iLT, iLE, iEQ, iNE, iGE, iGT, iADD, iSUB, iMUL, iDIV, iMOD:

      if iLT<=Node[P].ID & Node[P].ID<=iGT then
        fEAX=RegA;
      end

      if fEAX!=RegA then
        Emit("push    EAX");
        fEAX=RegA;
      end

      word fSwap=0;
      word pType;
      select
        case Node[Node[P].pRight].ID=iCHAR | Node[Node[P].pRight].ID=iWORD | Node[Node[P].pRight].ID=iINT:
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=2;

        case Node[Node[P].pLeft].ID=iCHAR | Node[Node[P].pLeft].ID=iWORD | Node[Node[P].pLeft].ID=iINT:
          Code(Node[P].pRight,0,0,0);
          fEAX =RegB;
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=1;

        case Node[Node[Node[P].pLeft].pLeft].ID=iLOAD:
          Code(Node[P].pRight,0,0,0);
          fEAX =RegB;
          pType=Code(Node[P].pLeft,0,0,0);
          fSwap=1;

        default:
          pType=Code(Node[P].pLeft,0,0,0);
          fEAX =RegB;
          Code(Node[P].pRight,0,0,0);
          if fEAX=RegA then
            Emit("pop     EBX");
            fSwap=1;
          end
      end

      word ID=Node[P].ID;
      select
        case fSwap=1:
          select
            case ID=iLT:
              ID=iGT;

            case ID=iLE:
              ID=iGE;

            case ID=iGE:
              ID=iLE;

            case ID=iGT:
              ID=iLT;

            case ID=iSUB | ID=iDIV | ID=iMOD:
              Emit("xchg    EAX,  EBX");
          end

        case fSwap=2:
          select
            case ID=iMUL | ID=iDIV | ID=iMOD:
              fEAX =RegB;
              Code(Node[P].pRight,0,0,0);
          end
      end

      fEAX=RegA;

      word Size=4;
      if pType<nDICT then
        Size=Dict[pType].Value;
      end

      select
        case iLT<=ID & ID<=iGT:
          select
            case Size=1:
              select
                case fSwap=2:
                  Emit(@strcat(@strcpy(@Buff,"cmp     AL,   "),@str(Node[Node[P].pRight].Value)));

                default:
                  Emit("cmp     AL,   BL");
              end

            case Size=4:
              select
                case fSwap=2:
                  Emit(@strcat(@strcpy(@Buff,"cmp     EAX,  "),@str(Node[Node[P].pRight].Value)));

                default:
                  Emit("cmp     EAX,  EBX");
              end

            default:
              StopInternal();
          end

          if T=0 then
            select
              case ID=iLT:
                ID=iGE;

              case ID=iLE:
                ID=iGT;

              case ID=iEQ:
                ID=iNE;

              case ID=iNE:
                ID=iEQ;

              case ID=iGE:
                ID=iLT;

              case ID=iGT:
                ID=iLE;

              default:
                StopInternal();
            end

            T=F;
            F=0;
          end

          if T=0 | F!=0 then
            StopInternal();
          end

          char@ BranchCondition;
          select
            case pType=st_int:
              select
                case ID=iLT:
                  @BranchCondition = "l ";
                case ID=iLE:
                  @BranchCondition = "le";
                case ID=iEQ:
                  @BranchCondition = "e ";
                case ID=iNE:
                  @BranchCondition = "ne";
                case ID=iGE:
                  @BranchCondition = "ge";
                case ID=iGT:
                  @BranchCondition = "g ";
                default:
                  StopInternal();
              end

            default:
              select
                case ID=iLT:
                  @BranchCondition = "b ";
                case ID=iLE:
                  @BranchCondition = "be";
                case ID=iEQ:
                  @BranchCondition = "e ";
                case ID=iNE:
                  @BranchCondition = "ne";
                case ID=iGE:
                  @BranchCondition = "ae";
                case ID=iGT:
                  @BranchCondition = "a ";
                default:
                  StopInternal();
              end
          end
          EmitBranchToLabel(@BranchCondition, T);

          return nDICT;

        case ID=iBIT_OR:
          strcpy(@Buff,"or      ");

        case ID=iBIT_XOR:
          strcpy(@Buff,"xor     ");

        case ID=iBIT_AND:
          strcpy(@Buff,"and     ");

        case ID=iADD:
          strcpy(@Buff,"add     ");

        case ID=iSUB:
          strcpy(@Buff,"sub     ");

        case ID=iMUL:
          select
            case pType=st_byte:
              Emit("mul     BL");

            case pType=st_word:
              Emit("mul     EBX");

            case pType=st_int:
              Emit("imul    EBX");

            default:
              StopInternal();
          end

          return pType;

        case ID=iDIV:
          select
            case pType=st_byte:
              Emit("xor     AH,   AH");
              Emit("div     BL");

            case pType=st_word:
              Emit("xor     EDX,  EDX");
              Emit("div     EBX");

            case pType=st_int:
              Emit("xor     EDX,  EDX");
              Emit("idiv    EBX");

            default:
              StopInternal();
          end

          return pType;

        case ID=iMOD:
          select
            case pType=st_byte:
              Emit("xor     AH,   AH");
              Emit("div     BL");
              Emit("xchg    AL,   AH");

            case pType=st_word:
              Emit("xor     EDX,  EDX");
              Emit("div     EBX");
              Emit("xchg    EAX,  EDX");

            default:
              StopInternal();
          end

          return pType;

        default:
          StopInternal();
      end

      select
        case Size=1:
          select
            case fSwap=2:
              Emit(@strcat(@strcat(@Buff,"AL,   "),@str(Node[Node[P].pRight].Value)));

            default:
              Emit(@strcat(@Buff,"AL,   BL"));
          end

        case Size=4:
          select
            case fSwap=2:
              Emit(@strcat(@strcat(@Buff,"EAX,  "),@str(Node[Node[P].pRight].Value)));

            default:
              Emit(@strcat(@Buff,"EAX,  EBX"));
          end

        default:
          StopInternal();
      end

      return pType;

///////////////////////////////////////////////////////////////////////////////

    case iDEF_LOCAL:
      if nLocal>=nLOCAL then
        StopMemory();
      end

      word pType = Node[P].Value;
      word nPtr  = Node[Node[P].pLeft].Value;
      word Size  = SizeOfType(pType, nPtr);

      AllocatedFrameSize =
          AllocatedFrameSize + DefaultInStackAlign(Node[Node[Node[P].pLeft].pLeft].Value*Size);

      Local[nLocal].pType=pType;
      Local[nLocal].nPtr =nPtr;
      Local[nLocal].Value=AllocatedFrameSize;
      inc   nLocal;

      Code(Node[Node[P].pLeft].pLeft,0,0,0);
///////////////////////////////////////////////////////////////////////////////

	case iASSIGN:
		P    = Node[P].pLeft;
		fEAX = RegA;
		if Node[P].pRight < nNODE then
			Code(Node[P].pRight, 0, 0, 0);
			fEAX = RegB;
		end

		Code(Node[P].pLeft, 0, 0, 0);

///////////////////////////////////////////////////////////////////////////////

	case iINLINE:
		Emit(@strcat(@strcpy(@Buff,"db      0x"),@str2(Node[P].Value,16)));

///////////////////////////////////////////////////////////////////////////////
	case iOR:
		Code_OR(P, F, T, M, @Buff);
	case iXOR:
		Code_XOR(P, F, T, M, @Buff);
	case iEQV:
		Code_EQV(P, F, T, M, @Buff);
	case iAND:
		Code_AND(P, F, T, M, @Buff);
///////////////////////////////////////////////////////////////////////////////
	case iPUSH:
		Code_PUSH(P, F, T, M, @Buff);
	case iRETURN:
		Code_RETURN(P, F, T, M, @Buff);
///////////////////////////////////////////////////////////////////////////////
	case iSELECT:
		Code_SELECT(P, F, T, M, @Buff);
	case iSWITCH:
		Code_SWITCH(P, F, T, M, @Buff);
	case iWHILE:
		Code_WHILE(P, F, T, M, @Buff);
	case iREPEAT:
		Code_REPEAT(P, F, T, M, @Buff);
	case iCONTINUE:
		Code_CONTINUE(P, F, T, M, @Buff);
	case iEXIT:
		Code_EXIT(P, F, T, M, @Buff);
	case iEMPTY:
		null;
	default:
		StopInternal();
	end:switch

	return nDICT;
end

/*****************************************************************************/

/* Формирует листинг кода функций. */
word EmitFunctions(char @Buff)

	word S;

	word pRet = Peek();
	Node[pRet].ID = iRETURN;


	word I = 0;
	while I < nDict do
		select
			case Dict[I].Class = cFUNC & Dict[I].Sub != sSYS & Dict[I].Used != 0:
				EmitStringNL("");
				strcpy(@Buff,"       ;;");
				if Dict[I].Sub != sMAIN then
					strcat(@Buff, @GetDictName(I));
				else
					strcat(@Buff, "begin");
					S = Dict[I].Value;
				end:if
				EmitLine(Dict[I].Value, @Buff);

				word S1 = 0;

				word K = Dict[I].pIndx;
				while K < Dict[I].nIndx do
					Parm[K].Value = S1 + 8;
					if Parm[K].nPtr = 0 then
						S1 = S1 + DefaultInStackAlign(Dict[Parm[K].pType].Value);
					else
						S1 = S1 + 4;
					end

					inc K;
				end:while

				PHO_InvalidateRegs();

				if CompactFunctionEnterLeave != 0 & Dict[I].Stack > 0 then
					Emit(@strcat(@strcat(@strcpy(@Buff,"enter   "),@str(Dict[I].Stack)), ", 0"));
				else
					Emit("push    EBP");
					Emit("mov     EBP,  ESP");

					if Dict[I].Stack > 0 then
						Emit(@strcat(@strcpy(@Buff,"sub     ESP,  "),@str(Dict[I].Stack)));
					end:if
				end:if

				if Dict[I].Sub = sMAIN then
					word  J = 0;
					while J < nDict do
						if Dict[J].Class = cDATA & Dict[J].pNode < nNODE & Dict[J].Used != 0 then
							if Node[Dict[J].pNode].ID != iASSIGN then
								StopInternal();
							end:if
							if StaticDataIsZeroed = 0
							 | NodeHasConst(Node[Node[Dict[J].pNode].pLeft].pRight, 0) = 0 then
								Code(Dict[J].pNode, 0, 0, 0);
							end:if
						end:if

						inc J;
					end:while
				end:if

				pFunc = I;
				ParmFrameSize = S1;
				AllocatedFrameSize = 0;

				CODEBLOCK CB;
				Code_BeginBlock(@CB);

				word  P = Dict[I].pNode;
				word  ID;
				while P < nNODE do
					_Code(P, 0, 0, 0);
					ID = Node[P].ID;
					P  = Node[P].pRight;
				end

				if ID!=iRETURN then
					_Code(pRet, 0, 0, 0);
				end

				Code_EndBlock(@CB);

		end // of select

		inc I;
	end // of while

	return S;

end

/*****************************************************************************/

/* Формирует листинг секции кода. Возвращает индекс стартовой метки. */
word EmitSection_Code(char @Buff)

	EmitStringNL("");

	select
		case TargetFileFormat = tPE:
			EmitStringNL("section ~".code~" code readable executable");

		case TargetFileFormat = tELF:
			EmitStringNL("segment readable executable");

		default:
			StopInternal();
	end

	EmitROData();

	word S = EmitFunctions(@Buff);

	return S;

end

/*****************************************************************************/

