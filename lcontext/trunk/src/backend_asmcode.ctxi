
/*
	Вспомогательные функции для генерирования в листинг названий регистров, меток и т.п.
*/

/*****************************************************************************/

define RegNone 0
define RegA    1
define RegB    2
define RegC    3
define RegD    4

/*
	Помещает в Buff обозначение регистра Reg в режиме RegMode
	RegMode:
		1 - 8 бит
		2 - 16 бит
		4 - 32 бита
*/
char @CodeReg(char @Buff; word Reg; word RegMode)

	char @R = NULL;

	switch Reg of
	case RegA:
		switch RegMode of
			case 1: @R = " AL";
			case 2: @R = " AX";
			case 4: @R = "EAX";
			default: StopInternal();
		end:switch
	case RegB:
		switch RegMode of
			case 1: @R = " BL";
			case 2: @R = " BX";
			case 4: @R = "EBX";
			default: StopInternal();
		end:switch
	case RegC:
		switch RegMode of
			case 1: @R = " CL";
			case 2: @R = " CX";
			case 4: @R = "ECX";
			default: StopInternal();
		end:switch
	case RegD:
		switch RegMode of
			case 1: @R = " DL";
			case 2: @R = " DX";
			case 4: @R = "EDX";
			default: StopInternal();
		end:switch
	default: StopInternal();
	end:switch

	strcat(@Buff, @R);

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff обозначение указанной метки. */
char @CodeLabel(char @Buff; word Label)

	strcat(@Buff, " @");
	strcat(@Buff, @str(Dict[Label].Value));
	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff обозначения 2-х регистров. */
char @CodeRegReg(char @Buff; word Reg1; word RegMode1; word Reg2; word RegMode2)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	CodeReg(@Buff, Reg2, RegMode2);
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff обозначения регистра и константного значения. */
char @CodeRegConst(char @Buff; word Reg1; word RegMode1; word Value)

	CodeReg(@Buff, Reg1, RegMode1);
	strcat(@Buff, ",  ");
	strcat(@Buff, @str(Value));
	return @Buff;

end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и и регистра. */
char @CodeCmdRegReg(char @Buff; char @Cmd; word Reg1; word RegMode1; word Reg2; word RegMode2)

	strcat(@Buff, @Cmd);
	word cmd_len = strlen(@Cmd);
	while cmd_len < 8 do
		strcat(@Buff, " ");
		inc cmd_len;
	end

	CodeRegReg(@Buff, Reg1, RegMode1, Reg2, RegMode2);

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции регистра и константы. */
char @CodeCmdRegConst(char @Buff; char @Cmd; word Reg; word RegMode; word Value)

	strcat(@Buff, @Cmd);
	word cmd_len = strlen(@Cmd);
	while cmd_len < 8 do
		strcat(@Buff, " ");
		inc cmd_len;
	end

	CodeRegConst(@Buff, Reg, RegMode, Value);

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код для операции с регистром. */
char @CodeCmdReg(char @Buff; char @Cmd; word Reg; word RegMode)

	strcat(@Buff, @Cmd);
	word cmd_len = strlen(@Cmd);
	while cmd_len < 8 do
		strcat(@Buff, " ");
		inc cmd_len;
	end

	CodeReg(@Buff, Reg, RegMode);

	return @Buff;
end

/*****************************************************************************/

/* Помещает в Buff код загрузки константы в регистр. */
char @CodeLoadConstant(char @Buff; word Reg; word RegMode; word Value)
	select
	case Value = 0:
		CodeCmdRegReg(@Buff, "xor", Reg, RegMode, Reg, RegMode);
	default:
		CodeCmdRegConst(@Buff, "mov", Reg, RegMode, Value);
	end
end

/*****************************************************************************/

/* Помещает в Buff код загрузки метки в регистр. */
char @CodeLoadLabel(char @Buff; word Reg; word Label)

	strcat(@Buff, "mov     ");
	CodeReg(@Buff, Reg, 4);
	strcat(@Buff, ",");
	CodeLabel(@Buff, Label);

	return @Buff;
end

/*****************************************************************************/

void CodeData_FIELD(word @P1, @pType, @nPtr, @ID, @Ofs)

	word p = Node[P1].Value;

	pType = Parm[p].pType;
	nPtr  = Parm[p].nPtr;
	if ID != iLOCAL then
		Ofs = Ofs + Parm[p].Value;
	else
		Ofs = Ofs - Parm[p].Value;
	end
end

/*****************************************************************************/

char @CodeDataIX_offset(char @Buff; word ID; word IX; word offset)

	if IX!=0 then
		char@ RX;
		if IX=1 then
			@RX = "EAX";
		else
			@RX = "EBX";
		end

		select
		case ID=iDATA:
			strcat3(@Buff,"[@@DATA+",@RX,"+");
		case ID=iPARM:
			strcat3(@Buff,"[EBP+",@RX,"+");
		case ID=iLOCAL:
			strcat3(@Buff,"[EBP+",@RX,"-");
		case ID=iREF:
			strcat3(@Buff,"[",@RX,"+");
		default:
			StopInternal();
		end:select
	else
		select
		case ID=iDATA:
			strcat(@Buff,"[@@DATA+");
		case ID=iPARM:
			strcat(@Buff,"[EBP+");
		case ID=iLOCAL:
			strcat(@Buff,"[EBP-");
		default:
			StopInternal();
		end:select
	end:if

	strcat2(@Buff,@str(offset),"]");

	return @Buff;
end


/*****************************************************************************/

void Emit_IMUL_Reg_Const(word Reg; word RegMode; word Value)
	char Buff[nBUFF];
	Buff[0] = #0;

	select
	case Value=2:
		CodeCmdRegReg(@Buff, "add", Reg, RegMode, Reg, RegMode);
	case Value=4:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 2);
	case Value=8:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 3);
	case Value=16:
		CodeCmdRegConst(@Buff, "shl", Reg, RegMode, 4);
	case Value>1:
		CodeCmdRegConst(@Buff, "imul", Reg, RegMode, Value);
	case Value<1:
		StopInternal();
	end:select

	Emit(@Buff);
end
