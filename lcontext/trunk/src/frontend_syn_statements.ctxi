
/*
	Анализатоp упpавляющих констpукций.
*/

/*****************************************************************************/

void MatchCStyleSemicolon(char @Buff)
	if c_style_semicolons != 0 then
		Scan(@Buff);
		if strcmp(@Buff,";")!=0 then
			Stop(@eSEMICOLONEXP);
		end
	end:if
end


/*****************************************************************************/

word EndOf(char @Buff, @A1, @A2)

	word SkipScan = 0;

	if strcmp(@Buff, "end") = 0 then
		Scan(@Buff);
		if strcmp(@Buff, ":") = 0 then
			Scan(@Buff);
			if @A2 != NULL then
				if strcmp(@Buff, @A2) = 0 then
					return SkipScan;
				end
			end

			if strcmp(@Buff, @A1) != 0 then
				Stop(@eNOTALLOWED);
			end
		else
			SkipScan = 1;
		end
	else
		StopInternal();
	end

	return SkipScan;
end

/*****************************************************************************/

void Statement_IF(char @Buff; word @P1; word @SkipFinalScan)
	Node[P1].ID = iSELECT;

	char @End1="if";
	char @Case="";
	char @Then="then";
	char @Else="else";
	if strcmp(@Buff,"select")=0 then
		@End1="select";
		@Case="case";
		@Then=":";
		@Else="default";

		if strcmp(@Scan(@Buff),"case")!=0 then
			Stop(@eCASEEXP);
		end:if
	else
		strcpy(@Buff,@Case);
	end:if

	word @BackLink = @Node[P1].pLeft;
	while strcmp(@Buff,"end")!=0 do
		word CASE = Peek();
		word COND = Peek();
		word BODY = Peek();

		Node[CASE].ID = iCASE;
		Node[COND].ID = iCOND;
		Node[BODY].ID = iBODY;

		Node[CASE].pLeft  = COND;
		Node[COND].pRight = BODY;
		BackLink = CASE;
		@BackLink = @Node[CASE].pRight;

		if strcmp(@Buff,@Case)=0 then
			word pType, nPtr;
			Node[COND].pLeft = Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

			if strcmp(@Buff,@Then)!=0 then
				Stop(@eTHENEXP);
			end:if

			if pType != st_bool then
				Stop(@eTYPE);
			end:if
		else
			if strcmp(@Else,"default")=0 then
				if strcmp(@Scan(@Buff),":")!=0 then
					Stop(@eCOLONEXP);
				end:if
			end:if

			@Case="";
			@Else="";
		end:if

		Scan(@Buff);
		Node[BODY].pLeft = _Statements(@Buff, @Case, @Else, "end");
	end:while

	SkipFinalScan = EndOf(@Buff, @End1, NULL);
end

/*****************************************************************************/

void Statement_WHEN(char @Buff; word @P1; word @SkipFinalScan)

	Node[P1].ID=iSELECT;

	word CASE = Peek();
	word COND = Peek();
	word BODY = Peek();

	Node[CASE].ID = iCASE;
	Node[COND].ID = iCOND;
	Node[BODY].ID = iBODY;

	Node[CASE].pLeft  = COND;
	Node[COND].pRight = BODY;
	Node[P1].pLeft = CASE;

	word pType, nPtr;
	Node[COND].pLeft = Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

	if pType != st_bool then
		Stop(@eTYPE);
	end:if

	if strcmp(@Buff,":")!=0 then
		Stop(@eTHENEXP);
	end:if

	Scan(@Buff);

	Node[BODY].pLeft = _Ctrl(@Buff);

	SkipFinalScan = 1;
end


/*****************************************************************************/

void Statement_SWITCH(char @Buff; word @P1; word @SkipFinalScan)

	Node[P1].ID = iSWITCH;

	word COND = Peek();
	Node[COND].ID = iCOND;
	Node[P1].pLeft = COND;

	word @CaseBackLink = @Node[COND].pRight;

	word pType, nPtr;
	Node[COND].pLeft = Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

	when nPtr != 0:
		Stop(@eSWTYPE);

	when pType != st_char & pType != st_byte & pType != st_word & pType != st_int:
		Stop(@eSWTYPE);

	when strcmp(@Buff,"of") != 0:
		Stop(@eOFEXP);

	when strcmp(@Scan(@Buff),"case") != 0:
		Stop(@eCASEEXP);

	while strcmp(@Buff,"case") = 0 do
		word CASE = Peek();
		Node[CASE].ID = iCASE;
		CaseBackLink = CASE;
		@CaseBackLink = @Node[CASE].pRight;
		word @ValueBackLink = @Node[CASE].pLeft;

		repeat
			word pType2, nPtr2;
			word EXPR = Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

			select
			case pType = st_char:
				when Node[EXPR].ID != iCHAR:
					Stop(@eTYPE);
			case pType = st_byte:
				when Node[EXPR].ID != iWORD:
					Stop(@eTYPE);
			case pType = st_word:
				when Node[EXPR].ID != iWORD:
					Stop(@eTYPE);
			case pType = st_int:
				when Node[EXPR].ID != iWORD & Node[EXPR].ID != iINT:
					Stop(@eTYPE);
			default:
				Stop(@eCONSTEXP);
			end:select

			word  CASE_I = Node[COND].pRight;
			while CASE_I < nNODE do
				word  VALUE_I = Node[CASE_I].pLeft;
				while VALUE_I < nNode & Node[VALUE_I].ID = iVALUE do
					if Node[Node[VALUE_I].pLeft].Value = Node[EXPR].Value then
						Stop(@eDUPCASE);
					end:if

					VALUE_I = Node[VALUE_I].pRight;
				end:while

				CASE_I = Node[CASE_I].pRight;
			end:while

			word VALUE = Peek();
			Node[VALUE].ID = iVALUE;
			Node[VALUE].pLeft = EXPR;
			ValueBackLink = VALUE;
			@ValueBackLink = @Node[VALUE].pRight;

		until strcmp(@Buff,",") != 0;

		if strcmp(@Buff,":") != 0 then
			Stop(@eCOLONEXP);
		end

		word BODY = Peek();
		Node[BODY].ID = iBODY;
		ValueBackLink = BODY;

		Scan(@Buff);
		Node[BODY].pLeft = _Statements(@Buff, "case", "default", "end");
	end

	if strcmp(@Buff,"default") = 0 then
		if strcmp(@Scan(@Buff),":") != 0 then
			Stop(@eCOLONEXP);
		end

		word CASE = Peek();
		word DEFAULT = Peek();
		word BODY = Peek();

		Node[CASE].ID = iCASE;
		Node[DEFAULT].ID = iDEFAULT;
		Node[BODY].ID = iBODY;

		Node[CASE].pLeft = DEFAULT;
		Node[DEFAULT].pRight = BODY;
		CaseBackLink = CASE;

		Scan(@Buff);
		Node[BODY].pLeft = _Statements(@Buff, "end", NULL, NULL);
	end:if

	SkipFinalScan = EndOf(@Buff, "switch", NULL);

end

/*****************************************************************************/

void Statement_DO(char @Buff; word @P1; word @SkipFinalScan)

	word  BODY = Peek();
	word  COND = Peek();
	Node [P1].ID = iWHILE;
	Node [P1].pLeft = BODY;

	Node [BODY].ID = iBODY;
	Node [BODY].pRight = COND;

	Node [COND].ID = iCOND;

	char @End2 = NULL;

	if strcmp(@Buff,"while")=0 then
		@End2 = "while";
		word pType, nPtr;
		Node[COND].pLeft = Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

		if strcmp(@Buff,"do")!=0 then
			Stop(@eDOEXP);
		end

		if pType != st_bool then
			Stop(@eTYPE);
		end
	end:if

	word pLoop1=pLoop;
	pLoop=P1;

	Scan(@Buff);
	Node[BODY].pLeft = _Statements(@Buff, "end", NULL, NULL);

	SkipFinalScan = EndOf(@Buff, "do", @End2);

	pLoop=pLoop1;
end

/*****************************************************************************/

void Statement_REPEAT(char @Buff; word @P1; word @SkipFinalScan)
	word  BODY = Peek();
	word  COND = Peek();
	Node[P1].ID = iREPEAT;
	Node[P1].pLeft = BODY;

	Node[BODY].ID = iBODY;
	Node[BODY].pRight = COND;

	Node[COND].ID = iCOND;

	word pLoop1=pLoop;
	pLoop=P1;

	Scan(@Buff);
	Node[BODY].pLeft = _Statements(@Buff, "until", NULL, NULL);

	word pType, nPtr;
	Node[COND].pLeft = Expr(pZERO,@pType,@nPtr,@Scan(@Buff));

	if strcmp(@Buff,";")!=0 then
		Stop(@eSEMICOLONEXP);
	end

	if pType != st_bool then
		Stop(@eTYPE);
	end

	pLoop=pLoop1;
end

/*****************************************************************************/

void Statement_CONTINUE(char @Buff; word @P1; word @SkipFinalScan)
	when pLoop>=nNODE:
		Stop(@eWRONGCONTINUE);

	when Node[pLoop].ID != iWHILE
	&    Node[pLoop].ID != iREPEAT:
		StopInternal();

	Node[P1].ID = iCONTINUE;
	Node[P1].Value = pLoop;

	MatchCStyleSemicolon(@Buff);
end

/*****************************************************************************/

void Statement_EXIT(char @Buff; word @P1; word @SkipFinalScan)
	when pLoop>=nNODE:
		Stop(@eWRONGEXIT);

	when Node[pLoop].ID != iWHILE
	&    Node[pLoop].ID != iREPEAT:
		StopInternal();

	Node[P1].ID = iEXIT;
	Node[P1].Value = pLoop;

	MatchCStyleSemicolon(@Buff);
end

/*****************************************************************************/

void Statement_INCDEC(char @Buff; word @P1; word @SkipFinalScan)

	if strcmp(@Buff,"inc")=0 then
		Node[P1].ID =iINC;
	else
		Node[P1].ID =iDEC;
	end:if

	word pType, nPtr;
	Node[P1].pLeft= Expr(pINC,@pType,@nPtr,@Scan(@Buff));

	if strcmp(@Buff,";")!=0 then
		Stop(@eSEMICOLONEXP);
	end

	if (pType!=st_byte & pType!=st_word & pType!=st_int) | nPtr!=0 then
		Stop(@eTYPE);
	end

end

/*****************************************************************************/

void Statement_RETURN(char @Buff; word @P1; word @SkipFinalScan)

	Node[P1].ID   =iRETURN;
	Scan(@Buff);

	word need_semicolon = 0;

	if Dict[pFunc].nPtr!=0 | Dict[pFunc].pType != st_void then

		word pType2, nPtr2;
		Node[P1].pLeft=Expr(pZERO,@pType2,@nPtr2,@Buff);

		Test(Dict[pFunc].pType,Dict[pFunc].nPtr,pType2,nPtr2,@Node[P1].pLeft);

		need_semicolon = 1;
	end:if

	if c_style_semicolons != 0 | need_semicolon != 0 then
		if strcmp(@Buff,";")!=0 then
			Stop(@eSEMICOLONEXP);
		end
	else
		SkipFinalScan = 1;
	end:if

end

/*****************************************************************************/

void Statement_INLINE(char @Buff; word @P1; word @SkipFinalScan)

	word Code=val(@Scan(@Buff));
	if Code>255 then
		Stop(@eOVERFLOW);
	end

	Node[P1].ID   =iINLINE;
	Node[P1].Value= Code;

	if strcmp(@Scan(@Buff),",")=0 then
		strcpy (@Buff,"inline");
		SkipFinalScan = 1;
		return;
	end

	if strcmp(@Buff,";")!=0 then
		Stop(@eSEMICOLONEXP);
	end

end

/*****************************************************************************/

void Statement_ASSIGN(char @Buff; word @P1; word @SkipFinalScan)

	word pType1, nPtr1;
	word P2=Expr(pLVALUE,@pType1,@nPtr1,@Buff);
	if P2<nNODE then
		word P3=Peek();
		Node[P1].ID    =iASSIGN;
		Node[P1].pLeft = P3;

		Node[P3].ID    =iEMPTY;
		Node[P3].pLeft = P2;

		if strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0 then
			word pType2, nPtr2;
			Node[P3].pRight= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));
			Test(pType1,nPtr1,pType2,nPtr2,@Node[P3].pRight);
		end:if
	else
		word pType=Find(@Buff);
		if pType>=nDict | Dict[pType].Class!=cTYPE then
			Stop(@eUNDEFINED);
		end:if

//do

		word  nPtr=ReadPtrs(@Scan(@Buff));
		if pType=st_void & nPtr<1 then
			Stop(@eNOVOID);
		end:if

		if Dict[pType].Sub=sFUNCTYPE & nPtr<1 then
			Stop(@eNOVAL);
		end:if

		word I = ResolveLocal(@Buff);
		when I < nLOCAL:
			Stop(@eDUPLICATE);

		I = ResolveParm(@Buff);
		when I < nDICT:
			Stop(@eDUPLICATE);

		if nLocal>=nLOCAL then
			StopMemory();
		end:if

		Local[nLocal].Name2=SaveString0(@Buff);
		Local[nLocal].pType=pType;
		Local[nLocal].nPtr =nPtr;
		Local[nLocal].nIndx= Tabl(@Scan(@Buff));

		word  N=1;
		if Local[nLocal].nIndx > 0 then
			N = Local[nLocal].nIndx;
		end

		word P3=Peek();
		Node[P1].ID   =iDEF_LOCAL;
		Node[P1].Value=pType;
		Node[P1].pLeft =P3;

		word P4=Peek();
		Node[P3].ID    =iEMPTY;
		Node[P3].Value =nPtr;
		Node[P3].pLeft = P4;

		Node[P4].ID    =iEMPTY;
		Node[P4].Value = N;

		if strcmp(@Buff,"=")=0 | strcmp(@Buff,":=")=0 then
			if Local[nLocal].nIndx > 0 then
				Stop(@eNOTAVAIL);
			end:if

			word P5=Peek();
			Node[P4].ID    =iASSIGN;
			Node[P4].pLeft = P5;

			word pType2, nPtr2;
			word P6=Peek();
			Node[P5].ID    =iEMPTY;
			Node[P5].pLeft = P6;
			Node[P5].pRight= Expr(pZERO,@pType2,@nPtr2,@Scan(@Buff));

			Node[P6].ID    =iLOCAL;
			Node[P6].Value =nLocal;

			Test(pType,nPtr,pType2,nPtr2,@Node[P5].pRight);
		end:if

		inc nLocal;
///*
		if strcmp(@Buff,",")=0 then
			strcpy(@Buff,@DictGetName(pType));
			SkipFinalScan = 1;
			return;
		end:if
//*/

//        if strcmp(@Buff,",") != 0 then
//          exit;
//        end:if
//end:do


	end:if

	if strcmp(@Buff,";")!=0 then
		Stop(@eSEMICOLONEXP);
	end:if

end

/*****************************************************************************/

word Ctrl(char @Buff)

	word SkipFinalScan = 0;

	word P1 = Peek();

	select
		case strcmp(@Buff,"if")=0 | strcmp(@Buff,"select")=0:
			Statement_IF(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"while")=0 | strcmp(@Buff,"do")=0:
			Statement_DO(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"when")=0:
			Statement_WHEN(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"switch")=0:
			Statement_SWITCH(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"repeat")=0:
			Statement_REPEAT(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"continue")=0:
			Statement_CONTINUE(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"exit")=0:
			Statement_EXIT(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"inc")=0 | strcmp(@Buff,"dec")=0:
			Statement_INCDEC(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"inline")=0:
			Statement_INLINE(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"return")=0:
			Statement_RETURN(@Buff, @P1, @SkipFinalScan);

		case strcmp(@Buff,"null")=0:
			Node[P1].ID   =iEMPTY;
			MatchCStyleSemicolon(@Buff);

		default:
			Statement_ASSIGN(@Buff, @P1, @SkipFinalScan);
	end:select

	if SkipFinalScan = 0 then
		Scan (@Buff);
	end

	return P1;
end

/*****************************************************************************/

word Statements(char @Buff; char @End1; char @End2; char @End3)

	word Saved_nLocal = nLocal;

	word P = nNODE;
	word @Backlink = @P;

	repeat
		Backlink = Ctrl(@Buff);
		@Backlink =@Node[Backlink].pRight;

		if @End2 != NULL & strcmp(@Buff, @End2) = 0 then
			exit;
		end
		if @End3 != NULL & strcmp(@Buff, @End3) = 0 then
			exit;
		end

	until strcmp(@Buff, @End1) = 0;

	nLocal = Saved_nLocal;

	return P;
end

/*****************************************************************************/

