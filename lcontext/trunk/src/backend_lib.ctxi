
/*
	Вспомогательные и интерфейсные функции, не подходящие в другие файлы.
*/

/*****************************************************************************/

word AlignTo(word v; word align)
	while v % align !=0 do
		inc v;
	end
	return v;
end

/*****************************************************************************/

word DefaultStaticAlign(word v)
	return AlignTo(v, DefaultStaticAlignment);
end

/*****************************************************************************/

word DefaultInStackAlign(word v)
	return AlignTo(v, DefaultInStackAlignment);
end

/*****************************************************************************/

word SizeOfType(word pType; word nPtr)

	if nPtr = 0 then
		if Dict[pType].Class != cTYPE then
			StopInternal();
		end
		return Dict[pType].Value;
	end

	return PointerSize;
end

/*****************************************************************************/

word GetVarSize(word pType; word nPtr; word nIndx)
	word Size = SizeOfType(pType, nPtr);

	when nIndx > 0:
		Size = nIndx * Size;

	return Size;
end

/*****************************************************************************/

/*
	Распаковывает из узлов iDATA, iPARM, iLOCAL и iSTRING информацию об объекте.
	(Ofs - смещение относительно специфичного источника (напр., для iDATA - смещение от начала секции данных и т.п.))
*/
word ExtractDataInfo(word P, @pType, @nPtr, @nIndx, @Ofs, @RO)

	word ID = Node[P].ID;

	select
		case ID = iDATA:
			pType = Dict[Node[P].Value].pType;
			nPtr  = Dict[Node[P].Value].nPtr;
			nIndx = Dict[Node[P].Value].nIndx;
			Ofs   = Dict[Node[P].Value].Value;
			RO    = 0;

		case ID = iPARM:
			when Dict[Node[P].Value].Class != cARG:
				StopInternal();
			pType = Dict[Node[P].Value].pType;
			nPtr  = Dict[Node[P].Value].nPtr;
			nIndx = Dict[Node[P].Value].nIndx;
			Ofs   = Dict[Node[P].Value].Value;
			RO    = 0;

		case ID = iLOCAL:
			pType = Local[Node[P].Value].pType;
			nPtr  = Local[Node[P].Value].nPtr;
			nIndx = Local[Node[P].Value].nIndx;
			Ofs   = Local[Node[P].Value].Value;
			RO    = 0;

		case ID = iSTRING:
			nIndx = 0;
			pType = Dict[Node[P].Value].pType;
			nPtr  = 1;
			Ofs   = Dict[Node[P].Value].Value;
			RO    = Dict[Node[P].Value].RO;

		default:
			StopInternal();
      end

	return ID;
end

/*****************************************************************************/

word NodeHasConst(word P; word Data)
	if (Node[P].ID = iNULL & Data = 0)
	 | ( (Node[P].ID = iWORD | Node[P].ID = iINT) & Node[P].Value = Data) then
		return 1;
	end:if
	return 0;
end

/*****************************************************************************/

