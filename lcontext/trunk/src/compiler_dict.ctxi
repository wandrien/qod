
/*****************************************************************************/

DICT     Dict [nDICT]; // Таблица имен
word    nDict;

/*****************************************************************************/

/* Индексы встроенных типов данных. */

word st_void;
word st_char;
word st_byte;
word st_word;
word st_int;
word st_bool;

/*****************************************************************************/

/*
	Проверяет достаточность памяти таблице Dict для выделения одного элемента.
	TODO: при нехватке памяти, перераспределять динамически.
*/
void DictMemCheck()
	when nDict >= nDICT:
		StopMemory();
end

/*****************************************************************************/

void DictSetName(word D; char@ Name)

	when D >= nDict:
		StopInternal();

	Dict[D].Name2    = SaveString0(@Name);
	Dict[D].NameHash = str_hash(@Name);
end

/*****************************************************************************/

char @DictGetName(word D)

	when D >= nDict:
		StopInternal();

	return @Char[Dict[D].Name2];
end

/*****************************************************************************/

/* Выделить запись в таблице глобальных имён и вернуть её индекс.  */
word DictAlloc()

	DictMemCheck();

	word r = nDict;
	inc nDict;

	Dict[r].Used = 0;
	Dict[r].pType = nDICT;
	Dict[r].tPtrToMe = nDICT;
	Dict[r].pNamespace = nDICT;
	Dict[r].pNext = nDICT;
	Dict[r].pFirst = nDICT;
	Dict[r].pLast = nDICT;

	return r;
end

/*****************************************************************************/

/*
	Поиск объекта в заданном пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word FindInNamespace(char @Name; word pNamespace)
	when pNamespace >= nDict:
		StopInternal();

	word hash = str_hash(@Name);
	word P = Dict[pNamespace].pFirst;
	while P < nDict do
		when Dict[P].pNamespace != pNamespace:
			StopInternal();
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class != cFILE then
			while Dict[P].Class = cNAME do
				P = Dict[P].pType;
				when P >= nDict:
					StopInternal();
			end
			exit;
		end
		P = Dict[P].pNext;
	end

	return P;
end

/*****************************************************************************/

/*
	Поиск объекта в корневом пространстве по имени.
	(Кроме объектов класса cFILE.)
*/
word Find(char @Name)
	word hash = str_hash(@Name);
	word P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class != cFILE
		&  Dict[P].pNamespace = nDICT then
			while Dict[P].Class = cNAME do
				P = Dict[P].pType;
				when P >= nDict:
					StopInternal();
			end
			exit;
		end
		inc P;
	end

	return P;
end

/*****************************************************************************/

/*
	Поиск объекта с классом cFILE в корневом пространстве имён по имени.
*/
word Find_cFILE(char @Name)
	word hash = str_hash(@Name);
	word  P = 0;
	while P < nDict do
		if Dict[P].NameHash = hash
		&  strcmp(@DictGetName(P), @Name) = 0
		&  Dict[P].Class = cFILE
		&  Dict[P].pNamespace = nDICT then
			exit;
		end
		inc P;
	end

	return P;
end

/*****************************************************************************/

word DictAddToNamespace(word P; word pNamespace)
	when P >= nDict:
		StopInternal();
	when pNamespace >= nDict:
		StopInternal();
	when Dict[P].pNamespace != nDICT:
		StopInternal();
	when Dict[P].pNext != nDICT:
		StopInternal();
	when Dict[pNamespace].pFirst != nDICT & Dict[pNamespace].pLast = nDICT:
		StopInternal();
	when Dict[pNamespace].pFirst = nDICT & Dict[pNamespace].pLast != nDICT:
		StopInternal();

	Dict[P].pNamespace = pNamespace;
	if Dict[pNamespace].pLast < nDICT then
		Dict[Dict[pNamespace].pLast].pNext = P;
		Dict[pNamespace].pLast = P;
	else
		Dict[pNamespace].pFirst = P;
		Dict[pNamespace].pLast = P;
	end:if
end

/*****************************************************************************/

/* Регистрирует ключевое слово. */
void Word(char @Name)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cWORD;
end

/*****************************************************************************/

/* Регистрирует базовый тип. */
word Base(char @Name; word Size)
	word p = DictAlloc();
	DictSetName(p, @Name);
	Dict[p].Class = cTYPE;
	Dict[p].Sub   = sBASE;
	Dict[p].Value = Size;
	return p;
end

/*****************************************************************************/

word DictDupLiteral(word D1)

	when D1 >= nDict:
		StopInternal();

	when Dict[D1].Class != cLITERAL:
		StopInternal();

	word D2 = DictAlloc();
	DictSetName(D2, "");
	Dict[D2].Class = Dict[D1].Class;
	Dict[D2].Sub   = Dict[D1].Sub;
	Dict[D2].pType = Dict[D1].pType;
	Dict[D2].nPtr  = Dict[D1].nPtr;
	Dict[D2].nIndx = Dict[D1].nIndx;
	Dict[D2].RO    = Dict[D1].RO;
	Dict[D2].Value = Dict[D1].Value;
	Dict[D2].Stack = Dict[D1].Stack;

	return D2;
end

/*****************************************************************************/

void DefineWord(char @Name; word Value)
	if Find(@Name) < nDict then
		StopInternal();
	end

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].nPtr = 0;
	Dict[D].pType = st_word;
	Dict[D].Value = Value;
end

/*****************************************************************************/

void DefineString(char @Name; char @Value)
	if Find(@Name) < nDict then
		StopInternal();
	end

	word i = strlen(@Value) + 1;

	word D = DictAlloc();
	DictSetName(D, @Name);
	Dict[D].Class = cLITERAL;
	Dict[D].RO = 1;
	Dict[D].nPtr = 1;
	Dict[D].pType = st_char;
	Dict[D].Stack = SaveString(@Value, i);
	Dict[D].nIndx = i;
end

/*****************************************************************************/

word T_IsPtr(word T)
	when T >= nDict:
		StopInternal();
	when Dict[T].Class = cTYPE & Dict[T].Sub = sPTR:
		return 1;
	return 0;
end

word T_PtrTo(word T)
	when T >= nDict:
		StopInternal();
	when Dict[T].Class != cTYPE:
		StopInternal();

	if Dict[T].tPtrToMe >= nDICT then
		word PTR = DictAlloc();
		Dict[PTR].Class = cTYPE;
		Dict[PTR].Sub   = sPTR;
		Dict[PTR].Value = 4; /* FIXME */
		Dict[PTR].pType = T;
		Dict[T].tPtrToMe = PTR;
	end

	return Dict[T].tPtrToMe;
end

word T_nPtrTo(word nPtr; word T)
	while nPtr > 0 do
		T = T_PtrTo(T);
		dec nPtr;
	end:while
	return T;
end

/*****************************************************************************/

word T_ArrayGetSize(word T)
	when T >= nDict:
		StopInternal();
	when Dict[T].Class != cTYPE | Dict[T].Sub != sARRAY:
		StopInternal();
	return Dict[T].Value;
end

word T_Array(word T; word S)
	word P = 0;
	while P < nDict do
		if Dict[P].Class = cTYPE
		 & Dict[P].Sub = sARRAY
		 & Dict[P].pType = T
		 & T_ArrayGetSize(P) = S then
			return P;
		end:if
		inc P;
	end:while

	P = DictAlloc();
	Dict[P].Class = cTYPE;
	Dict[P].Sub = sARRAY;
	Dict[P].pType = T;
	Dict[P].Value = S;
	return P;
end

/*****************************************************************************/
